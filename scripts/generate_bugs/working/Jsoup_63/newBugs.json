{
    "original": {
        "num_of_hunks": 7,
        "0": {
            "file_name": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
            "from_line_no": 227,
            "to_line_no": 227,
            "replaced_with": "                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n",
            "replaced": "                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n",
            "patch_type": "replace",
            "next_line_no": 228
        },
        "1": {
            "file_name": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
            "from_line_no": 229,
            "to_line_no": 229,
            "replaced_with": "            else // unknown tag, remember this is self closing for output\n",
            "replaced": "            else {\n",
            "patch_type": "replace",
            "next_line_no": 230
        },
        "2": {
            "file_name": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
            "from_line_no": 231,
            "to_line_no": 232,
            "replaced": "                tokeniser.acknowledgeSelfClosingFlag();\n            }\n",
            "patch_type": "delete",
            "next_line_no": 233
        },
        "3": {
            "file_name": "src/main/java/org/jsoup/parser/Tokeniser.java",
            "from_line_no": 36,
            "to_line_no": 36,
            "replaced": "    private boolean selfClosingFlagAcknowledged = true;\n",
            "patch_type": "delete",
            "next_line_no": 37
        },
        "4": {
            "file_name": "src/main/java/org/jsoup/parser/Tokeniser.java",
            "from_line_no": 44,
            "to_line_no": 47,
            "replaced": "        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n",
            "patch_type": "delete",
            "next_line_no": 48
        },
        "5": {
            "file_name": "src/main/java/org/jsoup/parser/Tokeniser.java",
            "from_line_no": 76,
            "to_line_no": 77,
            "replaced": "            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n",
            "patch_type": "delete",
            "next_line_no": 78
        },
        "6": {
            "file_name": "src/main/java/org/jsoup/parser/Tokeniser.java",
            "from_line_no": 124,
            "to_line_no": 126,
            "replaced": "    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n",
            "patch_type": "delete",
            "next_line_no": 127
        }
    },
    "method": {
        "failing_tests": [
            "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError",
            "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError",
            "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested"
        ],
        "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError": {
            "file_path": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
            "Instance": "Begin: Pos(978, 5)\nEnd: Pos(988, 5)\nSource: /tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java\nName: selfClosingOnNonvoidIsError\nChilds: [StatementAssertion<Begin: Pos(982, 9), End: Pos(982, 51)>,\nStatementAssertion<Begin: Pos(983, 9), End: Pos(983, 109)>,\nStatementAssertion<Begin: Pos(985, 9), End: Pos(985, 62)>,\nStatementAssertion<Begin: Pos(987, 9), End: Pos(987, 104)>,\n]",
            "source": "/tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java",
            "name": "selfClosingOnNonvoidIsError",
            "begin": "Pos(978, 5)",
            "end": "Pos(988, 5)",
            "begin_line_no": 978,
            "end_line_no": 988,
            "child": [
                "Begin: Pos(982, 9)\nEnd: Pos(982, 51)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(983, 9)\nEnd: Pos(983, 109)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(985, 9)\nEnd: Pos(985, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(987, 9)\nEnd: Pos(987, 104)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test public void selfClosingOnNonvoidIsError$catena_0() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(1, parser.getErrors().size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void selfClosingOnNonvoidIsError$catena_1() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void selfClosingOnNonvoidIsError$catena_2() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void selfClosingOnNonvoidIsError$catena_3() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));              /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    @Test public void selfClosingOnNonvoidIsError$catena_0() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(1, parser.getErrors().size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    @Test public void selfClosingOnNonvoidIsError$catena_1() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    @Test public void selfClosingOnNonvoidIsError$catena_2() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        try{ assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "3": "    @Test public void selfClosingOnNonvoidIsError$catena_3() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.relaxed());\n        assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));              /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        },
        "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError": {
            "file_path": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
            "Instance": "Begin: Pos(967, 5)\nEnd: Pos(976, 5)\nSource: /tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java\nName: selfClosingVoidIsNotAnError\nChilds: [StatementAssertion<Begin: Pos(971, 9), End: Pos(971, 51)>,\nStatementAssertion<Begin: Pos(973, 9), End: Pos(973, 59)>,\nStatementAssertion<Begin: Pos(975, 9), End: Pos(975, 55)>,\n]",
            "source": "/tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java",
            "name": "selfClosingVoidIsNotAnError",
            "begin": "Pos(967, 5)",
            "end": "Pos(976, 5)",
            "begin_line_no": 967,
            "end_line_no": 976,
            "child": [
                "Begin: Pos(971, 9)\nEnd: Pos(971, 51)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(973, 9)\nEnd: Pos(973, 59)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(975, 9)\nEnd: Pos(975, 55)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test public void selfClosingVoidIsNotAnError$catena_0() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(0, parser.getErrors().size());                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        try{ assertEquals(\"<p>test<br>test<br></p>\", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void selfClosingVoidIsNotAnError$catena_1() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        try{ assertEquals(\"<p>test<br>test<br></p>\", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void selfClosingVoidIsNotAnError$catena_2() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        assertEquals(\"<p>test<br>test<br></p>\", clean);                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    @Test public void selfClosingVoidIsNotAnError$catena_0() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(0, parser.getErrors().size());                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        try{ assertEquals(\"<p>test<br>test<br></p>\", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    @Test public void selfClosingVoidIsNotAnError$catena_1() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        try{ assertEquals(\"<p>test<br>test<br></p>\", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    @Test public void selfClosingVoidIsNotAnError$catena_2() {\n        String html = \"<p>test<br/>test<br/></p>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        String clean = Jsoup.clean(html, Whitelist.basic());\n        assertEquals(\"<p>test<br>test<br></p>\", clean);                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        },
        "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested": {
            "file_path": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
            "Instance": "Begin: Pos(689, 5)\nEnd: Pos(701, 5)\nSource: /tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java\nName: tracksErrorsWhenRequested\nChilds: [StatementAssertion<Begin: Pos(695, 9), End: Pos(695, 39)>,\nStatementAssertion<Begin: Pos(696, 9), End: Pos(696, 96)>,\nStatementAssertion<Begin: Pos(697, 9), End: Pos(697, 104)>,\nStatementAssertion<Begin: Pos(698, 9), End: Pos(698, 116)>,\nStatementAssertion<Begin: Pos(699, 9), End: Pos(699, 97)>,\nStatementAssertion<Begin: Pos(700, 9), End: Pos(700, 118)>,\n]",
            "source": "/tmp/c4j/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java",
            "name": "tracksErrorsWhenRequested",
            "begin": "Pos(689, 5)",
            "end": "Pos(701, 5)",
            "begin_line_no": 689,
            "end_line_no": 701,
            "child": [
                "Begin: Pos(695, 9)\nEnd: Pos(695, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(696, 9)\nEnd: Pos(696, 96)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(697, 9)\nEnd: Pos(697, 104)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(698, 9)\nEnd: Pos(698, 116)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(699, 9)\nEnd: Pos(699, 97)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(700, 9)\nEnd: Pos(700, 118)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test public void tracksErrorsWhenRequested$catena_0() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        assertEquals(5, errors.size());                                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void tracksErrorsWhenRequested$catena_1() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                               /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void tracksErrorsWhenRequested$catena_2() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                       /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void tracksErrorsWhenRequested$catena_3() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());           /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void tracksErrorsWhenRequested$catena_4() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test public void tracksErrorsWhenRequested$catena_5() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());         /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    @Test public void tracksErrorsWhenRequested$catena_0() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        assertEquals(5, errors.size());                                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    @Test public void tracksErrorsWhenRequested$catena_1() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                               /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    @Test public void tracksErrorsWhenRequested$catena_2() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                       /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "3": "    @Test public void tracksErrorsWhenRequested$catena_3() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());           /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "4": "    @Test public void tracksErrorsWhenRequested$catena_4() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "5": "    @Test public void tracksErrorsWhenRequested$catena_5() {\n        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n        Parser parser = Parser.htmlParser().setTrackErrors(500);\n        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n        \n        List<ParseError> errors = parser.getErrors();\n        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());         /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        }
    },
    "1000010": {
        "failing_tests": [
            "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError$catena_1",
            "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError$catena_1",
            "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError$catena_0",
            "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested$catena_4"
        ]
    },
    "1000100": {
        "failing_tests": [
            "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError$catena_1",
            "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError$catena_1",
            "org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError$catena_0",
            "org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested$catena_4"
        ]
    }
}