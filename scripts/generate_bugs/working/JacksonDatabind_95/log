---
Begin generate bug_id: JacksonDatabind_95
num_of_hunks: 4
timeout for running: 3600
use working dir: ./working/data/JacksonDatabind_95
Try to checkout JacksonDatabind_95
build dir: ['target/classes', 'target/test-classes']
init FileManager
trace file: src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
trace file: src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java
trying to replace old failing tests
edit: replace from 209 range 42 at src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java
to
    public void testCanonicalNames$catena_0()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        assertEquals("java.util.Calendar", can);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_1()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_2()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        assertEquals("java.util.ArrayList<java.lang.Object>", can);                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_3()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_4()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_5()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_6()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_7()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_8()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        assertEquals(List.class, t.getRawClass());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_9()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(CollectionType.class, t.getClass());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_10()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        assertEquals(Object.class, t.getContentType().getRawClass());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_11()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        assertEquals("java.util.List<java.lang.Object>", can);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testCanonicalNames$catena_12()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
trace file: src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java
new test num: 13
ori test num: 0
pattern: 0000
patches are written to file
running tests...
used time: Finished in 248.88 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
processed: 0000
pattern: 0001
try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 247.45 seconds
Failing tests: 0
select new bug
Pattern: 0001
new failing tests:
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
Save found bug
processed: 0001
pattern: 0010
try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

patches are written to file
running tests...
used time: Finished in 244.22 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
No new failing tests but only 1 hunk
processed: 0010
pattern: 0100
try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

patches are written to file
running tests...
used time: Finished in 242.82 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
No new failing tests but only 1 hunk
processed: 0100
pattern: 1000
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

patches are written to file
running tests...
used time: Finished in 249.22 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
No new failing tests but only 1 hunk
processed: 1000
pattern: 0011
try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 216.23 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 0011
pattern: 0101
try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 216.61 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 0101
pattern: 0110
try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

patches are written to file
running tests...
used time: Finished in 235.07 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
Can independently fix []
Could not fix independently
processed: 0110
pattern: 1001
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 244.61 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 1001
pattern: 1010
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

patches are written to file
running tests...
used time: Finished in 219.89 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
Can independently fix []
Could not fix independently
processed: 1010
pattern: 1100
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

patches are written to file
running tests...
used time: Finished in 284.50 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
Can independently fix []
Could not fix independently
processed: 1100
pattern: 0111
try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 246.69 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 0111
pattern: 1011
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 185.41 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 1011
pattern: 1101
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
used time: Finished in 204.24 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 1101
pattern: 1110
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

patches are written to file
running tests...
used time: Finished in 205.34 seconds
Failing tests: 13
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_10
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_11
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_12
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_0
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_1
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_2
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_3
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_4
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_5
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_6
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_7
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_8
	com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames$catena_9
Can independently fix []
Could not fix independently
processed: 1110
pattern: 1111
try to fix hunk: 0
replace from 355 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);

try to fix hunk: 1
replace from 366 with range 1 to
                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     

try to fix hunk: 2
replace from 896 with range 1 to
            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);

try to fix hunk: 3
replace from 59 with range 1 to
        return _factory._fromClass(null, base, TypeBindings.emptyBindings());

patches are written to file
running tests...
EXCEPTION: Inside Exception generator.run() timeout
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/generate_bugs/run.py", line 41, in task
    generator.run()
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 82, in new_function
    return function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 85, in run
    self._run()
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 111, in _run
    self.taskSingleHunk(task)
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 140, in taskSingleHunk
    failure = util.get_failing_tests(self.path, self.build_dir)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/util.py", line 49, in get_failing_tests
    result = runCommand(['defects4j', 'test', '-w', '{}'.format(path)], timeout=timeout)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/util.py", line 12, in runCommand
    finished = subprocess.run(cmd, capture_output=True, cwd=cwd, timeout=timeout)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 550, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 1209, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 2113, in _communicate
    ready = selector.select(timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/selectors.py", line 415, in select
    fd_event_list = self._selector.poll(timeout)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 69, in handler
    _raise_exception(timeout_exception, exception_message)
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 47, in _raise_exception
    raise exception(exception_message)
TimeoutError: generator.run() timeout

