{
    "original": {
        "num_of_hunks": 3,
        "0": {
            "file_name": "src/main/java/com/fasterxml/jackson/core/io/IOContext.java",
            "from_line_no": 274,
            "to_line_no": 274,
            "replaced_with": "        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n",
            "replaced": "        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n",
            "patch_type": "replace",
            "next_line_no": 275
        },
        "1": {
            "file_name": "src/main/java/com/fasterxml/jackson/core/io/IOContext.java",
            "from_line_no": 279,
            "to_line_no": 279,
            "replaced_with": "        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n",
            "replaced": "        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n",
            "patch_type": "replace",
            "next_line_no": 280
        },
        "2": {
            "file_name": "src/main/java/com/fasterxml/jackson/core/io/IOContext.java",
            "from_line_no": 284,
            "to_line_no": 284,
            "replaced_with": "        return new IllegalArgumentException(\"Trying to release buffer smaller than original\");\n",
            "replaced": "return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n",
            "patch_type": "replace",
            "next_line_no": 285
        }
    },
    "method": {
        "failing_tests": [
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations"
        ],
        "com.fasterxml.jackson.core.io.TestIOContext::testAllocations": {
            "file_path": "src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java",
            "Instance": "Begin: Pos(9, 12)\nEnd: Pos(91, 5)\nSource: /tmp/c4j/JacksonCore_14/src/test/java//com/fasterxml/jackson/core/io/TestIOContext.java\nName: testAllocations\nChilds: [StatementAssertion<Begin: Pos(16, 9), End: Pos(16, 48)>,\nStatementAssertion<Begin: Pos(21, 13), End: Pos(21, 46)>,\nStatementAssertion<Begin: Pos(27, 13), End: Pos(27, 56)>,\nStatementAssertion<Begin: Pos(34, 9), End: Pos(34, 55)>,\nStatementAssertion<Begin: Pos(38, 13), End: Pos(38, 46)>,\nStatementAssertion<Begin: Pos(43, 13), End: Pos(43, 56)>,\nStatementAssertion<Begin: Pos(49, 9), End: Pos(49, 47)>,\nStatementAssertion<Begin: Pos(53, 13), End: Pos(53, 46)>,\nStatementAssertion<Begin: Pos(58, 13), End: Pos(58, 56)>,\nStatementAssertion<Begin: Pos(64, 9), End: Pos(64, 48)>,\nStatementAssertion<Begin: Pos(68, 13), End: Pos(68, 46)>,\nStatementAssertion<Begin: Pos(73, 13), End: Pos(73, 56)>,\nStatementAssertion<Begin: Pos(79, 9), End: Pos(79, 53)>,\nStatementAssertion<Begin: Pos(83, 13), End: Pos(83, 46)>,\nStatementAssertion<Begin: Pos(88, 13), End: Pos(88, 56)>,\n]",
            "source": "/tmp/c4j/JacksonCore_14/src/test/java//com/fasterxml/jackson/core/io/TestIOContext.java",
            "name": "testAllocations",
            "begin": "Pos(9, 12)",
            "end": "Pos(91, 5)",
            "begin_line_no": 9,
            "end_line_no": 91,
            "child": [
                "Begin: Pos(16, 9)\nEnd: Pos(16, 48)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(21, 13)\nEnd: Pos(21, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(27, 13)\nEnd: Pos(27, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(34, 9)\nEnd: Pos(34, 55)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(38, 13)\nEnd: Pos(38, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(43, 13)\nEnd: Pos(43, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(49, 9)\nEnd: Pos(49, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(53, 13)\nEnd: Pos(53, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(58, 13)\nEnd: Pos(58, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(64, 9)\nEnd: Pos(64, 48)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(68, 13)\nEnd: Pos(68, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(73, 13)\nEnd: Pos(73, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(79, 9)\nEnd: Pos(79, 53)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(83, 13)\nEnd: Pos(83, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(88, 13)\nEnd: Pos(88, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    public void testAllocations$catena_0() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        assertNotNull(ctxt.allocReadIOBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_1() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_2() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_3() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        assertNotNull(ctxt.allocWriteEncodingBuffer());                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_4() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_5() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_6() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        assertNotNull(ctxt.allocTokenBuffer());                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_7() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_8() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_9() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        assertNotNull(ctxt.allocConcatBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_10() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_11() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_12() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        assertNotNull(ctxt.allocNameCopyBuffer(100));                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_13() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "    public void testAllocations$catena_14() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }"
            ],
            "func": {
                "0": "    public void testAllocations$catena_0() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        assertNotNull(ctxt.allocReadIOBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "1": "    public void testAllocations$catena_1() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "2": "    public void testAllocations$catena_2() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "3": "    public void testAllocations$catena_3() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        assertNotNull(ctxt.allocWriteEncodingBuffer());                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "4": "    public void testAllocations$catena_4() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "5": "    public void testAllocations$catena_5() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "6": "    public void testAllocations$catena_6() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        assertNotNull(ctxt.allocTokenBuffer());                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "7": "    public void testAllocations$catena_7() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "8": "    public void testAllocations$catena_8() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "9": "    public void testAllocations$catena_9() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        assertNotNull(ctxt.allocConcatBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "10": "    public void testAllocations$catena_10() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "11": "    public void testAllocations$catena_11() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "12": "    public void testAllocations$catena_12() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        assertNotNull(ctxt.allocNameCopyBuffer(100));                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "13": "    public void testAllocations$catena_13() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }",
                "14": "    public void testAllocations$catena_14() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        // but call with null is a NOP for convenience\n        ctxt.releaseReadIOBuffer(null);\n\n        /* I/O Write buffer */\n\n        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocWriteEncodingBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseWriteEncodingBuffer(null);\n\n        /* Token (read) buffer */\n\n        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocTokenBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseTokenBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseTokenBuffer(null);\n\n        /* Concat (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocConcatBuffer();\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseConcatBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            try{ verifyException(e, \"smaller than original\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        ctxt.releaseConcatBuffer(null);\n\n        /* NameCopy (write?) buffer */\n\n        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        try {\n            ctxt.allocNameCopyBuffer(100);\n        } catch (IllegalStateException e) {\n            try{ verifyException(e, \"second time\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n        try {\n            ctxt.releaseNameCopyBuffer(new char[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n        ctxt.releaseNameCopyBuffer(null);\n    }"
            }
        }
    },
    "001": {
        "failing_tests": [
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations$catena_5",
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations$catena_11",
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations$catena_8",
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations$catena_2",
            "com.fasterxml.jackson.core.io.TestIOContext::testAllocations$catena_14"
        ]
    }
}