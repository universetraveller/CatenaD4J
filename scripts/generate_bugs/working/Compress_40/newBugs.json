{
    "original": {
        "num_of_hunks": 5,
        "0": {
            "file_name": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
            "from_line_no": 85,
            "to_line_no": 85,
            "replaced_with": "        while (bitsCachedSize < count && bitsCachedSize < 57) {\n",
            "replaced": "        while (bitsCachedSize < count) {\n",
            "patch_type": "replace",
            "next_line_no": 86
        },
        "1": {
            "file_name": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
            "replaced_with": "        int overflowBits = 0;\n        long overflow = 0l;\n        if (bitsCachedSize < count) {\n",
            "patch_type": "insert",
            "next_line_no": 98
        },
        "2": {
            "file_name": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
            "replaced_with": "            int bitsToAddCount = count - bitsCachedSize;\n            overflowBits = 8 - bitsToAddCount;\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n            } else {\n                bitsCached <<= bitsToAddCount;\n                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n                bitsCached |= bitsToAdd;\n                overflow = nextByte & MASKS[overflowBits];\n            }\n            bitsCachedSize = count;\n        }\n",
            "patch_type": "insert",
            "next_line_no": 99
        },
        "3": {
            "file_name": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
            "replaced_with": "        if (overflowBits == 0) {\n",
            "patch_type": "insert",
            "next_line_no": 101
        },
        "4": {
            "file_name": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java",
            "replaced_with": "        } else {\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }\n",
            "patch_type": "insert",
            "next_line_no": 108
        }
    },
    "method": {
        "failing_tests": [
            "org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow",
            "org.apache.commons.compress.utils.BitInputStreamTest::bigEndianWithOverflow"
        ],
        "org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow": {
            "file_path": "src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java",
            "Instance": "Begin: Pos(124, 5)\nEnd: Pos(146, 5)\nSource: /tmp/c4j/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java\nName: littleEndianWithOverflow\nChilds: [StatementAssertion<Begin: Pos(139, 9), End: Pos(140, 38)>,\nStatementAssertion<Begin: Pos(141, 9), End: Pos(142, 39)>,\nStatementAssertion<Begin: Pos(143, 9), End: Pos(144, 39)>,\nStatementAssertion<Begin: Pos(145, 9), End: Pos(145, 43)>,\n]",
            "source": "/tmp/c4j/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java",
            "name": "littleEndianWithOverflow",
            "begin": "Pos(124, 5)",
            "end": "Pos(146, 5)",
            "begin_line_no": 124,
            "end_line_no": 146,
            "child": [
                "Begin: Pos(139, 9)\nEnd: Pos(140, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(141, 9)\nEnd: Pos(142, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(143, 9)\nEnd: Pos(144, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(145, 9)\nEnd: Pos(145, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test\n    public void littleEndianWithOverflow$catena_0() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void littleEndianWithOverflow$catena_1() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void littleEndianWithOverflow$catena_2() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void littleEndianWithOverflow$catena_3() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    @Test\n    public void littleEndianWithOverflow$catena_0() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    @Test\n    public void littleEndianWithOverflow$catena_1() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    @Test\n    public void littleEndianWithOverflow$catena_2() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "3": "    @Test\n    public void littleEndianWithOverflow$catena_3() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try{ assertEquals(23, // 10111\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(1186, // 01001010-0010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        },
        "org.apache.commons.compress.utils.BitInputStreamTest::bigEndianWithOverflow": {
            "file_path": "src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java",
            "Instance": "Begin: Pos(148, 5)\nEnd: Pos(170, 5)\nSource: /tmp/c4j/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java\nName: bigEndianWithOverflow\nChilds: [StatementAssertion<Begin: Pos(163, 9), End: Pos(164, 38)>,\nStatementAssertion<Begin: Pos(165, 9), End: Pos(166, 39)>,\nStatementAssertion<Begin: Pos(167, 9), End: Pos(168, 39)>,\nStatementAssertion<Begin: Pos(169, 9), End: Pos(169, 43)>,\n]",
            "source": "/tmp/c4j/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java",
            "name": "bigEndianWithOverflow",
            "begin": "Pos(148, 5)",
            "end": "Pos(170, 5)",
            "begin_line_no": 148,
            "end_line_no": 170,
            "child": [
                "Begin: Pos(163, 9)\nEnd: Pos(164, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(165, 9)\nEnd: Pos(166, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(167, 9)\nEnd: Pos(168, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(169, 9)\nEnd: Pos(169, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test\n    public void bigEndianWithOverflow$catena_0() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void bigEndianWithOverflow$catena_1() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void bigEndianWithOverflow$catena_2() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    @Test\n    public void bigEndianWithOverflow$catena_3() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    @Test\n    public void bigEndianWithOverflow$catena_0() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    @Test\n    public void bigEndianWithOverflow$catena_1() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    @Test\n    public void bigEndianWithOverflow$catena_2() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "3": "    @Test\n    public void bigEndianWithOverflow$catena_3() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n        try{ assertEquals(10, // 01010\n                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(330, // 0001-01001010\n                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        }
    },
    "11111": {
        "failing_tests": [
            "org.apache.commons.compress.utils.BitInputStreamTest::bigEndianWithOverflow$catena_1",
            "org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow$catena_2"
        ]
    }
}