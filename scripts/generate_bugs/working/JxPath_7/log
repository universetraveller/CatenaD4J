---
Begin generate bug_id: JxPath_7
num_of_hunks: 11
timeout for running: 3600
use working dir: ./working/data/JxPath_7
Try to checkout JxPath_7
build dir: ['target/classes', 'target/test-classes']
init FileManager
trace file: src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java
trace file: src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java
trace file: src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java
trace file: src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java
trace file: src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
trying to replace old failing tests
edit: replace from 99 range 14 at src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
to
    public void testNodeSetOperations$catena_0() {
        assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_1() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_2() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_3() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_4() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_5() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_6() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_7() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_8() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_9() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_10() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }     public void testNodeSetOperations$catena_11() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
trace file: src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
new test num: 12
ori test num: 0
pattern: 00000000000
patches are written to file
running tests...
used time: Finished in 24.50 seconds
Failing tests: 4
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_0
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_1
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_7
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_8
processed: 00000000000
pattern: 00000000001
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000001
pattern: 00000000010
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000010
pattern: 00000000100
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
used time: Finished in 22.63 seconds
Failing tests: 4
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_0
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_1
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_7
	org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations$catena_8
No new failing tests but only 1 hunk
processed: 00000000100
pattern: 00000001000
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001000
pattern: 00000010000
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010000
pattern: 00000100000
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100000
pattern: 00001000000
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000000
pattern: 00010000000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000000
pattern: 00100000000
try to fix hunk: 2
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000000
pattern: 01000000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000
pattern: 10000000000
try to fix hunk: 0
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000
pattern: 00000000011
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000011
pattern: 00000000101
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000101
pattern: 00000000110
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000110
pattern: 00000001001
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001001
pattern: 00000001010
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001010
pattern: 00000001100
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001100
pattern: 00000010001
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010001
pattern: 00000010010
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010010
pattern: 00000010100
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010100
pattern: 00000011000
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011000
pattern: 00000100001
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100001
pattern: 00000100010
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100010
pattern: 00000100100
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100100
pattern: 00000101000
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101000
pattern: 00000110000
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110000
pattern: 00001000001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000001
pattern: 00001000010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000010
pattern: 00001000100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000100
pattern: 00001001000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001000
pattern: 00001010000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010000
pattern: 00001100000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100000
pattern: 00010000001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000001
pattern: 00010000010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000010
pattern: 00010000100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000100
pattern: 00010001000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001000
pattern: 00010010000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010000
pattern: 00010100000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100000
pattern: 00011000000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000000
pattern: 00100000001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000001
pattern: 00100000010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000010
pattern: 00100000100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000100
pattern: 00100001000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001000
pattern: 00100010000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010000
pattern: 00100100000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100000
pattern: 00101000000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000000
pattern: 00110000000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000000
pattern: 01000000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000001
pattern: 01000000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000010
pattern: 01000000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000100
pattern: 01000001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001000
pattern: 01000010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010000
pattern: 01000100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100000
pattern: 01001000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000000
pattern: 01010000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000000
pattern: 01100000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000000
pattern: 10000000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000001
pattern: 10000000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000010
pattern: 10000000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000100
pattern: 10000001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001000
pattern: 10000010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010000
pattern: 10000100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100000
pattern: 10001000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000000
pattern: 10010000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000000
pattern: 10100000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000000
pattern: 11000000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000000
pattern: 00000000111
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000111
pattern: 00000001011
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001011
pattern: 00000001101
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001101
pattern: 00000001110
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001110
pattern: 00000010011
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010011
pattern: 00000010101
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010101
pattern: 00000010110
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010110
pattern: 00000011001
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011001
pattern: 00000011010
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011010
pattern: 00000011100
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011100
pattern: 00000100011
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100011
pattern: 00000100101
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100101
pattern: 00000100110
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100110
pattern: 00000101001
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101001
pattern: 00000101010
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101010
pattern: 00000101100
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101100
pattern: 00000110001
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110001
pattern: 00000110010
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110010
pattern: 00000110100
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110100
pattern: 00000111000
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111000
pattern: 00001000011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000011
pattern: 00001000101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000101
pattern: 00001000110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000110
pattern: 00001001001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001001
pattern: 00001001010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001010
pattern: 00001001100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001100
pattern: 00001010001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010001
pattern: 00001010010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010010
pattern: 00001010100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010100
pattern: 00001011000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011000
pattern: 00001100001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100001
pattern: 00001100010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100010
pattern: 00001100100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100100
pattern: 00001101000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101000
pattern: 00001110000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110000
pattern: 00010000011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000011
pattern: 00010000101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000101
pattern: 00010000110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000110
pattern: 00010001001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001001
pattern: 00010001010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001010
pattern: 00010001100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001100
pattern: 00010010001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010001
pattern: 00010010010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010010
pattern: 00010010100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010100
pattern: 00010011000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011000
pattern: 00010100001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100001
pattern: 00010100010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100010
pattern: 00010100100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100100
pattern: 00010101000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101000
pattern: 00010110000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110000
pattern: 00011000001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000001
pattern: 00011000010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000010
pattern: 00011000100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000100
pattern: 00011001000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001000
pattern: 00011010000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010000
pattern: 00011100000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100000
pattern: 00100000011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000011
pattern: 00100000101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000101
pattern: 00100000110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000110
pattern: 00100001001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001001
pattern: 00100001010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001010
pattern: 00100001100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001100
pattern: 00100010001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010001
pattern: 00100010010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010010
pattern: 00100010100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010100
pattern: 00100011000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011000
pattern: 00100100001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100001
pattern: 00100100010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100010
pattern: 00100100100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100100
pattern: 00100101000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101000
pattern: 00100110000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110000
pattern: 00101000001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000001
pattern: 00101000010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000010
pattern: 00101000100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000100
pattern: 00101001000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001000
pattern: 00101010000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010000
pattern: 00101100000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100000
pattern: 00110000001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000001
pattern: 00110000010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000010
pattern: 00110000100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000100
pattern: 00110001000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001000
pattern: 00110010000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010000
pattern: 00110100000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100000
pattern: 00111000000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000000
pattern: 01000000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000011
pattern: 01000000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000101
pattern: 01000000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000110
pattern: 01000001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001001
pattern: 01000001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001010
pattern: 01000001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001100
pattern: 01000010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010001
pattern: 01000010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010010
pattern: 01000010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010100
pattern: 01000011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011000
pattern: 01000100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100001
pattern: 01000100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100010
pattern: 01000100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100100
pattern: 01000101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101000
pattern: 01000110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110000
pattern: 01001000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000001
pattern: 01001000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000010
pattern: 01001000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000100
pattern: 01001001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001000
pattern: 01001010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010000
pattern: 01001100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100000
pattern: 01010000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000001
pattern: 01010000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000010
pattern: 01010000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000100
pattern: 01010001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001000
pattern: 01010010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010000
pattern: 01010100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100000
pattern: 01011000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000000
pattern: 01100000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000001
pattern: 01100000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000010
pattern: 01100000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000100
pattern: 01100001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001000
pattern: 01100010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010000
pattern: 01100100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100000
pattern: 01101000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000000
pattern: 01110000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000000
pattern: 10000000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000011
pattern: 10000000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000101
pattern: 10000000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000110
pattern: 10000001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001001
pattern: 10000001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001010
pattern: 10000001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001100
pattern: 10000010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010001
pattern: 10000010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010010
pattern: 10000010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010100
pattern: 10000011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011000
pattern: 10000100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100001
pattern: 10000100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100010
pattern: 10000100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100100
pattern: 10000101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101000
pattern: 10000110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110000
pattern: 10001000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000001
pattern: 10001000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000010
pattern: 10001000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000100
pattern: 10001001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001000
pattern: 10001010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010000
pattern: 10001100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100000
pattern: 10010000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000001
pattern: 10010000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000010
pattern: 10010000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000100
pattern: 10010001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001000
pattern: 10010010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010000
pattern: 10010100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100000
pattern: 10011000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000000
pattern: 10100000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000001
pattern: 10100000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000010
pattern: 10100000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000100
pattern: 10100001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001000
pattern: 10100010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010000
pattern: 10100100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100000
pattern: 10101000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000000
pattern: 10110000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000000
pattern: 11000000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000001
pattern: 11000000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000010
pattern: 11000000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000100
pattern: 11000001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001000
pattern: 11000010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010000
pattern: 11000100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100000
pattern: 11001000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000000
pattern: 11010000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000000
pattern: 11100000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000000
pattern: 00000001111
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001111
pattern: 00000010111
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010111
pattern: 00000011011
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011011
pattern: 00000011101
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011101
pattern: 00000011110
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011110
pattern: 00000100111
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100111
pattern: 00000101011
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101011
pattern: 00000101101
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101101
pattern: 00000101110
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101110
pattern: 00000110011
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110011
pattern: 00000110101
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110101
pattern: 00000110110
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110110
pattern: 00000111001
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111001
pattern: 00000111010
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111010
pattern: 00000111100
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111100
pattern: 00001000111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000111
pattern: 00001001011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001011
pattern: 00001001101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001101
pattern: 00001001110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001110
pattern: 00001010011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010011
pattern: 00001010101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010101
pattern: 00001010110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010110
pattern: 00001011001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011001
pattern: 00001011010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011010
pattern: 00001011100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011100
pattern: 00001100011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100011
pattern: 00001100101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100101
pattern: 00001100110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100110
pattern: 00001101001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101001
pattern: 00001101010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101010
pattern: 00001101100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101100
pattern: 00001110001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110001
pattern: 00001110010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110010
pattern: 00001110100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110100
pattern: 00001111000
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111000
pattern: 00010000111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000111
pattern: 00010001011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001011
pattern: 00010001101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001101
pattern: 00010001110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001110
pattern: 00010010011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010011
pattern: 00010010101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010101
pattern: 00010010110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010110
pattern: 00010011001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011001
pattern: 00010011010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011010
pattern: 00010011100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011100
pattern: 00010100011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100011
pattern: 00010100101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100101
pattern: 00010100110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100110
pattern: 00010101001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101001
pattern: 00010101010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101010
pattern: 00010101100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101100
pattern: 00010110001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110001
pattern: 00010110010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110010
pattern: 00010110100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110100
pattern: 00010111000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111000
pattern: 00011000011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000011
pattern: 00011000101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000101
pattern: 00011000110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000110
pattern: 00011001001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001001
pattern: 00011001010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001010
pattern: 00011001100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001100
pattern: 00011010001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010001
pattern: 00011010010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010010
pattern: 00011010100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010100
pattern: 00011011000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011000
pattern: 00011100001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100001
pattern: 00011100010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100010
pattern: 00011100100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100100
pattern: 00011101000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101000
pattern: 00011110000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110000
pattern: 00100000111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000111
pattern: 00100001011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001011
pattern: 00100001101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001101
pattern: 00100001110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001110
pattern: 00100010011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010011
pattern: 00100010101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010101
pattern: 00100010110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010110
pattern: 00100011001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011001
pattern: 00100011010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011010
pattern: 00100011100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011100
pattern: 00100100011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100011
pattern: 00100100101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100101
pattern: 00100100110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100110
pattern: 00100101001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101001
pattern: 00100101010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101010
pattern: 00100101100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101100
pattern: 00100110001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110001
pattern: 00100110010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110010
pattern: 00100110100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110100
pattern: 00100111000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111000
pattern: 00101000011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000011
pattern: 00101000101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000101
pattern: 00101000110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000110
pattern: 00101001001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001001
pattern: 00101001010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001010
pattern: 00101001100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001100
pattern: 00101010001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010001
pattern: 00101010010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010010
pattern: 00101010100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010100
pattern: 00101011000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011000
pattern: 00101100001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100001
pattern: 00101100010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100010
pattern: 00101100100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100100
pattern: 00101101000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101000
pattern: 00101110000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110000
pattern: 00110000011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000011
pattern: 00110000101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000101
pattern: 00110000110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000110
pattern: 00110001001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001001
pattern: 00110001010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001010
pattern: 00110001100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001100
pattern: 00110010001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010001
pattern: 00110010010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010010
pattern: 00110010100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010100
pattern: 00110011000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011000
pattern: 00110100001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100001
pattern: 00110100010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100010
pattern: 00110100100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100100
pattern: 00110101000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101000
pattern: 00110110000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110000
pattern: 00111000001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000001
pattern: 00111000010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000010
pattern: 00111000100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000100
pattern: 00111001000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001000
pattern: 00111010000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010000
pattern: 00111100000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100000
pattern: 01000000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000111
pattern: 01000001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001011
pattern: 01000001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001101
pattern: 01000001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001110
pattern: 01000010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010011
pattern: 01000010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010101
pattern: 01000010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010110
pattern: 01000011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011001
pattern: 01000011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011010
pattern: 01000011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011100
pattern: 01000100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100011
pattern: 01000100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100101
pattern: 01000100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100110
pattern: 01000101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101001
pattern: 01000101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101010
pattern: 01000101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101100
pattern: 01000110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110001
pattern: 01000110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110010
pattern: 01000110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110100
pattern: 01000111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111000
pattern: 01001000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000011
pattern: 01001000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000101
pattern: 01001000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000110
pattern: 01001001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001001
pattern: 01001001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001010
pattern: 01001001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001100
pattern: 01001010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010001
pattern: 01001010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010010
pattern: 01001010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010100
pattern: 01001011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011000
pattern: 01001100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100001
pattern: 01001100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100010
pattern: 01001100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100100
pattern: 01001101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101000
pattern: 01001110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110000
pattern: 01010000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000011
pattern: 01010000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000101
pattern: 01010000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000110
pattern: 01010001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001001
pattern: 01010001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001010
pattern: 01010001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001100
pattern: 01010010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010001
pattern: 01010010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010010
pattern: 01010010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010100
pattern: 01010011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011000
pattern: 01010100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100001
pattern: 01010100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100010
pattern: 01010100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100100
pattern: 01010101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101000
pattern: 01010110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110000
pattern: 01011000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000001
pattern: 01011000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000010
pattern: 01011000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000100
pattern: 01011001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001000
pattern: 01011010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010000
pattern: 01011100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100000
pattern: 01100000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000011
pattern: 01100000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000101
pattern: 01100000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000110
pattern: 01100001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001001
pattern: 01100001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001010
pattern: 01100001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001100
pattern: 01100010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010001
pattern: 01100010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010010
pattern: 01100010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010100
pattern: 01100011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011000
pattern: 01100100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100001
pattern: 01100100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100010
pattern: 01100100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100100
pattern: 01100101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101000
pattern: 01100110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110000
pattern: 01101000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000001
pattern: 01101000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000010
pattern: 01101000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000100
pattern: 01101001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001000
pattern: 01101010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010000
pattern: 01101100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100000
pattern: 01110000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000001
pattern: 01110000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000010
pattern: 01110000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000100
pattern: 01110001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001000
pattern: 01110010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010000
pattern: 01110100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100000
pattern: 01111000000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000000
pattern: 10000000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000111
pattern: 10000001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001011
pattern: 10000001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001101
pattern: 10000001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001110
pattern: 10000010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010011
pattern: 10000010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010101
pattern: 10000010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010110
pattern: 10000011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011001
pattern: 10000011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011010
pattern: 10000011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011100
pattern: 10000100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100011
pattern: 10000100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100101
pattern: 10000100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100110
pattern: 10000101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101001
pattern: 10000101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101010
pattern: 10000101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101100
pattern: 10000110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110001
pattern: 10000110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110010
pattern: 10000110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110100
pattern: 10000111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111000
pattern: 10001000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000011
pattern: 10001000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000101
pattern: 10001000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000110
pattern: 10001001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001001
pattern: 10001001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001010
pattern: 10001001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001100
pattern: 10001010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010001
pattern: 10001010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010010
pattern: 10001010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010100
pattern: 10001011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011000
pattern: 10001100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100001
pattern: 10001100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100010
pattern: 10001100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100100
pattern: 10001101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101000
pattern: 10001110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110000
pattern: 10010000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000011
pattern: 10010000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000101
pattern: 10010000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000110
pattern: 10010001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001001
pattern: 10010001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001010
pattern: 10010001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001100
pattern: 10010010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010001
pattern: 10010010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010010
pattern: 10010010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010100
pattern: 10010011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011000
pattern: 10010100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100001
pattern: 10010100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100010
pattern: 10010100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100100
pattern: 10010101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101000
pattern: 10010110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110000
pattern: 10011000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000001
pattern: 10011000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000010
pattern: 10011000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000100
pattern: 10011001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001000
pattern: 10011010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010000
pattern: 10011100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100000
pattern: 10100000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000011
pattern: 10100000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000101
pattern: 10100000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000110
pattern: 10100001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001001
pattern: 10100001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001010
pattern: 10100001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001100
pattern: 10100010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010001
pattern: 10100010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010010
pattern: 10100010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010100
pattern: 10100011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011000
pattern: 10100100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100001
pattern: 10100100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100010
pattern: 10100100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100100
pattern: 10100101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101000
pattern: 10100110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110000
pattern: 10101000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000001
pattern: 10101000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000010
pattern: 10101000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000100
pattern: 10101001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001000
pattern: 10101010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010000
pattern: 10101100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100000
pattern: 10110000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000001
pattern: 10110000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000010
pattern: 10110000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000100
pattern: 10110001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001000
pattern: 10110010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010000
pattern: 10110100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100000
pattern: 10111000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000000
pattern: 11000000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000011
pattern: 11000000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000101
pattern: 11000000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000110
pattern: 11000001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001001
pattern: 11000001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001010
pattern: 11000001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001100
pattern: 11000010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010001
pattern: 11000010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010010
pattern: 11000010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010100
pattern: 11000011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011000
pattern: 11000100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100001
pattern: 11000100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100010
pattern: 11000100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100100
pattern: 11000101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101000
pattern: 11000110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110000
pattern: 11001000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000001
pattern: 11001000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000010
pattern: 11001000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000100
pattern: 11001001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001000
pattern: 11001010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010000
pattern: 11001100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100000
pattern: 11010000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000001
pattern: 11010000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000010
pattern: 11010000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000100
pattern: 11010001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001000
pattern: 11010010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010000
pattern: 11010100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100000
pattern: 11011000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000000
pattern: 11100000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000001
pattern: 11100000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000010
pattern: 11100000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000100
pattern: 11100001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100001000
pattern: 11100010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100010000
pattern: 11100100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100100000
pattern: 11101000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101000000
pattern: 11110000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110000000
pattern: 00000011111
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000011111
pattern: 00000101111
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101111
pattern: 00000110111
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110111
pattern: 00000111011
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111011
pattern: 00000111101
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111101
pattern: 00000111110
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111110
pattern: 00001001111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001111
pattern: 00001010111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010111
pattern: 00001011011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011011
pattern: 00001011101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011101
pattern: 00001011110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011110
pattern: 00001100111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100111
pattern: 00001101011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101011
pattern: 00001101101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101101
pattern: 00001101110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101110
pattern: 00001110011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110011
pattern: 00001110101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110101
pattern: 00001110110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110110
pattern: 00001111001
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111001
pattern: 00001111010
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111010
pattern: 00001111100
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111100
pattern: 00010001111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001111
pattern: 00010010111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010111
pattern: 00010011011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011011
pattern: 00010011101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011101
pattern: 00010011110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011110
pattern: 00010100111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100111
pattern: 00010101011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101011
pattern: 00010101101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101101
pattern: 00010101110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101110
pattern: 00010110011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110011
pattern: 00010110101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110101
pattern: 00010110110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110110
pattern: 00010111001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111001
pattern: 00010111010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111010
pattern: 00010111100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111100
pattern: 00011000111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000111
pattern: 00011001011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001011
pattern: 00011001101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001101
pattern: 00011001110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001110
pattern: 00011010011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010011
pattern: 00011010101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010101
pattern: 00011010110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010110
pattern: 00011011001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011001
pattern: 00011011010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011010
pattern: 00011011100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011100
pattern: 00011100011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100011
pattern: 00011100101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100101
pattern: 00011100110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100110
pattern: 00011101001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101001
pattern: 00011101010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101010
pattern: 00011101100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101100
pattern: 00011110001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110001
pattern: 00011110010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110010
pattern: 00011110100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110100
pattern: 00011111000
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011111000
pattern: 00100001111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100001111
pattern: 00100010111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100010111
pattern: 00100011011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011011
pattern: 00100011101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011101
pattern: 00100011110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011110
pattern: 00100100111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100111
pattern: 00100101011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101011
pattern: 00100101101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101101
pattern: 00100101110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101110
pattern: 00100110011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110011
pattern: 00100110101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110101
pattern: 00100110110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110110
pattern: 00100111001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111001
pattern: 00100111010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111010
pattern: 00100111100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111100
pattern: 00101000111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000111
pattern: 00101001011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001011
pattern: 00101001101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001101
pattern: 00101001110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001110
pattern: 00101010011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010011
pattern: 00101010101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010101
pattern: 00101010110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010110
pattern: 00101011001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011001
pattern: 00101011010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011010
pattern: 00101011100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011100
pattern: 00101100011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100011
pattern: 00101100101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100101
pattern: 00101100110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100110
pattern: 00101101001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101001
pattern: 00101101010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101010
pattern: 00101101100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101100
pattern: 00101110001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110001
pattern: 00101110010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110010
pattern: 00101110100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110100
pattern: 00101111000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101111000
pattern: 00110000111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000111
pattern: 00110001011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001011
pattern: 00110001101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001101
pattern: 00110001110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001110
pattern: 00110010011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010011
pattern: 00110010101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010101
pattern: 00110010110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010110
pattern: 00110011001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011001
pattern: 00110011010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011010
pattern: 00110011100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011100
pattern: 00110100011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100011
pattern: 00110100101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100101
pattern: 00110100110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100110
pattern: 00110101001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101001
pattern: 00110101010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101010
pattern: 00110101100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101100
pattern: 00110110001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110001
pattern: 00110110010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110010
pattern: 00110110100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110100
pattern: 00110111000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110111000
pattern: 00111000011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000011
pattern: 00111000101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000101
pattern: 00111000110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000110
pattern: 00111001001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001001
pattern: 00111001010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001010
pattern: 00111001100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001100
pattern: 00111010001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010001
pattern: 00111010010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010010
pattern: 00111010100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010100
pattern: 00111011000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111011000
pattern: 00111100001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100001
pattern: 00111100010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100010
pattern: 00111100100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100100
pattern: 00111101000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111101000
pattern: 00111110000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111110000
pattern: 01000001111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001111
pattern: 01000010111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010111
pattern: 01000011011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011011
pattern: 01000011101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011101
pattern: 01000011110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011110
pattern: 01000100111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100111
pattern: 01000101011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101011
pattern: 01000101101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101101
pattern: 01000101110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101110
pattern: 01000110011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110011
pattern: 01000110101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110101
pattern: 01000110110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110110
pattern: 01000111001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111001
pattern: 01000111010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111010
pattern: 01000111100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111100
pattern: 01001000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000111
pattern: 01001001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001011
pattern: 01001001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001101
pattern: 01001001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001110
pattern: 01001010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010011
pattern: 01001010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010101
pattern: 01001010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010110
pattern: 01001011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011001
pattern: 01001011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011010
pattern: 01001011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011100
pattern: 01001100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100011
pattern: 01001100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100101
pattern: 01001100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100110
pattern: 01001101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101001
pattern: 01001101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101010
pattern: 01001101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101100
pattern: 01001110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110001
pattern: 01001110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110010
pattern: 01001110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110100
pattern: 01001111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001111000
pattern: 01010000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000111
pattern: 01010001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001011
pattern: 01010001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001101
pattern: 01010001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001110
pattern: 01010010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010011
pattern: 01010010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010101
pattern: 01010010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010110
pattern: 01010011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011001
pattern: 01010011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011010
pattern: 01010011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011100
pattern: 01010100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100011
pattern: 01010100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100101
pattern: 01010100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100110
pattern: 01010101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101001
pattern: 01010101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101010
pattern: 01010101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101100
pattern: 01010110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110001
pattern: 01010110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110010
pattern: 01010110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110100
pattern: 01010111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010111000
pattern: 01011000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000011
pattern: 01011000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000101
pattern: 01011000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000110
pattern: 01011001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001001
pattern: 01011001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001010
pattern: 01011001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001100
pattern: 01011010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010001
pattern: 01011010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010010
pattern: 01011010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010100
pattern: 01011011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011011000
pattern: 01011100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100001
pattern: 01011100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100010
pattern: 01011100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100100
pattern: 01011101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011101000
pattern: 01011110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011110000
pattern: 01100000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000111
pattern: 01100001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001011
pattern: 01100001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001101
pattern: 01100001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001110
pattern: 01100010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010011
pattern: 01100010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010101
pattern: 01100010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010110
pattern: 01100011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011001
pattern: 01100011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011010
pattern: 01100011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011100
pattern: 01100100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100011
pattern: 01100100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100101
pattern: 01100100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100110
pattern: 01100101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101001
pattern: 01100101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101010
pattern: 01100101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101100
pattern: 01100110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110001
pattern: 01100110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110010
pattern: 01100110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110100
pattern: 01100111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100111000
pattern: 01101000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000011
pattern: 01101000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000101
pattern: 01101000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000110
pattern: 01101001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001001
pattern: 01101001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001010
pattern: 01101001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001100
pattern: 01101010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010001
pattern: 01101010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010010
pattern: 01101010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010100
pattern: 01101011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101011000
pattern: 01101100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100001
pattern: 01101100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100010
pattern: 01101100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100100
pattern: 01101101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101101000
pattern: 01101110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101110000
pattern: 01110000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000011
pattern: 01110000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000101
pattern: 01110000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000110
pattern: 01110001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001001
pattern: 01110001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001010
pattern: 01110001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001100
pattern: 01110010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010001
pattern: 01110010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010010
pattern: 01110010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010100
pattern: 01110011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110011000
pattern: 01110100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100001
pattern: 01110100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100010
pattern: 01110100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100100
pattern: 01110101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110101000
pattern: 01110110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110110000
pattern: 01111000001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000001
pattern: 01111000010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000010
pattern: 01111000100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000100
pattern: 01111001000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111001000
pattern: 01111010000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111010000
pattern: 01111100000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111100000
pattern: 10000001111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001111
pattern: 10000010111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010111
pattern: 10000011011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011011
pattern: 10000011101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011101
pattern: 10000011110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011110
pattern: 10000100111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100111
pattern: 10000101011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101011
pattern: 10000101101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101101
pattern: 10000101110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101110
pattern: 10000110011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110011
pattern: 10000110101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110101
pattern: 10000110110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110110
pattern: 10000111001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111001
pattern: 10000111010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111010
pattern: 10000111100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111100
pattern: 10001000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000111
pattern: 10001001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001011
pattern: 10001001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001101
pattern: 10001001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001110
pattern: 10001010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010011
pattern: 10001010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010101
pattern: 10001010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010110
pattern: 10001011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011001
pattern: 10001011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011010
pattern: 10001011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011100
pattern: 10001100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100011
pattern: 10001100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100101
pattern: 10001100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100110
pattern: 10001101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101001
pattern: 10001101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101010
pattern: 10001101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101100
pattern: 10001110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110001
pattern: 10001110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110010
pattern: 10001110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110100
pattern: 10001111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001111000
pattern: 10010000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000111
pattern: 10010001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001011
pattern: 10010001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001101
pattern: 10010001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001110
pattern: 10010010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010011
pattern: 10010010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010101
pattern: 10010010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010110
pattern: 10010011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011001
pattern: 10010011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011010
pattern: 10010011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011100
pattern: 10010100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100011
pattern: 10010100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100101
pattern: 10010100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100110
pattern: 10010101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101001
pattern: 10010101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101010
pattern: 10010101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101100
pattern: 10010110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110001
pattern: 10010110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110010
pattern: 10010110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110100
pattern: 10010111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010111000
pattern: 10011000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000011
pattern: 10011000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000101
pattern: 10011000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000110
pattern: 10011001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001001
pattern: 10011001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001010
pattern: 10011001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001100
pattern: 10011010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010001
pattern: 10011010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010010
pattern: 10011010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010100
pattern: 10011011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011011000
pattern: 10011100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100001
pattern: 10011100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100010
pattern: 10011100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100100
pattern: 10011101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011101000
pattern: 10011110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011110000
pattern: 10100000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000111
pattern: 10100001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001011
pattern: 10100001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001101
pattern: 10100001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001110
pattern: 10100010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010011
pattern: 10100010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010101
pattern: 10100010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010110
pattern: 10100011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011001
pattern: 10100011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011010
pattern: 10100011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011100
pattern: 10100100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100011
pattern: 10100100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100101
pattern: 10100100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100110
pattern: 10100101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101001
pattern: 10100101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101010
pattern: 10100101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101100
pattern: 10100110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110001
pattern: 10100110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110010
pattern: 10100110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110100
pattern: 10100111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100111000
pattern: 10101000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000011
pattern: 10101000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000101
pattern: 10101000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000110
pattern: 10101001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001001
pattern: 10101001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001010
pattern: 10101001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001100
pattern: 10101010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010001
pattern: 10101010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010010
pattern: 10101010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010100
pattern: 10101011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101011000
pattern: 10101100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100001
pattern: 10101100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100010
pattern: 10101100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100100
pattern: 10101101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101101000
pattern: 10101110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101110000
pattern: 10110000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000011
pattern: 10110000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000101
pattern: 10110000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000110
pattern: 10110001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001001
pattern: 10110001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001010
pattern: 10110001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001100
pattern: 10110010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010001
pattern: 10110010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010010
pattern: 10110010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010100
pattern: 10110011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110011000
pattern: 10110100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100001
pattern: 10110100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100010
pattern: 10110100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100100
pattern: 10110101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110101000
pattern: 10110110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110110000
pattern: 10111000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000001
pattern: 10111000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000010
pattern: 10111000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000100
pattern: 10111001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111001000
pattern: 10111010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111010000
pattern: 10111100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111100000
pattern: 11000000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000111
pattern: 11000001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001011
pattern: 11000001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001101
pattern: 11000001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001110
pattern: 11000010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010011
pattern: 11000010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010101
pattern: 11000010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010110
pattern: 11000011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011001
pattern: 11000011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011010
pattern: 11000011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011100
pattern: 11000100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100011
pattern: 11000100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100101
pattern: 11000100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100110
pattern: 11000101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101001
pattern: 11000101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101010
pattern: 11000101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101100
pattern: 11000110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110001
pattern: 11000110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110010
pattern: 11000110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110100
pattern: 11000111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000111000
pattern: 11001000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000011
pattern: 11001000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000101
pattern: 11001000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000110
pattern: 11001001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001001
pattern: 11001001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001010
pattern: 11001001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001100
pattern: 11001010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010001
pattern: 11001010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010010
pattern: 11001010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010100
pattern: 11001011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001011000
pattern: 11001100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100001
pattern: 11001100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100010
pattern: 11001100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100100
pattern: 11001101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001101000
pattern: 11001110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001110000
pattern: 11010000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000011
pattern: 11010000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000101
pattern: 11010000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000110
pattern: 11010001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001001
pattern: 11010001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001010
pattern: 11010001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001100
pattern: 11010010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010001
pattern: 11010010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010010
pattern: 11010010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010100
pattern: 11010011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010011000
pattern: 11010100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100001
pattern: 11010100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100010
pattern: 11010100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100100
pattern: 11010101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010101000
pattern: 11010110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010110000
pattern: 11011000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000001
pattern: 11011000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000010
pattern: 11011000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000100
pattern: 11011001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011001000
pattern: 11011010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011010000
pattern: 11011100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011100000
pattern: 11100000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000011
pattern: 11100000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000101
pattern: 11100000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000110
pattern: 11100001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100001001
pattern: 11100001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100001010
pattern: 11100001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100001100
pattern: 11100010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100010001
pattern: 11100010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100010010
pattern: 11100010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100010100
pattern: 11100011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100011000
pattern: 11100100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100100001
pattern: 11100100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100100010
pattern: 11100100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100100100
pattern: 11100101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100101000
pattern: 11100110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100110000
pattern: 11101000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101000001
pattern: 11101000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101000010
pattern: 11101000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101000100
pattern: 11101001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101001000
pattern: 11101010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101010000
pattern: 11101100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101100000
pattern: 11110000001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110000001
pattern: 11110000010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110000010
pattern: 11110000100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110000100
pattern: 11110001000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110001000
pattern: 11110010000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110010000
pattern: 11110100000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110100000
pattern: 11111000000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11111000000
pattern: 00000111111
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111111
pattern: 00001011111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011111
pattern: 00001101111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101111
pattern: 00001110111
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110111
pattern: 00001111011
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111011
pattern: 00001111101
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111101
pattern: 00001111110
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111110
pattern: 00010011111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011111
pattern: 00010101111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101111
pattern: 00010110111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110111
pattern: 00010111011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111011
pattern: 00010111101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111101
pattern: 00010111110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111110
pattern: 00011001111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001111
pattern: 00011010111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010111
pattern: 00011011011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011011
pattern: 00011011101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011101
pattern: 00011011110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011110
pattern: 00011100111
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100111
pattern: 00011101011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101011
pattern: 00011101101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101101
pattern: 00011101110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101110
pattern: 00011110011
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110011
pattern: 00011110101
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110101
pattern: 00011110110
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110110
pattern: 00011111001
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011111001
pattern: 00011111010
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011111010
pattern: 00011111100
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011111100
pattern: 00100011111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100011111
pattern: 00100101111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101111
pattern: 00100110111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110111
pattern: 00100111011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111011
pattern: 00100111101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111101
pattern: 00100111110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111110
pattern: 00101001111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001111
pattern: 00101010111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010111
pattern: 00101011011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011011
pattern: 00101011101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011101
pattern: 00101011110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011110
pattern: 00101100111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100111
pattern: 00101101011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101011
pattern: 00101101101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101101
pattern: 00101101110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101110
pattern: 00101110011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110011
pattern: 00101110101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110101
pattern: 00101110110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110110
pattern: 00101111001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101111001
pattern: 00101111010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101111010
pattern: 00101111100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101111100
pattern: 00110001111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001111
pattern: 00110010111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010111
pattern: 00110011011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011011
pattern: 00110011101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011101
pattern: 00110011110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011110
pattern: 00110100111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100111
pattern: 00110101011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101011
pattern: 00110101101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101101
pattern: 00110101110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101110
pattern: 00110110011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110011
pattern: 00110110101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110101
pattern: 00110110110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110110
pattern: 00110111001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110111001
pattern: 00110111010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110111010
pattern: 00110111100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110111100
pattern: 00111000111
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000111
pattern: 00111001011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001011
pattern: 00111001101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001101
pattern: 00111001110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001110
pattern: 00111010011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010011
pattern: 00111010101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010101
pattern: 00111010110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010110
pattern: 00111011001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111011001
pattern: 00111011010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111011010
pattern: 00111011100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111011100
pattern: 00111100011
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100011
pattern: 00111100101
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100101
pattern: 00111100110
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100110
pattern: 00111101001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111101001
pattern: 00111101010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111101010
pattern: 00111101100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111101100
pattern: 00111110001
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111110001
pattern: 00111110010
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111110010
pattern: 00111110100
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111110100
pattern: 00111111000
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111111000
pattern: 01000011111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011111
pattern: 01000101111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101111
pattern: 01000110111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110111
pattern: 01000111011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111011
pattern: 01000111101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111101
pattern: 01000111110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111110
pattern: 01001001111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001111
pattern: 01001010111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010111
pattern: 01001011011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011011
pattern: 01001011101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011101
pattern: 01001011110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011110
pattern: 01001100111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100111
pattern: 01001101011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101011
pattern: 01001101101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101101
pattern: 01001101110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101110
pattern: 01001110011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110011
pattern: 01001110101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110101
pattern: 01001110110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110110
pattern: 01001111001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001111001
pattern: 01001111010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001111010
pattern: 01001111100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001111100
pattern: 01010001111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001111
pattern: 01010010111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010111
pattern: 01010011011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011011
pattern: 01010011101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011101
pattern: 01010011110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011110
pattern: 01010100111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100111
pattern: 01010101011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101011
pattern: 01010101101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101101
pattern: 01010101110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101110
pattern: 01010110011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110011
pattern: 01010110101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110101
pattern: 01010110110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110110
pattern: 01010111001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010111001
pattern: 01010111010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010111010
pattern: 01010111100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010111100
pattern: 01011000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000111
pattern: 01011001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001011
pattern: 01011001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001101
pattern: 01011001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001110
pattern: 01011010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010011
pattern: 01011010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010101
pattern: 01011010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010110
pattern: 01011011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011011001
pattern: 01011011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011011010
pattern: 01011011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011011100
pattern: 01011100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100011
pattern: 01011100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100101
pattern: 01011100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100110
pattern: 01011101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011101001
pattern: 01011101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011101010
pattern: 01011101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011101100
pattern: 01011110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011110001
pattern: 01011110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011110010
pattern: 01011110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011110100
pattern: 01011111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011111000
pattern: 01100001111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001111
pattern: 01100010111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010111
pattern: 01100011011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011011
pattern: 01100011101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011101
pattern: 01100011110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011110
pattern: 01100100111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100111
pattern: 01100101011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101011
pattern: 01100101101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101101
pattern: 01100101110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101110
pattern: 01100110011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110011
pattern: 01100110101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110101
pattern: 01100110110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110110
pattern: 01100111001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100111001
pattern: 01100111010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100111010
pattern: 01100111100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100111100
pattern: 01101000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000111
pattern: 01101001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001011
pattern: 01101001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001101
pattern: 01101001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001110
pattern: 01101010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010011
pattern: 01101010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010101
pattern: 01101010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010110
pattern: 01101011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101011001
pattern: 01101011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101011010
pattern: 01101011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101011100
pattern: 01101100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100011
pattern: 01101100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100101
pattern: 01101100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100110
pattern: 01101101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101101001
pattern: 01101101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101101010
pattern: 01101101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101101100
pattern: 01101110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101110001
pattern: 01101110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101110010
pattern: 01101110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101110100
pattern: 01101111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101111000
pattern: 01110000111
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000111
pattern: 01110001011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001011
pattern: 01110001101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001101
pattern: 01110001110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001110
pattern: 01110010011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010011
pattern: 01110010101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010101
pattern: 01110010110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010110
pattern: 01110011001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110011001
pattern: 01110011010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110011010
pattern: 01110011100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110011100
pattern: 01110100011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100011
pattern: 01110100101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100101
pattern: 01110100110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100110
pattern: 01110101001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110101001
pattern: 01110101010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110101010
pattern: 01110101100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110101100
pattern: 01110110001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110110001
pattern: 01110110010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110110010
pattern: 01110110100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110110100
pattern: 01110111000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110111000
pattern: 01111000011
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000011
pattern: 01111000101
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000101
pattern: 01111000110
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000110
pattern: 01111001001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111001001
pattern: 01111001010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111001010
pattern: 01111001100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111001100
pattern: 01111010001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111010001
pattern: 01111010010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111010010
pattern: 01111010100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111010100
pattern: 01111011000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111011000
pattern: 01111100001
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111100001
pattern: 01111100010
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111100010
pattern: 01111100100
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111100100
pattern: 01111101000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111101000
pattern: 01111110000
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111110000
pattern: 10000011111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011111
pattern: 10000101111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101111
pattern: 10000110111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110111
pattern: 10000111011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111011
pattern: 10000111101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111101
pattern: 10000111110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111110
pattern: 10001001111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001111
pattern: 10001010111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010111
pattern: 10001011011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011011
pattern: 10001011101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011101
pattern: 10001011110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011110
pattern: 10001100111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100111
pattern: 10001101011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101011
pattern: 10001101101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101101
pattern: 10001101110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101110
pattern: 10001110011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110011
pattern: 10001110101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110101
pattern: 10001110110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110110
pattern: 10001111001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001111001
pattern: 10001111010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001111010
pattern: 10001111100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001111100
pattern: 10010001111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001111
pattern: 10010010111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010111
pattern: 10010011011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011011
pattern: 10010011101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011101
pattern: 10010011110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011110
pattern: 10010100111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100111
pattern: 10010101011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101011
pattern: 10010101101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101101
pattern: 10010101110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101110
pattern: 10010110011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110011
pattern: 10010110101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110101
pattern: 10010110110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110110
pattern: 10010111001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010111001
pattern: 10010111010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010111010
pattern: 10010111100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010111100
pattern: 10011000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000111
pattern: 10011001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001011
pattern: 10011001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001101
pattern: 10011001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001110
pattern: 10011010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010011
pattern: 10011010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010101
pattern: 10011010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010110
pattern: 10011011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011011001
pattern: 10011011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011011010
pattern: 10011011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011011100
pattern: 10011100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100011
pattern: 10011100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100101
pattern: 10011100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100110
pattern: 10011101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011101001
pattern: 10011101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011101010
pattern: 10011101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011101100
pattern: 10011110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011110001
pattern: 10011110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011110010
pattern: 10011110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011110100
pattern: 10011111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011111000
pattern: 10100001111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001111
pattern: 10100010111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010111
pattern: 10100011011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011011
pattern: 10100011101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011101
pattern: 10100011110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011110
pattern: 10100100111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100111
pattern: 10100101011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101011
pattern: 10100101101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101101
pattern: 10100101110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101110
pattern: 10100110011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110011
pattern: 10100110101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110101
pattern: 10100110110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110110
pattern: 10100111001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100111001
pattern: 10100111010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100111010
pattern: 10100111100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100111100
pattern: 10101000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000111
pattern: 10101001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001011
pattern: 10101001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001101
pattern: 10101001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001110
pattern: 10101010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010011
pattern: 10101010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010101
pattern: 10101010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010110
pattern: 10101011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101011001
pattern: 10101011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101011010
pattern: 10101011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101011100
pattern: 10101100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100011
pattern: 10101100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100101
pattern: 10101100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100110
pattern: 10101101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101101001
pattern: 10101101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101101010
pattern: 10101101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101101100
pattern: 10101110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101110001
pattern: 10101110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101110010
pattern: 10101110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101110100
pattern: 10101111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101111000
pattern: 10110000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000111
pattern: 10110001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001011
pattern: 10110001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001101
pattern: 10110001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001110
pattern: 10110010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010011
pattern: 10110010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010101
pattern: 10110010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010110
pattern: 10110011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110011001
pattern: 10110011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110011010
pattern: 10110011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110011100
pattern: 10110100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100011
pattern: 10110100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100101
pattern: 10110100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100110
pattern: 10110101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110101001
pattern: 10110101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110101010
pattern: 10110101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110101100
pattern: 10110110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110110001
pattern: 10110110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110110010
pattern: 10110110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110110100
pattern: 10110111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110111000
pattern: 10111000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000011
pattern: 10111000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000101
pattern: 10111000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000110
pattern: 10111001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111001001
pattern: 10111001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111001010
pattern: 10111001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111001100
pattern: 10111010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111010001
pattern: 10111010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111010010
pattern: 10111010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111010100
pattern: 10111011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111011000
pattern: 10111100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111100001
pattern: 10111100010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111100010
pattern: 10111100100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111100100
pattern: 10111101000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111101000
pattern: 10111110000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 2
delete from 19 with range 2
try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111110000
pattern: 11000001111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001111
pattern: 11000010111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010111
pattern: 11000011011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011011
pattern: 11000011101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011101
pattern: 11000011110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011110
pattern: 11000100111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100111
pattern: 11000101011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101011
pattern: 11000101101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101101
pattern: 11000101110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101110
pattern: 11000110011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110011
pattern: 11000110101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110101
pattern: 11000110110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110110
pattern: 11000111001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000111001
pattern: 11000111010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000111010
pattern: 11000111100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000111100
pattern: 11001000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000111
pattern: 11001001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001011
pattern: 11001001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001101
pattern: 11001001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001110
pattern: 11001010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010011
pattern: 11001010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010101
pattern: 11001010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010110
pattern: 11001011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001011001
pattern: 11001011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001011010
pattern: 11001011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001011100
pattern: 11001100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100011
pattern: 11001100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100101
pattern: 11001100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100110
pattern: 11001101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001101001
pattern: 11001101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001101010
pattern: 11001101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001101100
pattern: 11001110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001110001
pattern: 11001110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001110010
pattern: 11001110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001110100
pattern: 11001111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001111000
pattern: 11010000111
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000111
pattern: 11010001011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001011
pattern: 11010001101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001101
pattern: 11010001110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001110
pattern: 11010010011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010011
pattern: 11010010101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010101
pattern: 11010010110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010110
pattern: 11010011001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010011001
pattern: 11010011010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010011010
pattern: 11010011100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010011100
pattern: 11010100011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100011
pattern: 11010100101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100101
pattern: 11010100110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100110
pattern: 11010101001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010101001
pattern: 11010101010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010101010
pattern: 11010101100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010101100
pattern: 11010110001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010110001
pattern: 11010110010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010110010
pattern: 11010110100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010110100
pattern: 11010111000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010111000
pattern: 11011000011
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000011
pattern: 11011000101
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000101
pattern: 11011000110
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000110
pattern: 11011001001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011001001
pattern: 11011001010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011001010
pattern: 11011001100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011001100
pattern: 11011010001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011010001
pattern: 11011010010
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 9
insert before 31 with     public final Object computeValue(EvalContext context) {
        return compute(args[0].computeValue(context), args[1]
                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
    }


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011010010
pattern: 11011010100
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 8
insert before 19 with import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011010100
pattern: 11011011000
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 6
delete from 19 with range 2
try to fix hunk: 7
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare <= 0;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011011000
pattern: 11011100001
try to fix hunk: 0
delete from 19 with range 2
try to fix hunk: 1
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare > 0;

try to fix hunk: 3
replace from 34 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare >= 0;

try to fix hunk: 4
delete from 19 with range 2
try to fix hunk: 5
replace from 33 with range 4 to
    protected boolean evaluateCompare(int compare) {
        return compare < 0;

try to fix hunk: 10
insert before 39 with     protected abstract boolean evaluateCompare(int compare);

    private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
            return containsMatch((Iterator) left, right);
        }
        if (right instanceof Iterator) {
            return containsMatch((Iterator) right, left);
        }
        return evaluateCompare(compare(left, right));
    }

    private Object reduce(Object o) {
        if (o instanceof SelfContext) {
            o = ((EvalContext) o).getSingleNodePointer();
        }
        if (o instanceof Collection) {
            o = ((Collection) o).iterator();
        }
        return o;
    }

    private boolean containsMatch(Iterator it, Object value) {
        while (it.hasNext()) {
            Object element = it.next();
            if (evaluateCompare(compare(element, value))) {
                return true;
            }
        }
        return false;
    }

    private boolean findMatch(Iterator lit, Iterator rit) {
        HashSet left = new HashSet();
        while (lit.hasNext()) {
            left.add(lit.next());
        }
        while (rit.hasNext()) {
            if (containsMatch(left.iterator(), rit.next())) {
                return true;
            }
        }
        return false;
    }

    private int compare(Object l, Object r) {
        double ld = InfoSetUtil.doubleValue(l);
        double rd = InfoSetUtil.doubleValue(r);
        return ld == rd ? 0 : ld < rd ? -1 : 1;
    }


patches are written to file
running tests...
EXCEPTION: Inside Exception generator.run() timeout
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/generate_bugs/run.py", line 41, in task
    generator.run()
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 82, in new_function
    return function(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 85, in run
    self._run()
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 111, in _run
    self.taskSingleHunk(task)
  File "/root/rjy/c4j/scripts/generate_bugs/runner.py", line 140, in taskSingleHunk
    failure = util.get_failing_tests(self.path, self.build_dir)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/util.py", line 49, in get_failing_tests
    result = runCommand(['defects4j', 'test', '-w', '{}'.format(path)], timeout=timeout)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/util.py", line 12, in runCommand
    finished = subprocess.run(cmd, capture_output=True, cwd=cwd, timeout=timeout)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 550, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 1209, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/subprocess.py", line 2113, in _communicate
    ready = selector.select(timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/lib/python3.12/selectors.py", line 415, in select
    fd_event_list = self._selector.poll(timeout)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 69, in handler
    _raise_exception(timeout_exception, exception_message)
  File "/root/rjy/c4j/scripts/generate_bugs/timeout_decorator/timeout_decorator.py", line 47, in _raise_exception
    raise exception(exception_message)
TimeoutError: generator.run() timeout

