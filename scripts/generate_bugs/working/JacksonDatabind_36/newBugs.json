{
    "original": {
        "num_of_hunks": 3,
        "0": {
            "file_name": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
            "replaced_with": "    @Override // since 2.7\n    public void setLenient(boolean enabled) {\n        Boolean newValue = enabled;\n        if (_lenient != newValue) {\n            _lenient = newValue;\n",
            "patch_type": "insert",
            "next_line_no": 250
        },
        "1": {
            "file_name": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
            "replaced_with": "            _clearFormats();\n        }\n    }\n",
            "patch_type": "insert",
            "next_line_no": 251
        },
        "2": {
            "file_name": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java",
            "replaced_with": "        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n",
            "patch_type": "insert",
            "next_line_no": 557
        }
    },
    "method": {
        "failing_tests": [
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient"
        ],
        "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient": {
            "file_path": "src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java",
            "Instance": "Begin: Pos(19, 12)\nEnd: Pos(57, 5)\nSource: /tmp/c4j/JacksonDatabind_36/src/test/java//com/fasterxml/jackson/databind/TestStdDateFormat.java\nName: testLenient\nChilds: [StatementAssertion<Begin: Pos(24, 9), End: Pos(24, 34)>,\nStatementAssertion<Begin: Pos(27, 9), End: Pos(27, 35)>,\nStatementAssertion<Begin: Pos(30, 9), End: Pos(30, 36)>,\nStatementAssertion<Begin: Pos(33, 9), End: Pos(33, 35)>,\nStatementAssertion<Begin: Pos(37, 9), End: Pos(37, 36)>,\nStatementAssertion<Begin: Pos(39, 9), End: Pos(39, 36)>,\nStatementAssertion<Begin: Pos(43, 9), End: Pos(43, 26)>,\nStatementAssertion<Begin: Pos(48, 13), End: Pos(48, 36)>,\nStatementAssertion<Begin: Pos(50, 13), End: Pos(50, 53)>,\nStatementAssertion<Begin: Pos(56, 9), End: Pos(56, 26)>,\n]",
            "source": "/tmp/c4j/JacksonDatabind_36/src/test/java//com/fasterxml/jackson/databind/TestStdDateFormat.java",
            "name": "testLenient",
            "begin": "Pos(19, 12)",
            "end": "Pos(57, 5)",
            "begin_line_no": 19,
            "end_line_no": 57,
            "child": [
                "Begin: Pos(24, 9)\nEnd: Pos(24, 34)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(27, 9)\nEnd: Pos(27, 35)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(30, 9)\nEnd: Pos(30, 36)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(33, 9)\nEnd: Pos(33, 35)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(37, 9)\nEnd: Pos(37, 36)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(39, 9)\nEnd: Pos(39, 36)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(43, 9)\nEnd: Pos(43, 26)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(48, 13)\nEnd: Pos(48, 36)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(50, 13)\nEnd: Pos(50, 53)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(56, 9)\nEnd: Pos(56, 26)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    public void testLenient$catena_0() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        assertTrue(f.isLenient());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_1() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_2() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_3() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_4() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_5() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        assertFalse(f3.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_6() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_7() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            fail(\"Should not pass\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_8() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            verifyException(e, \"can not parse date\");                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "    public void testLenient$catena_9() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            ],
            "func": {
                "0": "    public void testLenient$catena_0() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        assertTrue(f.isLenient());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "1": "    public void testLenient$catena_1() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "2": "    public void testLenient$catena_2() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "3": "    public void testLenient$catena_3() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "4": "    public void testLenient$catena_4() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "5": "    public void testLenient$catena_5() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        assertFalse(f3.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "6": "    public void testLenient$catena_6() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "7": "    public void testLenient$catena_7() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            fail(\"Should not pass\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "8": "    public void testLenient$catena_8() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            verifyException(e, \"can not parse date\");                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
                "9": "    public void testLenient$catena_9() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
            }
        }
    },
    "110": {
        "failing_tests": [
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_3",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_5",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_2",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_1",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_8",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_0",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_6",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_4",
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_9"
        ]
    },
    "111": {
        "failing_tests": [
            "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient$catena_7"
        ]
    }
}