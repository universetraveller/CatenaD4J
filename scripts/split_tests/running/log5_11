--------------------
Run: Cli_30
@@@
Split test: org.apache.commons.cli.BasicParserTest::testPropertyOptionGroup
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/BasicParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionGroup> in AST

---
@@@
Split test: org.apache.commons.cli.BasicParserTest::testPropertyOptionUnexpected
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/BasicParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionUnexpected> in AST

---
@@@
Split test: org.apache.commons.cli.DefaultParserTest::testPropertyOptionGroup
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/DefaultParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionGroup> in AST

---
@@@
Split test: org.apache.commons.cli.DefaultParserTest::testPropertyOptionUnexpected
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/DefaultParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionUnexpected> in AST

---
@@@
Split test: org.apache.commons.cli.GnuParserTest::testPropertyOptionGroup
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/GnuParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionGroup> in AST

---
@@@
Split test: org.apache.commons.cli.GnuParserTest::testPropertyOptionUnexpected
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/GnuParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionUnexpected> in AST

---
@@@
Split test: org.apache.commons.cli.OptionGroupTest::testTwoOptionsFromGroupWithProperties
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/OptionGroupTest.java
Begin: Pos(191, 12)
End: Pos(201, 5)
Source: /tmp/Cli_30/src/test/java//org/apache/commons/cli/OptionGroupTest.java
Name: testTwoOptionsFromGroupWithProperties
Childs: [StatementAssertion<Begin: Pos(199, 9), End: Pos(199, 38)>,
StatementAssertion<Begin: Pos(200, 9), End: Pos(200, 39)>,
]
---
    public void testTwoOptionsFromGroupWithProperties$catena_0() throws Exception
    {
        String[] args = new String[] { "-f" };
        
        Properties properties = new Properties();
        properties.put("d", "true");
        
        CommandLine cl = parser.parse( _options, args, properties);
        assertTrue(cl.hasOption("f"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(!cl.hasOption("d"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoOptionsFromGroupWithProperties$catena_1() throws Exception
    {
        String[] args = new String[] { "-f" };
        
        Properties properties = new Properties();
        properties.put("d", "true");
        
        CommandLine cl = parser.parse( _options, args, properties);
        try{ assertTrue(cl.hasOption("f"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(!cl.hasOption("d"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli.PosixParserTest::testPropertyOptionGroup
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/PosixParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionGroup> in AST

---
@@@
Split test: org.apache.commons.cli.PosixParserTest::testPropertyOptionUnexpected
file: /tmp/Cli_30/src/test/java//org/apache/commons/cli/PosixParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testPropertyOptionUnexpected> in AST

---
--------------------
Run: Cli_22
@@@
Split test: org.apache.commons.cli.ApplicationTest::testGroovy
file: /tmp/Cli_22/src/test//org/apache/commons/cli/ApplicationTest.java
Begin: Pos(105, 12)
End: Pos(170, 5)
Source: /tmp/Cli_22/src/test//org/apache/commons/cli/ApplicationTest.java
Name: testGroovy
Childs: [StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 40)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 66)>,
]
---
    public void testGroovy$catena_0() throws Exception {
        Options options = new Options();

        options.addOption(
            OptionBuilder.withLongOpt("define").
                withDescription("define a system property").
                hasArg(true).
                withArgName("name=value").
                create('D'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("usage information")
            .withLongOpt("help")
            .create('h'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("debug mode will print out full stack traces")
            .withLongOpt("debug")
            .create('d'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("display the Groovy and JVM versions")
            .withLongOpt("version")
            .create('v'));
        options.addOption(
            OptionBuilder.withArgName("charset")
            .hasArg()
            .withDescription("specify the encoding of the files")
            .withLongOpt("encoding")
            .create('c'));
        options.addOption(
            OptionBuilder.withArgName("script")
            .hasArg()
            .withDescription("specify a command line script")
            .create('e'));
        options.addOption(
            OptionBuilder.withArgName("extension")
            .hasOptionalArg()
            .withDescription("modify files in place; create backup if extension is given (e.g. \'.bak\')")
            .create('i'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("process files line by line using implicit 'line' variable")
            .create('n'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("process files line by line and print result (see also -n)")
            .create('p'));
        options.addOption(
            OptionBuilder.withArgName("port")
            .hasOptionalArg()
            .withDescription("listen on a port and process inbound lines")
            .create('l'));
        options.addOption(
            OptionBuilder.withArgName("splitPattern")
            .hasOptionalArg()
            .withDescription("split lines using splitPattern (default '\\s') using implicit 'split' variable")
            .withLongOpt("autosplit")
            .create('a'));

        Parser parser = new PosixParser();
        CommandLine line = parser.parse(options, new String[] { "-e", "println 'hello'" }, true);

        assertTrue(line.hasOption('e'));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("println 'hello'", line.getOptionValue('e'));                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGroovy$catena_1() throws Exception {
        Options options = new Options();

        options.addOption(
            OptionBuilder.withLongOpt("define").
                withDescription("define a system property").
                hasArg(true).
                withArgName("name=value").
                create('D'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("usage information")
            .withLongOpt("help")
            .create('h'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("debug mode will print out full stack traces")
            .withLongOpt("debug")
            .create('d'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("display the Groovy and JVM versions")
            .withLongOpt("version")
            .create('v'));
        options.addOption(
            OptionBuilder.withArgName("charset")
            .hasArg()
            .withDescription("specify the encoding of the files")
            .withLongOpt("encoding")
            .create('c'));
        options.addOption(
            OptionBuilder.withArgName("script")
            .hasArg()
            .withDescription("specify a command line script")
            .create('e'));
        options.addOption(
            OptionBuilder.withArgName("extension")
            .hasOptionalArg()
            .withDescription("modify files in place; create backup if extension is given (e.g. \'.bak\')")
            .create('i'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("process files line by line using implicit 'line' variable")
            .create('n'));
        options.addOption(
            OptionBuilder.hasArg(false)
            .withDescription("process files line by line and print result (see also -n)")
            .create('p'));
        options.addOption(
            OptionBuilder.withArgName("port")
            .hasOptionalArg()
            .withDescription("listen on a port and process inbound lines")
            .create('l'));
        options.addOption(
            OptionBuilder.withArgName("splitPattern")
            .hasOptionalArg()
            .withDescription("split lines using splitPattern (default '\\s') using implicit 'split' variable")
            .withLongOpt("autosplit")
            .create('a'));

        Parser parser = new PosixParser();
        CommandLine line = parser.parse(options, new String[] { "-e", "println 'hello'" }, true);

        try{ assertTrue(line.hasOption('e'));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("println 'hello'", line.getOptionValue('e'));                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli.PosixParserTest::testStopAtExpectedArg
file: /tmp/Cli_22/src/test//org/apache/commons/cli/PosixParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testStopAtExpectedArg> in AST

---
--------------------
Run: Cli_37
@@@
Split test: org.apache.commons.cli.bug.BugCLI265Test::shouldParseShortOptionWithoutValue
file: /tmp/Cli_37/src/test/java//org/apache/commons/cli/bug/BugCLI265Test.java
Begin: Pos(45, 5)
End: Pos(54, 5)
Source: /tmp/Cli_37/src/test/java//org/apache/commons/cli/bug/BugCLI265Test.java
Name: shouldParseShortOptionWithoutValue
Childs: [StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 48)>,
StatementAssertion<Begin: Pos(52, 9), End: Pos(52, 124)>,
StatementAssertion<Begin: Pos(53, 9), End: Pos(53, 89)>,
]
---
    @Test
    public void shouldParseShortOptionWithoutValue$catena_0() throws Exception {
        String[] twoShortOptions = new String[]{"-t1", "-last"};

        final CommandLine commandLine = parser.parse(options, twoShortOptions);

        assertTrue(commandLine.hasOption("t1"));                                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotEquals("Second option has been used as value for first option", "-last", commandLine.getOptionValue("t1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Second option has not been detected", commandLine.hasOption("last"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseShortOptionWithoutValue$catena_1() throws Exception {
        String[] twoShortOptions = new String[]{"-t1", "-last"};

        final CommandLine commandLine = parser.parse(options, twoShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotEquals("Second option has been used as value for first option", "-last", commandLine.getOptionValue("t1"));         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Second option has not been detected", commandLine.hasOption("last"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseShortOptionWithoutValue$catena_2() throws Exception {
        String[] twoShortOptions = new String[]{"-t1", "-last"};

        final CommandLine commandLine = parser.parse(options, twoShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotEquals("Second option has been used as value for first option", "-last", commandLine.getOptionValue("t1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Second option has not been detected", commandLine.hasOption("last"));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_33
@@@
Split test: org.apache.commons.cli.HelpFormatterTest::testIndentedHeaderAndFooter
file: /tmp/Cli_33/src/test/java//org/apache/commons/cli/HelpFormatterTest.java
Begin: Pos(431, 12)
End: Pos(449, 5)
Source: /tmp/Cli_33/src/test/java//org/apache/commons/cli/HelpFormatterTest.java
Name: testIndentedHeaderAndFooter
Childs: [StatementAssertion<Begin: Pos(441, 9), End: Pos(448, 34)>,
]
--------------------
Run: Cli_29
@@@
Split test: org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes
file: /tmp/Cli_29/src/test//org/apache/commons/cli/UtilTest.java
Begin: Pos(35, 12)
End: Pos(42, 5)
Source: /tmp/Cli_29/src/test//org/apache/commons/cli/UtilTest.java
Name: testStripLeadingAndTrailingQuotes
Childs: [StatementAssertion<Begin: Pos(37, 9), End: Pos(37, 75)>,
StatementAssertion<Begin: Pos(38, 9), End: Pos(38, 87)>,
StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 87)>,
StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 103)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 69)>,
]
---
    public void testStripLeadingAndTrailingQuotes$catena_0()
    {
        assertEquals("foo", Util.stripLeadingAndTrailingQuotes("\"foo\""));                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo \"bar\"", Util.stripLeadingAndTrailingQuotes("foo \"bar\""));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" bar", Util.stripLeadingAndTrailingQuotes("\"foo\" bar"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" and \"bar\"", Util.stripLeadingAndTrailingQuotes("\"foo\" and \"bar\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"", Util.stripLeadingAndTrailingQuotes("\""));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStripLeadingAndTrailingQuotes$catena_1()
    {
        try{ assertEquals("foo", Util.stripLeadingAndTrailingQuotes("\"foo\""));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo \"bar\"", Util.stripLeadingAndTrailingQuotes("foo \"bar\""));                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("\"foo\" bar", Util.stripLeadingAndTrailingQuotes("\"foo\" bar"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" and \"bar\"", Util.stripLeadingAndTrailingQuotes("\"foo\" and \"bar\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"", Util.stripLeadingAndTrailingQuotes("\""));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStripLeadingAndTrailingQuotes$catena_2()
    {
        try{ assertEquals("foo", Util.stripLeadingAndTrailingQuotes("\"foo\""));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo \"bar\"", Util.stripLeadingAndTrailingQuotes("foo \"bar\""));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("\"foo\" bar", Util.stripLeadingAndTrailingQuotes("\"foo\" bar"));                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("\"foo\" and \"bar\"", Util.stripLeadingAndTrailingQuotes("\"foo\" and \"bar\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"", Util.stripLeadingAndTrailingQuotes("\""));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStripLeadingAndTrailingQuotes$catena_3()
    {
        try{ assertEquals("foo", Util.stripLeadingAndTrailingQuotes("\"foo\""));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo \"bar\"", Util.stripLeadingAndTrailingQuotes("foo \"bar\""));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" bar", Util.stripLeadingAndTrailingQuotes("\"foo\" bar"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("\"foo\" and \"bar\"", Util.stripLeadingAndTrailingQuotes("\"foo\" and \"bar\""));         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("\"", Util.stripLeadingAndTrailingQuotes("\""));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStripLeadingAndTrailingQuotes$catena_4()
    {
        try{ assertEquals("foo", Util.stripLeadingAndTrailingQuotes("\"foo\""));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo \"bar\"", Util.stripLeadingAndTrailingQuotes("foo \"bar\""));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" bar", Util.stripLeadingAndTrailingQuotes("\"foo\" bar"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("\"foo\" and \"bar\"", Util.stripLeadingAndTrailingQuotes("\"foo\" and \"bar\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("\"", Util.stripLeadingAndTrailingQuotes("\""));                                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_21
@@@
Split test: org.apache.commons.cli2.bug.BugCLI150Test::testNegativeNumber
file: /tmp/Cli_21/src/test//org/apache/commons/cli2/bug/BugCLI150Test.java
Begin: Pos(40, 12)
End: Pos(61, 5)
Source: /tmp/Cli_21/src/test//org/apache/commons/cli2/bug/BugCLI150Test.java
Name: testNegativeNumber
Childs: [StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 64)>,
]
--------------------
Run: Cli_9
@@@
Split test: org.apache.commons.cli.OptionsTest::testMissingOptionsException
file: /tmp/Cli_9/src/test//org/apache/commons/cli/OptionsTest.java
Begin: Pos(108, 12)
End: Pos(118, 5)
Source: /tmp/Cli_9/src/test//org/apache/commons/cli/OptionsTest.java
Name: testMissingOptionsException
Childs: [StatementAssertion<Begin: Pos(114, 13), End: Pos(114, 65)>,
StatementAssertion<Begin: Pos(116, 13), End: Pos(116, 75)>,
]
---
    public void testMissingOptionsException$catena_0() throws ParseException {
        Options options = new Options();
        options.addOption(OptionBuilder.isRequired().create("f"));
        options.addOption(OptionBuilder.isRequired().create("x"));
        try {
            new PosixParser().parse(options, new String[0]);
            fail("Expected MissingOptionException to be thrown");                                           /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (MissingOptionException e) {
            try{ assertEquals("Missing required options: f, x", e.getMessage());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testMissingOptionsException$catena_1() throws ParseException {
        Options options = new Options();
        options.addOption(OptionBuilder.isRequired().create("f"));
        options.addOption(OptionBuilder.isRequired().create("x"));
        try {
            new PosixParser().parse(options, new String[0]);
            try{ fail("Expected MissingOptionException to be thrown");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (MissingOptionException e) {
            assertEquals("Missing required options: f, x", e.getMessage());                                 /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
@@@
Split test: org.apache.commons.cli.ParseRequiredTest::testMissingRequiredOptions
file: /tmp/Cli_9/src/test//org/apache/commons/cli/ParseRequiredTest.java
Begin: Pos(118, 12)
End: Pos(141, 5)
Source: /tmp/Cli_9/src/test//org/apache/commons/cli/ParseRequiredTest.java
Name: testMissingRequiredOptions
Childs: [StatementAssertion<Begin: Pos(131, 13), End: Pos(131, 56)>,
StatementAssertion<Begin: Pos(135, 13), End: Pos(135, 108)>,
StatementAssertion<Begin: Pos(139, 13), End: Pos(139, 63)>,
]
---
    public void testMissingRequiredOptions$catena_0()
    {
        String[] args = new String[] { "-a" };

        _options.addOption( OptionBuilder.withLongOpt( "cfile" )
                                     .hasArg()
                                     .isRequired()
                                     .withDescription( "set the value of [c]" )
                                     .create( 'c' ) );

        try
        {
            CommandLine cl = parser.parse(_options,args);
            fail( "exception should have been thrown" );                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        }
        catch (MissingOptionException e)
        {
            try{ assertEquals( "Incorrect exception message", "Missing required options: b, c", e.getMessage() );    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (ParseException e)
        {
            try{ fail( "expected to catch MissingOptionException" );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testMissingRequiredOptions$catena_1()
    {
        String[] args = new String[] { "-a" };

        _options.addOption( OptionBuilder.withLongOpt( "cfile" )
                                     .hasArg()
                                     .isRequired()
                                     .withDescription( "set the value of [c]" )
                                     .create( 'c' ) );

        try
        {
            CommandLine cl = parser.parse(_options,args);
            try{ fail( "exception should have been thrown" );                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (MissingOptionException e)
        {
            assertEquals( "Incorrect exception message", "Missing required options: b, c", e.getMessage() );         /***** ORIGINAL ASSERTION IS HERE *****/
        }
        catch (ParseException e)
        {
            try{ fail( "expected to catch MissingOptionException" );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testMissingRequiredOptions$catena_2()
    {
        String[] args = new String[] { "-a" };

        _options.addOption( OptionBuilder.withLongOpt( "cfile" )
                                     .hasArg()
                                     .isRequired()
                                     .withDescription( "set the value of [c]" )
                                     .create( 'c' ) );

        try
        {
            CommandLine cl = parser.parse(_options,args);
            try{ fail( "exception should have been thrown" );                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (MissingOptionException e)
        {
            try{ assertEquals( "Incorrect exception message", "Missing required options: b, c", e.getMessage() );    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (ParseException e)
        {
            fail( "expected to catch MissingOptionException" );                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: Cli_19
@@@
Split test: org.apache.commons.cli.PosixParserTest::testUnrecognizedOption2
file: /tmp/Cli_19/src/test//org/apache/commons/cli/PosixParserTest.java
Begin: Pos(103, 12)
End: Pos(116, 5)
Source: /tmp/Cli_19/src/test//org/apache/commons/cli/PosixParserTest.java
Name: testUnrecognizedOption2
Childs: [StatementAssertion<Begin: Pos(110, 13), End: Pos(110, 62)>,
StatementAssertion<Begin: Pos(114, 13), End: Pos(114, 46)>,
]
---
    public void testUnrecognizedOption2$catena_0() throws Exception
    {
        String[] args = new String[] { "-z", "-abtoast", "foo", "bar" };

        try
        {
            parser.parse(options, args);
            fail("UnrecognizedOptionException wasn't thrown");                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        catch (UnrecognizedOptionException e)
        {
            try{ assertEquals("-z", e.getOption());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testUnrecognizedOption2$catena_1() throws Exception
    {
        String[] args = new String[] { "-z", "-abtoast", "foo", "bar" };

        try
        {
            parser.parse(options, args);
            try{ fail("UnrecognizedOptionException wasn't thrown");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (UnrecognizedOptionException e)
        {
            assertEquals("-z", e.getOption());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: Cli_18
@@@
Split test: org.apache.commons.cli.PosixParserTest::testStop2
file: /tmp/Cli_18/src/test//org/apache/commons/cli/PosixParserTest.java
Begin: Pos(133, 12)
End: Pos(142, 5)
Source: /tmp/Cli_18/src/test//org/apache/commons/cli/PosixParserTest.java
Name: testStop2
Childs: [StatementAssertion<Begin: Pos(140, 9), End: Pos(140, 64)>,
StatementAssertion<Begin: Pos(141, 9), End: Pos(141, 100)>,
]
---
    public void testStop2$catena_0() throws Exception
    {
        String[] args = new String[]{"-z",
                                     "-a",
                                     "-btoast"};

        CommandLine cl = parser.parse(options, args, true);
        assertFalse("Confirm -a is not set", cl.hasOption("a"));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Confirm  3 extra args: " + cl.getArgList().size(), cl.getArgList().size() == 3);    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStop2$catena_1() throws Exception
    {
        String[] args = new String[]{"-z",
                                     "-a",
                                     "-btoast"};

        CommandLine cl = parser.parse(options, args, true);
        try{ assertFalse("Confirm -a is not set", cl.hasOption("a"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Confirm  3 extra args: " + cl.getArgList().size(), cl.getArgList().size() == 3);         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_15
@@@
Split test: org.apache.commons.cli2.bug.BugCLI158Test::testSingleOptionSingleArgument
file: /tmp/Cli_15/src/test//org/apache/commons/cli2/bug/BugCLI158Test.java
Begin: Pos(62, 12)
End: Pos(71, 5)
Source: /tmp/Cli_15/src/test//org/apache/commons/cli2/bug/BugCLI158Test.java
Name: testSingleOptionSingleArgument
Childs: [StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 27)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 62)>,
]
---
    public void testSingleOptionSingleArgument$catena_0() throws Exception {
        Parser parser = createDefaultValueParser(new String[]{"100", "1000"});
        String enteredValue1 = "1";
        String[] args = new String[]{"-b", enteredValue1};
        CommandLine cl = parser.parse(args);
        CommandLine cmd = cl;
        assertNotNull(cmd);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        List b = cmd.getValues("-b");
        try{ assertEquals("[" + enteredValue1 + ", 1000]", b + "");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSingleOptionSingleArgument$catena_1() throws Exception {
        Parser parser = createDefaultValueParser(new String[]{"100", "1000"});
        String enteredValue1 = "1";
        String[] args = new String[]{"-b", enteredValue1};
        CommandLine cl = parser.parse(args);
        CommandLine cmd = cl;
        try{ assertNotNull(cmd);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        List b = cmd.getValues("-b");
        assertEquals("[" + enteredValue1 + ", 1000]", b + "");                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli2.bug.BugCLI158Test::testSingleOptionMaximumNumberOfArgument
file: /tmp/Cli_15/src/test//org/apache/commons/cli2/bug/BugCLI158Test.java
Begin: Pos(83, 12)
End: Pos(113, 5)
Source: /tmp/Cli_15/src/test//org/apache/commons/cli2/bug/BugCLI158Test.java
Name: testSingleOptionMaximumNumberOfArgument
Childs: [StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 27)>,
StatementAssertion<Begin: Pos(112, 9), End: Pos(112, 46)>,
]
---
    public void testSingleOptionMaximumNumberOfArgument$catena_0() throws Exception {
        String[] args = new String[]{"-b", "1", "2"};
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();

        DefaultOption bOption = obuilder.withShortName("b")
                .withLongName("b")
                .withArgument(abuilder.withName("b")
                        .withMinimum(2)
                        .withMaximum(4)
                        .withDefault("100")
                        .withDefault("1000")
                        .withDefault("10000")
                        .create())
                .create();

        Group options = gbuilder
                .withName("options")
                .withOption(bOption)
                .create();

        Parser parser = new Parser();
        parser.setHelpTrigger("--help");
        parser.setGroup(options);
        CommandLine cl = parser.parse(args);
        CommandLine cmd = cl;
        assertNotNull(cmd);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        List b = cmd.getValues("-b");
        try{ assertEquals("[1, 2, 10000]", b + "");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSingleOptionMaximumNumberOfArgument$catena_1() throws Exception {
        String[] args = new String[]{"-b", "1", "2"};
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();

        DefaultOption bOption = obuilder.withShortName("b")
                .withLongName("b")
                .withArgument(abuilder.withName("b")
                        .withMinimum(2)
                        .withMaximum(4)
                        .withDefault("100")
                        .withDefault("1000")
                        .withDefault("10000")
                        .create())
                .create();

        Group options = gbuilder
                .withName("options")
                .withOption(bOption)
                .create();

        Parser parser = new Parser();
        parser.setHelpTrigger("--help");
        parser.setGroup(options);
        CommandLine cl = parser.parse(args);
        CommandLine cmd = cl;
        try{ assertNotNull(cmd);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        List b = cmd.getValues("-b");
        assertEquals("[1, 2, 10000]", b + "");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_12
@@@
Split test: org.apache.commons.cli.GnuParserTest::testShortWithEqual
file: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Begin: Pos(199, 12)
End: Pos(210, 5)
Source: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Name: testShortWithEqual
Childs: [StatementAssertion<Begin: Pos(209, 9), End: Pos(209, 54)>,
]
@@@
Split test: org.apache.commons.cli.GnuParserTest::testLongWithEqualSingleDash
file: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Begin: Pos(238, 12)
End: Pos(249, 5)
Source: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Name: testLongWithEqualSingleDash
Childs: [StatementAssertion<Begin: Pos(248, 9), End: Pos(248, 54)>,
]
@@@
Split test: org.apache.commons.cli.GnuParserTest::testLongWithEqual
file: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Begin: Pos(225, 12)
End: Pos(236, 5)
Source: /tmp/Cli_12/src/test//org/apache/commons/cli/GnuParserTest.java
Name: testLongWithEqual
Childs: [StatementAssertion<Begin: Pos(235, 9), End: Pos(235, 54)>,
]
--------------------
Run: Cli_16
@@@
Split test: org.apache.commons.cli2.bug.BugCLI123Test::testMultipleChildOptions
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Begin: Pos(91, 12)
End: Pos(101, 5)
Source: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Name: testMultipleChildOptions
Childs: [StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 73)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(96, 41)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 71)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(99, 41)>,
StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 70)>,
]
---
    public void testMultipleChildOptions$catena_0() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test",
                "--sub", "anotherTest" });
        assertTrue("Child option not found", cl.hasOption(childOption1));                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Sub option not found", cl.hasOption(childOption2));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for sub option", "anotherTest", cl
                .getValue(childOption2));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMultipleChildOptions$catena_1() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test",
                "--sub", "anotherTest" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Sub option not found", cl.hasOption(childOption2));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for sub option", "anotherTest", cl
                .getValue(childOption2));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMultipleChildOptions$catena_2() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test",
                "--sub", "anotherTest" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Sub option not found", cl.hasOption(childOption2));                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Wrong value for sub option", "anotherTest", cl
                .getValue(childOption2));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMultipleChildOptions$catena_3() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test",
                "--sub", "anotherTest" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Sub option not found", cl.hasOption(childOption2));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Wrong value for sub option", "anotherTest", cl
                .getValue(childOption2));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMultipleChildOptions$catena_4() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test",
                "--sub", "anotherTest" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Sub option not found", cl.hasOption(childOption2));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for sub option", "anotherTest", cl
                .getValue(childOption2));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Child group not found", cl.hasOption(childGroup));                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli2.bug.BugCLI123Test::testParentOptionAndChildOption
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Begin: Pos(117, 12)
End: Pos(125, 5)
Source: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Name: testParentOptionAndChildOption
Childs: [StatementAssertion<Begin: Pos(121, 13), End: Pos(121, 65)>,
]
@@@
Split test: org.apache.commons.cli2.bug.BugCLI123Test::testSingleChildOption
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Begin: Pos(80, 12)
End: Pos(86, 5)
Source: /tmp/Cli_16/src/test//org/apache/commons/cli2/bug/BugCLI123Test.java
Name: testSingleChildOption
Childs: [StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 73)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(84, 41)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 70)>,
]
---
    public void testSingleChildOption$catena_0() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test" });
        assertTrue("Child option not found", cl.hasOption(childOption1));                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSingleChildOption$catena_1() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Child group not found", cl.hasOption(childGroup));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSingleChildOption$catena_2() throws OptionException {
        CommandLine cl = parser.parse(new String[] { "--child", "test" });
        try{ assertTrue("Child option not found", cl.hasOption(childOption1));                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Wrong value for option", "test", cl
                .getValue(childOption1));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Child group not found", cl.hasOption(childGroup));                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli2.commandline.DefaultingCommandLineTest::testGetOptions_Order
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testGetOptions_Order> in AST

---
@@@
Split test: org.apache.commons.cli2.commandline.PreferencesCommandLineTest::testGetOptions_Order
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testGetOptions_Order> in AST

---
@@@
Split test: org.apache.commons.cli2.commandline.PropertiesCommandLineTest::testGetOptions_Order
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testGetOptions_Order> in AST

---
@@@
Split test: org.apache.commons.cli2.commandline.WriteableCommandLineImplTest::testGetOptions_Order
file: /tmp/Cli_16/src/test//org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testGetOptions_Order> in AST

---
--------------------
Run: Cli_10
@@@
Split test: org.apache.commons.cli.ParseRequiredTest::testReuseOptionsTwice
file: /tmp/Cli_10/src/test//org/apache/commons/cli/ParseRequiredTest.java
Begin: Pos(143, 12)
End: Pos(163, 5)
Source: /tmp/Cli_10/src/test//org/apache/commons/cli/ParseRequiredTest.java
Name: testReuseOptionsTwice
Childs: [StatementAssertion<Begin: Pos(157, 13), End: Pos(157, 54)>,
]
--------------------
Run: Cli_20
@@@
Split test: org.apache.commons.cli.PosixParserTest::testStop3
file: /tmp/Cli_20/src/test//org/apache/commons/cli/PosixParserTest.java
Begin: Pos(159, 12)
End: Pos(170, 5)
Source: /tmp/Cli_20/src/test//org/apache/commons/cli/PosixParserTest.java
Name: testStop3
Childs: [StatementAssertion<Begin: Pos(167, 9), End: Pos(167, 64)>,
StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 64)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 100)>,
]
---
    public void testStop3$catena_0() throws Exception
    {
        String[] args = new String[]{"--zop==1",
                                     "-abtoast",
                                     "--b=bar"};

        CommandLine cl = parser.parse(options, args, true);

        assertFalse("Confirm -a is not set", cl.hasOption("a"));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse("Confirm -b is not set", cl.hasOption("b"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Confirm  3 extra args: " + cl.getArgList().size(), cl.getArgList().size() == 3);    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStop3$catena_1() throws Exception
    {
        String[] args = new String[]{"--zop==1",
                                     "-abtoast",
                                     "--b=bar"};

        CommandLine cl = parser.parse(options, args, true);

        try{ assertFalse("Confirm -a is not set", cl.hasOption("a"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse("Confirm -b is not set", cl.hasOption("b"));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Confirm  3 extra args: " + cl.getArgList().size(), cl.getArgList().size() == 3);    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStop3$catena_2() throws Exception
    {
        String[] args = new String[]{"--zop==1",
                                     "-abtoast",
                                     "--b=bar"};

        CommandLine cl = parser.parse(options, args, true);

        try{ assertFalse("Confirm -a is not set", cl.hasOption("a"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse("Confirm -b is not set", cl.hasOption("b"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Confirm  3 extra args: " + cl.getArgList().size(), cl.getArgList().size() == 3);         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_23
@@@
Split test: org.apache.commons.cli.bug.BugCLI162Test::testInfiniteLoop
file: /tmp/Cli_23/src/test//org/apache/commons/cli/bug/BugCLI162Test.java
Begin: Pos(42, 12)
End: Pos(46, 5)
Source: /tmp/Cli_23/src/test//org/apache/commons/cli/bug/BugCLI162Test.java
Name: testInfiniteLoop
Childs: []
@@@
Split test: org.apache.commons.cli.bug.BugCLI162Test::testPrintHelpLongLines
file: /tmp/Cli_23/src/test//org/apache/commons/cli/bug/BugCLI162Test.java
# check: Use pattern matching: None.testPrintHelp
Selector contains assertion
Begin: Pos(52, 12)
End: Pos(237, 5)
Source: /tmp/Cli_23/src/test//org/apache/commons/cli/bug/BugCLI162Test.java
Name: testPrintHelpLongLines
Childs: [StatementAssertion<Begin: Pos(236, 9), End: Pos(236, 47)>,
]
--------------------
Run: Cli_34
@@@
Split test: org.apache.commons.cli.CommandLineTest::testGetParsedOptionValue
file: /tmp/Cli_34/src/test/java//org/apache/commons/cli/CommandLineTest.java
Begin: Pos(65, 12)
End: Pos(75, 5)
Source: /tmp/Cli_34/src/test/java//org/apache/commons/cli/CommandLineTest.java
Name: testGetParsedOptionValue
Childs: [StatementAssertion<Begin: Pos(73, 9), End: Pos(73, 79)>,
StatementAssertion<Begin: Pos(74, 9), End: Pos(74, 59)>,
]
---
    public void testGetParsedOptionValue$catena_0() throws Exception {
        Options options = new Options();
        options.addOption(OptionBuilder.hasArg().withType(Number.class).create("i"));
        options.addOption(OptionBuilder.hasArg().create("f"));
        
        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, new String[] { "-i", "123", "-f", "foo" });
        
        assertEquals(123, ((Number) cmd.getParsedOptionValue("i")).intValue());                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo", cmd.getParsedOptionValue("f"));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetParsedOptionValue$catena_1() throws Exception {
        Options options = new Options();
        options.addOption(OptionBuilder.hasArg().withType(Number.class).create("i"));
        options.addOption(OptionBuilder.hasArg().create("f"));
        
        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, new String[] { "-i", "123", "-f", "foo" });
        
        try{ assertEquals(123, ((Number) cmd.getParsedOptionValue("i")).intValue());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo", cmd.getParsedOptionValue("f"));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli.OptionBuilderTest::testTwoCompleteOptions
file: /tmp/Cli_34/src/test/java//org/apache/commons/cli/OptionBuilderTest.java
Begin: Pos(42, 12)
End: Pos(71, 5)
Source: /tmp/Cli_34/src/test/java//org/apache/commons/cli/OptionBuilderTest.java
Name: testTwoCompleteOptions
Childs: [StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 45)>,
StatementAssertion<Begin: Pos(52, 9), End: Pos(52, 61)>,
StatementAssertion<Begin: Pos(53, 9), End: Pos(53, 75)>,
StatementAssertion<Begin: Pos(54, 9), End: Pos(54, 54)>,
StatementAssertion<Begin: Pos(55, 9), End: Pos(55, 38)>,
StatementAssertion<Begin: Pos(56, 9), End: Pos(56, 42)>,
StatementAssertion<Begin: Pos(57, 9), End: Pos(57, 39)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 45)>,
StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 61)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 75)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 55)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 38)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 43)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 40)>,
]
---
    public void testTwoCompleteOptions$catena_0( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        assertEquals( "s", simple.getOpt() );                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_1( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( "simple option", simple.getLongOpt() );                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_2( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( "this is a simple option", simple.getDescription() );                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_3( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( simple.getType(), Float.class );                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_4( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( simple.hasArg() );                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_5( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( simple.isRequired() );                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_6( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( simple.hasArgs() );                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_7( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        assertEquals( "d", simple.getOpt() );                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_8( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( "dimple option", simple.getLongOpt() );                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_9( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( "this is a dimple option", simple.getDescription() );                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_10( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals( String.class, simple.getType() );                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_11( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( simple.hasArg() );                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_12( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( !simple.isRequired() );                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue( !simple.hasArgs() );                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testTwoCompleteOptions$catena_13( ) {
        Option simple = OptionBuilder.withLongOpt( "simple option")
                                     .hasArg( )
                                     .isRequired( )
                                     .hasArgs( )
                                     .withType( Float.class )
                                     .withDescription( "this is a simple option" )
                                     .create( 's' );

        try{ assertEquals( "s", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "simple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a simple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( simple.getType(), Float.class );                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.isRequired() );                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArgs() );                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        simple = OptionBuilder.withLongOpt( "dimple option")
                              .hasArg( )
                              .withDescription( "this is a dimple option" )
                              .create( 'd' );

        try{ assertEquals( "d", simple.getOpt() );                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "dimple option", simple.getLongOpt() );                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( "this is a dimple option", simple.getDescription() );                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals( String.class, simple.getType() );                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( simple.hasArg() );                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue( !simple.isRequired() );                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue( !simple.hasArgs() );                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_7
@@@
Split test: org.apache.commons.cli2.bug.Bug27575Test::testRequiredOptions
file: /tmp/Cli_7/src/test//org/apache/commons/cli2/bug/Bug27575Test.java
Begin: Pos(29, 9)
End: Pos(40, 2)
Source: /tmp/Cli_7/src/test//org/apache/commons/cli2/bug/Bug27575Test.java
Name: testRequiredOptions
Childs: [StatementAssertion<Begin: Pos(33, 3), End: Pos(33, 42)>,
StatementAssertion<Begin: Pos(37, 3), End: Pos(37, 43)>,
StatementAssertion<Begin: Pos(38, 3), End: Pos(38, 47)>,
StatementAssertion<Begin: Pos(39, 3), End: Pos(39, 27)>,
]
---
	public void testRequiredOptions$catena_0(){
		PatternBuilder builder = new PatternBuilder();
		builder.withPattern("hc!<");
		Option option = builder.create();
		assertTrue(option instanceof GroupImpl);                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
		
		GroupImpl group = (GroupImpl)option;
		Iterator i = group.getOptions().iterator();
		try{ assertEquals("[-h]",i.next().toString());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
		try{ assertEquals("-c <arg>",i.next().toString());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
		try{ assertFalse(i.hasNext());                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
	}
---
---
	public void testRequiredOptions$catena_1(){
		PatternBuilder builder = new PatternBuilder();
		builder.withPattern("hc!<");
		Option option = builder.create();
		try{ assertTrue(option instanceof GroupImpl);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
		
		GroupImpl group = (GroupImpl)option;
		Iterator i = group.getOptions().iterator();
		assertEquals("[-h]",i.next().toString());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
		try{ assertEquals("-c <arg>",i.next().toString());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
		try{ assertFalse(i.hasNext());                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
	}
---
---
	public void testRequiredOptions$catena_2(){
		PatternBuilder builder = new PatternBuilder();
		builder.withPattern("hc!<");
		Option option = builder.create();
		try{ assertTrue(option instanceof GroupImpl);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
		
		GroupImpl group = (GroupImpl)option;
		Iterator i = group.getOptions().iterator();
		try{ assertEquals("[-h]",i.next().toString());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
		assertEquals("-c <arg>",i.next().toString());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
		try{ assertFalse(i.hasNext());                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
	}
---
---
	public void testRequiredOptions$catena_3(){
		PatternBuilder builder = new PatternBuilder();
		builder.withPattern("hc!<");
		Option option = builder.create();
		try{ assertTrue(option instanceof GroupImpl);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
		
		GroupImpl group = (GroupImpl)option;
		Iterator i = group.getOptions().iterator();
		try{ assertEquals("[-h]",i.next().toString());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
		try{ assertEquals("-c <arg>",i.next().toString());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
		assertFalse(i.hasNext());                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
	}
---
--------------------
Run: Cli_3
@@@
Split test: org.apache.commons.cli.PatternOptionBuilderTest::testSimplePattern
file: /tmp/Cli_3/src/test//org/apache/commons/cli/PatternOptionBuilderTest.java
Begin: Pos(45, 11)
End: Pos(84, 4)
Source: /tmp/Cli_3/src/test//org/apache/commons/cli/PatternOptionBuilderTest.java
Name: testSimplePattern
Childs: [StatementAssertion<Begin: Pos(56, 12), End: Pos(56, 67)>,
StatementAssertion<Begin: Pos(57, 12), End: Pos(57, 67)>,
StatementAssertion<Begin: Pos(58, 12), End: Pos(58, 75)>,
StatementAssertion<Begin: Pos(59, 12), End: Pos(59, 75)>,
StatementAssertion<Begin: Pos(60, 12), End: Pos(60, 92)>,
StatementAssertion<Begin: Pos(61, 12), End: Pos(61, 92)>,
StatementAssertion<Begin: Pos(62, 12), End: Pos(62, 74)>,
StatementAssertion<Begin: Pos(63, 12), End: Pos(63, 74)>,
StatementAssertion<Begin: Pos(64, 12), End: Pos(64, 76)>,
StatementAssertion<Begin: Pos(65, 12), End: Pos(65, 76)>,
StatementAssertion<Begin: Pos(66, 12), End: Pos(66, 97)>,
StatementAssertion<Begin: Pos(67, 12), End: Pos(67, 97)>,
StatementAssertion<Begin: Pos(68, 12), End: Pos(68, 93)>,
StatementAssertion<Begin: Pos(69, 12), End: Pos(69, 93)>,
StatementAssertion<Begin: Pos(70, 12), End: Pos(70, 85)>,
StatementAssertion<Begin: Pos(71, 12), End: Pos(71, 85)>,
StatementAssertion<Begin: Pos(72, 12), End: Pos(72, 113)>,
StatementAssertion<Begin: Pos(73, 12), End: Pos(73, 113)>,
StatementAssertion<Begin: Pos(79, 12), End: Pos(79, 36)>,
StatementAssertion<Begin: Pos(82, 12), End: Pos(82, 36)>,
]
---
   public void testSimplePattern$catena_0()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           assertEquals("flag a", "foo", line.getOptionValue("a"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_1()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("flag a", "foo", line.getOptionValue('a'));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_2()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("string flag a", "foo", line.getOptionObject("a"));                                               /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_3()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("string flag a", "foo", line.getOptionObject('a'));                                               /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_4()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                              /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_5()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                              /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_6()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("boolean true flag c", true, line.hasOption("c"));                                                /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_7()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("boolean true flag c", true, line.hasOption('c'));                                                /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_8()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("boolean false flag d", false, line.hasOption("d"));                                              /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_9()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("boolean false flag d", false, line.hasOption('d'));                                              /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_10()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                         /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_11()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                         /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_12()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                             /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_13()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                             /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_14()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                     /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_15()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                     /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_16()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));         /***** ORIGINAL ASSERTION IS HERE *****/
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_17()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));         /***** ORIGINAL ASSERTION IS HERE *****/
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_18()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           fail( exp.getMessage() );                                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
       }
       catch( java.net.MalformedURLException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
   }
---
---
   public void testSimplePattern$catena_19()
   {
       try {
           Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/");
           String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" };
      
           CommandLineParser parser = new PosixParser();
           CommandLine line = parser.parse(options,args);

           // tests the char methods of CommandLine that delegate to
           // the String methods
           try{ assertEquals("flag a", "foo", line.getOptionValue("a"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("flag a", "foo", line.getOptionValue('a'));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject("a"));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("string flag a", "foo", line.getOptionObject('a'));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject("b"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("object flag b", new java.util.Vector(), line.getOptionObject('b'));                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption("c"));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean true flag c", true, line.hasOption('c'));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption("d"));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("boolean false flag d", false, line.hasOption('d'));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject("e"));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("file flag e", new java.io.File("build.xml"), line.getOptionObject('e'));                    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject("f"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("class flag f", java.util.Calendar.class, line.getOptionObject('f'));                        }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject("n"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("number flag n", new Double(4.5), line.getOptionObject('n'));                                }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject("t"));    }catch(Throwable __SHOULD_BE_IGNORED){}
           try{ assertEquals("url flag t", new java.net.URL("http://jakarta.apache.org/"), line.getOptionObject('t'));    }catch(Throwable __SHOULD_BE_IGNORED){}
           /// DATES NOT SUPPORTED YET.
           //      assertEquals("number flag t", new java.util.Date(1023400137276L), line.getOptionObject('z'));
           //     input is:  "Thu Jun 06 17:48:57 EDT 2002"
       }
       catch( ParseException exp ) {
           try{ fail( exp.getMessage() );                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
       }
       catch( java.net.MalformedURLException exp ) {
           fail( exp.getMessage() );                                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
       }
   }
---
--------------------
Run: Cli_13
@@@
Split test: org.apache.commons.cli2.bug.BugLoopingOptionLookAlikeTest::testLoopingOptionLookAlike2
file: /tmp/Cli_13/src/test//org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java
Begin: Pos(63, 12)
End: Pos(78, 5)
Source: /tmp/Cli_13/src/test//org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java
Name: testLoopingOptionLookAlike2
Childs: [StatementAssertion<Begin: Pos(74, 13), End: Pos(74, 36)>,
StatementAssertion<Begin: Pos(76, 13), End: Pos(76, 86)>,
]
---
    public void testLoopingOptionLookAlike2$catena_0() {
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();
        final Argument inputfile_opt = abuilder.withName("input").withMinimum(1).withMaximum(1).create();
        final Argument outputfile_opt = abuilder.withName("output").withMinimum(1).withMaximum(1).create();
        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);
        final Group options = gbuilder.withOption(targets).create();
        final Parser parser = new Parser();
        parser.setGroup(options);
        try {
            parser.parse(new String[] { "testfile.txt", "testfile.txt", "testfile.txt", "testfile.txt" });
            fail("OptionException");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (OptionException e) {
            try{ assertEquals("Unexpected testfile.txt while processing ", e.getMessage());                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }    
---
---
    public void testLoopingOptionLookAlike2$catena_1() {
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();
        final Argument inputfile_opt = abuilder.withName("input").withMinimum(1).withMaximum(1).create();
        final Argument outputfile_opt = abuilder.withName("output").withMinimum(1).withMaximum(1).create();
        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);
        final Group options = gbuilder.withOption(targets).create();
        final Parser parser = new Parser();
        parser.setGroup(options);
        try {
            parser.parse(new String[] { "testfile.txt", "testfile.txt", "testfile.txt", "testfile.txt" });
            try{ fail("OptionException");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (OptionException e) {
            assertEquals("Unexpected testfile.txt while processing ", e.getMessage());                      /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }    
---
--------------------
Run: Cli_36
@@@
Split test: org.apache.commons.cli.bug.BugCLI266Test::testOptionComparatorInsertedOrder
file: /tmp/Cli_36/src/test/java//org/apache/commons/cli/bug/BugCLI266Test.java
Begin: Pos(34, 5)
End: Pos(42, 5)
Source: /tmp/Cli_36/src/test/java//org/apache/commons/cli/bug/BugCLI266Test.java
Name: testOptionComparatorInsertedOrder
Childs: [StatementAssertion<Begin: Pos(39, 13), End: Pos(39, 66)>,
]
--------------------
Run: Cli_31
@@@
Split test: org.apache.commons.cli.HelpFormatterTest::testDefaultArgName
file: /tmp/Cli_31/src/test/java//org/apache/commons/cli/HelpFormatterTest.java
Begin: Pos(308, 12)
End: Pos(322, 5)
Source: /tmp/Cli_31/src/test/java//org/apache/commons/cli/HelpFormatterTest.java
Name: testDefaultArgName
Childs: [StatementAssertion<Begin: Pos(321, 9), End: Pos(321, 71)>,
]
--------------------
Run: Cli_38
@@@
Split test: org.apache.commons.cli.bug.BugCLI265Test::shouldParseConcatenatedShortOptions
file: /tmp/Cli_38/src/test/java//org/apache/commons/cli/bug/BugCLI265Test.java
Begin: Pos(76, 5)
End: Pos(87, 5)
Source: /tmp/Cli_38/src/test/java//org/apache/commons/cli/bug/BugCLI265Test.java
Name: shouldParseConcatenatedShortOptions
Childs: [StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 48)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 53)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 47)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 47)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 51)>,
]
---
    @Test
    public void shouldParseConcatenatedShortOptions$catena_0() throws Exception {
        String[] concatenatedShortOptions = new String[] { "-t1", "-ab" };

        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);

        assertTrue(commandLine.hasOption("t1"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(commandLine.getOptionValue("t1"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("a"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("b"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(commandLine.hasOption("last"));                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseConcatenatedShortOptions$catena_1() throws Exception {
        String[] concatenatedShortOptions = new String[] { "-t1", "-ab" };

        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(commandLine.getOptionValue("t1"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(commandLine.hasOption("a"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("b"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(commandLine.hasOption("last"));                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseConcatenatedShortOptions$catena_2() throws Exception {
        String[] concatenatedShortOptions = new String[] { "-t1", "-ab" };

        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(commandLine.getOptionValue("t1"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(commandLine.hasOption("a"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(commandLine.hasOption("b"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(commandLine.hasOption("last"));                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseConcatenatedShortOptions$catena_3() throws Exception {
        String[] concatenatedShortOptions = new String[] { "-t1", "-ab" };

        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(commandLine.getOptionValue("t1"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("a"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(commandLine.hasOption("b"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(commandLine.hasOption("last"));                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldParseConcatenatedShortOptions$catena_4() throws Exception {
        String[] concatenatedShortOptions = new String[] { "-t1", "-ab" };

        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);

        try{ assertTrue(commandLine.hasOption("t1"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(commandLine.getOptionValue("t1"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("a"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption("b"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(commandLine.hasOption("last"));                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_1
@@@
Split test: org.apache.commons.cli.bug.BugCLI13Test::testCLI13
file: /tmp/Cli_1/src/test//org/apache/commons/cli/bug/BugCLI13Test.java
Begin: Pos(33, 12)
End: Pos(51, 5)
Source: /tmp/Cli_1/src/test//org/apache/commons/cli/bug/BugCLI13Test.java
Name: testCLI13
Childs: [StatementAssertion<Begin: Pos(47, 9), End: Pos(47, 69)>,
StatementAssertion<Begin: Pos(48, 9), End: Pos(48, 64)>,
StatementAssertion<Begin: Pos(49, 9), End: Pos(49, 48)>,
StatementAssertion<Begin: Pos(50, 9), End: Pos(50, 53)>,
]
---
    public void testCLI13$catena_0()
        throws ParseException
    {
        final String debugOpt = "debug";
        Option debug = OptionBuilder
            .withArgName( debugOpt )
            .withDescription( "turn on debugging" )
            .withLongOpt( debugOpt )
            .hasArg()
            .create( 'd' );
        Options options = new Options();
        options.addOption( debug );
        CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} );

        assertEquals("true", commandLine.getOptionValue( debugOpt ));                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("true", commandLine.getOptionValue( 'd' ));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption( 'd'));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption( debugOpt));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCLI13$catena_1()
        throws ParseException
    {
        final String debugOpt = "debug";
        Option debug = OptionBuilder
            .withArgName( debugOpt )
            .withDescription( "turn on debugging" )
            .withLongOpt( debugOpt )
            .hasArg()
            .create( 'd' );
        Options options = new Options();
        options.addOption( debug );
        CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} );

        try{ assertEquals("true", commandLine.getOptionValue( debugOpt ));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("true", commandLine.getOptionValue( 'd' ));                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(commandLine.hasOption( 'd'));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption( debugOpt));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCLI13$catena_2()
        throws ParseException
    {
        final String debugOpt = "debug";
        Option debug = OptionBuilder
            .withArgName( debugOpt )
            .withDescription( "turn on debugging" )
            .withLongOpt( debugOpt )
            .hasArg()
            .create( 'd' );
        Options options = new Options();
        options.addOption( debug );
        CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} );

        try{ assertEquals("true", commandLine.getOptionValue( debugOpt ));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("true", commandLine.getOptionValue( 'd' ));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(commandLine.hasOption( 'd'));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(commandLine.hasOption( debugOpt));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCLI13$catena_3()
        throws ParseException
    {
        final String debugOpt = "debug";
        Option debug = OptionBuilder
            .withArgName( debugOpt )
            .withDescription( "turn on debugging" )
            .withLongOpt( debugOpt )
            .hasArg()
            .create( 'd' );
        Options options = new Options();
        options.addOption( debug );
        CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} );

        try{ assertEquals("true", commandLine.getOptionValue( debugOpt ));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("true", commandLine.getOptionValue( 'd' ));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(commandLine.hasOption( 'd'));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(commandLine.hasOption( debugOpt));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_27
@@@
Split test: org.apache.commons.cli.BasicParserTest::testOptionGroupLong
file: /tmp/Cli_27/src/test//org/apache/commons/cli/BasicParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testOptionGroupLong> in AST

---
@@@
Split test: org.apache.commons.cli.GnuParserTest::testOptionGroupLong
file: /tmp/Cli_27/src/test//org/apache/commons/cli/GnuParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testOptionGroupLong> in AST

---
@@@
Split test: org.apache.commons.cli.PosixParserTest::testOptionGroupLong
file: /tmp/Cli_27/src/test//org/apache/commons/cli/PosixParserTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testOptionGroupLong> in AST

---
--------------------
Run: Cli_39
@@@
Split test: org.apache.commons.cli.PatternOptionBuilderTest::testExistingFilePattern
file: /tmp/Cli_39/src/test/java//org/apache/commons/cli/PatternOptionBuilderTest.java
Begin: Pos(161, 5)
End: Pos(172, 5)
Source: /tmp/Cli_39/src/test/java//org/apache/commons/cli/PatternOptionBuilderTest.java
Name: testExistingFilePattern
Childs: [StatementAssertion<Begin: Pos(170, 9), End: Pos(170, 71)>,
StatementAssertion<Begin: Pos(171, 9), End: Pos(171, 104)>,
]
---
    @Test
    public void testExistingFilePattern$catena_0() throws Exception
    {
        final Options options = PatternOptionBuilder.parsePattern("g<");
        final CommandLineParser parser = new PosixParser();
        final CommandLine line = parser.parse(options, new String[] { "-g", "src/test/resources/existing-readable.file" });

        final Object parsedReadableFileStream = line.getOptionObject("g");

        assertNotNull("option g not parsed", parsedReadableFileStream);                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("option g not FileInputStream", parsedReadableFileStream instanceof FileInputStream);    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testExistingFilePattern$catena_1() throws Exception
    {
        final Options options = PatternOptionBuilder.parsePattern("g<");
        final CommandLineParser parser = new PosixParser();
        final CommandLine line = parser.parse(options, new String[] { "-g", "src/test/resources/existing-readable.file" });

        final Object parsedReadableFileStream = line.getOptionObject("g");

        try{ assertNotNull("option g not parsed", parsedReadableFileStream);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("option g not FileInputStream", parsedReadableFileStream instanceof FileInputStream);         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.cli.PatternOptionBuilderTest::testExistingFilePatternFileNotExist
file: /tmp/Cli_39/src/test/java//org/apache/commons/cli/PatternOptionBuilderTest.java
Begin: Pos(174, 5)
End: Pos(181, 5)
Source: /tmp/Cli_39/src/test/java//org/apache/commons/cli/PatternOptionBuilderTest.java
Name: testExistingFilePatternFileNotExist
Childs: [StatementAssertion<Begin: Pos(180, 9), End: Pos(180, 65)>,
]
--------------------
Run: Cli_26
@@@
Split test: org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways
file: /tmp/Cli_26/src/test//org/apache/commons/cli/OptionBuilderTest.java
Begin: Pos(154, 12)
End: Pos(176, 5)
Source: /tmp/Cli_26/src/test//org/apache/commons/cli/OptionBuilderTest.java
Name: testBuilderIsResettedAlways
Childs: [StatementAssertion<Begin: Pos(158, 13), End: Pos(158, 54)>,
StatementAssertion<Begin: Pos(164, 9), End: Pos(164, 93)>,
StatementAssertion<Begin: Pos(169, 13), End: Pos(169, 54)>,
StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 93)>,
]
---
    public void testBuilderIsResettedAlways$catena_0() {
        try
        {
            OptionBuilder.withDescription("JUnit").create('"');
            fail("IllegalArgumentException expected");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}

        try
        {
            OptionBuilder.withDescription("JUnit").create();
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBuilderIsResettedAlways$catena_1() {
        try
        {
            OptionBuilder.withDescription("JUnit").create('"');
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        assertNull("we inherited a description", OptionBuilder.create('x').getDescription());               /***** ORIGINAL ASSERTION IS HERE *****/

        try
        {
            OptionBuilder.withDescription("JUnit").create();
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBuilderIsResettedAlways$catena_2() {
        try
        {
            OptionBuilder.withDescription("JUnit").create('"');
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}

        try
        {
            OptionBuilder.withDescription("JUnit").create();
            fail("IllegalArgumentException expected");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBuilderIsResettedAlways$catena_3() {
        try
        {
            OptionBuilder.withDescription("JUnit").create('"');
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        try{ assertNull("we inherited a description", OptionBuilder.create('x').getDescription());          }catch(Throwable __SHOULD_BE_IGNORED){}

        try
        {
            OptionBuilder.withDescription("JUnit").create();
            try{ fail("IllegalArgumentException expected");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        catch (IllegalArgumentException e)
        {
            // expected
        }
        assertNull("we inherited a description", OptionBuilder.create('x').getDescription());               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Cli_14
@@@
Split test: org.apache.commons.cli2.bug.BugCLI144Test::testFileValidator
file: /tmp/Cli_14/src/test//org/apache/commons/cli2/bug/BugCLI144Test.java
Begin: Pos(44, 9)
End: Pos(65, 2)
Source: /tmp/Cli_14/src/test//org/apache/commons/cli2/bug/BugCLI144Test.java
Name: testFileValidator
Childs: [StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 26)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 84)>,
]
---
	public void testFileValidator$catena_0() {
		final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();
        DefaultOption fileNameOption = obuilder.withShortName("f")
                .withLongName("file-name").withRequired(true).withDescription(
                        "name of an existing file").withArgument(
                        abuilder.withName("file-name").withValidator(
                                FileValidator.getExistingFileInstance())
                                .create()).create();
        Group options = gbuilder.withName("options").withOption(fileNameOption)
                .create();
        Parser parser = new Parser();
        parser.setHelpTrigger("--help");
        parser.setGroup(options);

        final String fileName = "src/test/org/apache/commons/cli2/bug/BugCLI144Test.java";
        CommandLine cl = parser
                .parseAndHelp(new String[] { "--file-name", fileName });
        assertNotNull(cl);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Wrong file", new File(fileName), cl.getValue(fileNameOption));                   }catch(Throwable __SHOULD_BE_IGNORED){}
	}
---
---
	public void testFileValidator$catena_1() {
		final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();
        final ArgumentBuilder abuilder = new ArgumentBuilder();
        final GroupBuilder gbuilder = new GroupBuilder();
        DefaultOption fileNameOption = obuilder.withShortName("f")
                .withLongName("file-name").withRequired(true).withDescription(
                        "name of an existing file").withArgument(
                        abuilder.withName("file-name").withValidator(
                                FileValidator.getExistingFileInstance())
                                .create()).create();
        Group options = gbuilder.withName("options").withOption(fileNameOption)
                .create();
        Parser parser = new Parser();
        parser.setHelpTrigger("--help");
        parser.setGroup(options);

        final String fileName = "src/test/org/apache/commons/cli2/bug/BugCLI144Test.java";
        CommandLine cl = parser
                .parseAndHelp(new String[] { "--file-name", fileName });
        try{ assertNotNull(cl);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Wrong file", new File(fileName), cl.getValue(fileNameOption));                        /***** ORIGINAL ASSERTION IS HERE *****/
	}
---
--------------------
Run: Cli_6
--------------------
Run: Codec_11
@@@
Split test: org.apache.commons.codec.net.QuotedPrintableCodecTest::testSkipNotEncodedCRLF
file: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Begin: Pos(294, 5)
End: Pos(304, 5)
Source: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Name: testSkipNotEncodedCRLF
Childs: [StatementAssertion<Begin: Pos(300, 9), End: Pos(300, 55)>,
StatementAssertion<Begin: Pos(303, 9), End: Pos(303, 56)>,
]
---
    @Test
    public void testSkipNotEncodedCRLF$catena_0() throws Exception {
        String qpdata = "CRLF in an\n encoded text should be=20=\r\n\rskipped in the\r decoding.";
        String expected = "CRLF in an encoded text should be skipped in the decoding.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        assertEquals(expected, qpcodec.decode(qpdata));                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        String encoded = qpcodec.encode(expected);
        try{ assertEquals(expected, qpcodec.decode(encoded));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipNotEncodedCRLF$catena_1() throws Exception {
        String qpdata = "CRLF in an\n encoded text should be=20=\r\n\rskipped in the\r decoding.";
        String expected = "CRLF in an encoded text should be skipped in the decoding.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        try{ assertEquals(expected, qpcodec.decode(qpdata));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        String encoded = qpcodec.encode(expected);
        assertEquals(expected, qpcodec.decode(encoded));                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.net.QuotedPrintableCodecTest::testSoftLineBreakDecode
file: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Begin: Pos(266, 5)
End: Pos(278, 5)
Source: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Name: testSoftLineBreakDecode
Childs: [StatementAssertion<Begin: Pos(274, 9), End: Pos(274, 55)>,
StatementAssertion<Begin: Pos(277, 9), End: Pos(277, 56)>,
]
---
    @Test
    public void testSoftLineBreakDecode$catena_0() throws Exception {
        String qpdata = "If you believe that truth=3Dbeauty, then surely=20=\r\nmathematics " +
                "is the most beautiful branch of philosophy.";
        String expected = "If you believe that truth=beauty, then surely mathematics " +
                "is the most beautiful branch of philosophy.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        assertEquals(expected, qpcodec.decode(qpdata));                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        String encoded = qpcodec.encode(expected);
        try{ assertEquals(expected, qpcodec.decode(encoded));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSoftLineBreakDecode$catena_1() throws Exception {
        String qpdata = "If you believe that truth=3Dbeauty, then surely=20=\r\nmathematics " +
                "is the most beautiful branch of philosophy.";
        String expected = "If you believe that truth=beauty, then surely mathematics " +
                "is the most beautiful branch of philosophy.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        try{ assertEquals(expected, qpcodec.decode(qpdata));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        String encoded = qpcodec.encode(expected);
        assertEquals(expected, qpcodec.decode(encoded));                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.net.QuotedPrintableCodecTest::testSoftLineBreakEncode
file: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Begin: Pos(280, 5)
End: Pos(292, 5)
Source: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Name: testSoftLineBreakEncode
Childs: [StatementAssertion<Begin: Pos(288, 9), End: Pos(288, 55)>,
StatementAssertion<Begin: Pos(291, 9), End: Pos(291, 54)>,
]
---
    @Test
    public void testSoftLineBreakEncode$catena_0() throws Exception {
        String qpdata = "If you believe that truth=3Dbeauty, then surely mathematics is the most " +
                "b=\r\neautiful branch of philosophy.";
        String expected = "If you believe that truth=beauty, then surely mathematics is the most " +
                "beautiful branch of philosophy.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        assertEquals(qpdata, qpcodec.encode(expected));                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        String decoded = qpcodec.decode(qpdata);
        try{ assertEquals(qpdata, qpcodec.encode(decoded));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSoftLineBreakEncode$catena_1() throws Exception {
        String qpdata = "If you believe that truth=3Dbeauty, then surely mathematics is the most " +
                "b=\r\neautiful branch of philosophy.";
        String expected = "If you believe that truth=beauty, then surely mathematics is the most " +
                "beautiful branch of philosophy.";

        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();
        try{ assertEquals(qpdata, qpcodec.encode(expected));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        String decoded = qpcodec.decode(qpdata);
        assertEquals(qpdata, qpcodec.encode(decoded));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.net.QuotedPrintableCodecTest::testUltimateSoftBreak
file: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Begin: Pos(319, 5)
End: Pos(344, 5)
Source: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Name: testUltimateSoftBreak
Childs: [StatementAssertion<Begin: Pos(326, 9), End: Pos(326, 54)>,
StatementAssertion<Begin: Pos(331, 9), End: Pos(331, 54)>,
StatementAssertion<Begin: Pos(337, 9), End: Pos(337, 54)>,
StatementAssertion<Begin: Pos(343, 9), End: Pos(343, 54)>,
]
---
    @Test
    public void testUltimateSoftBreak$catena_0() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. There is no end to it\t";
        String expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=09";

        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        plain ="This is a example of a quoted-printable text file. There is no end to it ";
        expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // whitespace before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to   ";
        expected = "This is a example of a quoted-printable text file. There is no end to=20=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // non-printable character before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to=  ";
        expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testUltimateSoftBreak$catena_1() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. There is no end to it\t";
        String expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=09";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        plain ="This is a example of a quoted-printable text file. There is no end to it ";
        expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=20";

        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        // whitespace before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to   ";
        expected = "This is a example of a quoted-printable text file. There is no end to=20=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // non-printable character before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to=  ";
        expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testUltimateSoftBreak$catena_2() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. There is no end to it\t";
        String expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=09";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        plain ="This is a example of a quoted-printable text file. There is no end to it ";
        expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // whitespace before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to   ";
        expected = "This is a example of a quoted-printable text file. There is no end to=20=\r\n =20";

        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        // non-printable character before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to=  ";
        expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testUltimateSoftBreak$catena_3() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. There is no end to it\t";
        String expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=09";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        plain ="This is a example of a quoted-printable text file. There is no end to it ";
        expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // whitespace before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to   ";
        expected = "This is a example of a quoted-printable text file. There is no end to=20=\r\n =20";

        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // non-printable character before soft break
        plain ="This is a example of a quoted-printable text file. There is no end to=  ";
        expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20";

        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.net.QuotedPrintableCodecTest::testTrailingSpecial
file: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Begin: Pos(306, 5)
End: Pos(317, 5)
Source: /tmp/Codec_11/src/test/java//org/apache/commons/codec/net/QuotedPrintableCodecTest.java
Name: testTrailingSpecial
Childs: [StatementAssertion<Begin: Pos(312, 9), End: Pos(312, 54)>,
StatementAssertion<Begin: Pos(316, 9), End: Pos(316, 54)>,
]
---
    @Test
    public void testTrailingSpecial$catena_0() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. This might contain sp=cial chars.";
        String expected = "This is a example of a quoted-printable text file. This might contain sp=3D=\r\ncial chars.";
        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        plain ="This is a example of a quoted-printable text file. This might contain ta\tbs as well.";
        expected = "This is a example of a quoted-printable text file. This might contain ta=09=\r\nbs as well.";
        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testTrailingSpecial$catena_1() throws Exception {
        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();

        String plain ="This is a example of a quoted-printable text file. This might contain sp=cial chars.";
        String expected = "This is a example of a quoted-printable text file. This might contain sp=3D=\r\ncial chars.";
        try{ assertEquals(expected, qpcodec.encode(plain));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        plain ="This is a example of a quoted-printable text file. This might contain ta\tbs as well.";
        expected = "This is a example of a quoted-printable text file. This might contain ta=09=\r\nbs as well.";
        assertEquals(expected, qpcodec.encode(plain));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Codec_8
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105
file: /tmp/Codec_8/src/test//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(55, 12)
End: Pos(60, 5)
Source: /tmp/Codec_8/src/test//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testCodec105
Childs: []
--------------------
Run: Codec_15
@@@
Split test: org.apache.commons.codec.language.SoundexTest::testHWRuleEx1
file: /tmp/Codec_15/src/test/java//org/apache/commons/codec/language/SoundexTest.java
Begin: Pos(223, 5)
End: Pos(233, 5)
Source: /tmp/Codec_15/src/test/java//org/apache/commons/codec/language/SoundexTest.java
Name: testHWRuleEx1
Childs: [StatementAssertion<Begin: Pos(229, 9), End: Pos(229, 80)>,
StatementAssertion<Begin: Pos(230, 9), End: Pos(230, 80)>,
StatementAssertion<Begin: Pos(231, 9), End: Pos(231, 79)>,
StatementAssertion<Begin: Pos(232, 9), End: Pos(232, 78)>,
]
---
    @Test
    public void testHWRuleEx1$catena_0() {
        // From
        // http://www.archives.gov/research_room/genealogy/census/soundex.html:
        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1
        // for the F). It is not coded A-226.
        Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft"));                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yehudit"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yhwdyt"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testHWRuleEx1$catena_1() {
        // From
        // http://www.archives.gov/research_room/genealogy/census/soundex.html:
        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1
        // for the F). It is not coded A-226.
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft"));                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yehudit"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yhwdyt"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testHWRuleEx1$catena_2() {
        // From
        // http://www.archives.gov/research_room/genealogy/census/soundex.html:
        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1
        // for the F). It is not coded A-226.
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        Assert.assertEquals("Y330", this.getStringEncoder().encode("yehudit"));                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yhwdyt"));                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testHWRuleEx1$catena_3() {
        // From
        // http://www.archives.gov/research_room/genealogy/census/soundex.html:
        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1
        // for the F). It is not coded A-226.
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft"));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ Assert.assertEquals("Y330", this.getStringEncoder().encode("yehudit"));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        Assert.assertEquals("Y330", this.getStringEncoder().encode("yhwdyt"));                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Codec_12
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testSkipToEnd
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(521, 5)
End: Pos(530, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testSkipToEnd
Childs: [StatementAssertion<Begin: Pos(526, 9), End: Pos(526, 43)>,
StatementAssertion<Begin: Pos(528, 9), End: Pos(528, 43)>,
StatementAssertion<Begin: Pos(529, 9), End: Pos(529, 43)>,
]
---
    @Test
    public void testSkipToEnd$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        assertEquals(3, b32stream.skip(3));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipToEnd$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(3, b32stream.skip(3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipToEnd$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(3, b32stream.skip(3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testCodec130
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(47, 5)
End: Pos(64, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testCodec130
Childs: [StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 55)>,
]
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testSkipWrongArgument
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(537, 5)
End: Pos(542, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testSkipWrongArgument
Childs: []
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testAvailable
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(152, 5)
End: Pos(163, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testAvailable
Childs: [StatementAssertion<Begin: Pos(156, 9), End: Pos(156, 47)>,
StatementAssertion<Begin: Pos(157, 9), End: Pos(157, 44)>,
StatementAssertion<Begin: Pos(159, 9), End: Pos(159, 47)>,
StatementAssertion<Begin: Pos(160, 9), End: Pos(160, 43)>,
StatementAssertion<Begin: Pos(161, 9), End: Pos(161, 43)>,
StatementAssertion<Begin: Pos(162, 9), End: Pos(162, 47)>,
]
---
    @Test
    public void testAvailable$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        assertEquals(1, b32stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(1, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, b32stream.skip(10));                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(1, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(0, b32stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_3() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(1, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_4() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(1, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_5() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(1, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b32stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, b32stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testSkipPastEnd
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(505, 5)
End: Pos(514, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testSkipPastEnd
Childs: [StatementAssertion<Begin: Pos(510, 9), End: Pos(510, 44)>,
StatementAssertion<Begin: Pos(512, 9), End: Pos(512, 43)>,
StatementAssertion<Begin: Pos(513, 9), End: Pos(513, 43)>,
]
---
    @Test
    public void testSkipPastEnd$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        assertEquals(3, b32stream.skip(10));                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipPastEnd$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipPastEnd$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(3, b32stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base32InputStreamTest::testSkipBig
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Begin: Pos(490, 5)
End: Pos(498, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base32InputStreamTest.java
Name: testSkipBig
Childs: [StatementAssertion<Begin: Pos(494, 9), End: Pos(494, 46)>,
StatementAssertion<Begin: Pos(496, 9), End: Pos(496, 43)>,
StatementAssertion<Begin: Pos(497, 9), End: Pos(497, 43)>,
]
---
    @Test
    public void testSkipBig$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        assertEquals(3, b32stream.skip(1024));                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipBig$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(3, b32stream.skip(1024));                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipBig$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
        Base32InputStream b32stream = new Base32InputStream(ins);
        try{ assertEquals(3, b32stream.skip(1024));                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b32stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b32stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testSkipToEnd
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(532, 5)
End: Pos(541, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testSkipToEnd
Childs: [StatementAssertion<Begin: Pos(537, 9), End: Pos(537, 43)>,
StatementAssertion<Begin: Pos(539, 9), End: Pos(539, 43)>,
StatementAssertion<Begin: Pos(540, 9), End: Pos(540, 43)>,
]
---
    @Test
    public void testSkipToEnd$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        assertEquals(6, b64stream.skip(6));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipToEnd$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(6, b64stream.skip(6));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipToEnd$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(6, b64stream.skip(6));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testCodec130
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(57, 5)
End: Pos(74, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testCodec130
Childs: [StatementAssertion<Begin: Pos(73, 9), End: Pos(73, 55)>,
]
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testSkipWrongArgument
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(548, 5)
End: Pos(553, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testSkipWrongArgument
Childs: []
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testAvailable
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(160, 5)
End: Pos(171, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testAvailable
Childs: [StatementAssertion<Begin: Pos(164, 9), End: Pos(164, 47)>,
StatementAssertion<Begin: Pos(165, 9), End: Pos(165, 44)>,
StatementAssertion<Begin: Pos(167, 9), End: Pos(167, 47)>,
StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 43)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 43)>,
StatementAssertion<Begin: Pos(170, 9), End: Pos(170, 47)>,
]
---
    @Test
    public void testAvailable$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        assertEquals(1, b64stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(1, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(6, b64stream.skip(10));                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(1, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(0, b64stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_3() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(1, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_4() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(1, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testAvailable$catena_5() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(1, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(0, b64stream.available());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, b64stream.available());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testSkipPastEnd
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(516, 5)
End: Pos(525, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testSkipPastEnd
Childs: [StatementAssertion<Begin: Pos(521, 9), End: Pos(521, 44)>,
StatementAssertion<Begin: Pos(523, 9), End: Pos(523, 43)>,
StatementAssertion<Begin: Pos(524, 9), End: Pos(524, 43)>,
]
---
    @Test
    public void testSkipPastEnd$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        assertEquals(6, b64stream.skip(10));                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipPastEnd$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipPastEnd$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded
        try{ assertEquals(6, b64stream.skip(10));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testSkipBig
file: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(484, 5)
End: Pos(492, 5)
Source: /tmp/Codec_12/src/test/java//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testSkipBig
Childs: [StatementAssertion<Begin: Pos(488, 9), End: Pos(488, 46)>,
StatementAssertion<Begin: Pos(490, 9), End: Pos(490, 43)>,
StatementAssertion<Begin: Pos(491, 9), End: Pos(491, 43)>,
]
---
    @Test
    public void testSkipBig$catena_0() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        assertEquals(6, b64stream.skip(1024));                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipBig$catena_1() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(6, b64stream.skip(1024));                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testSkipBig$catena_2() throws Throwable {
        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
        Base64InputStream b64stream = new Base64InputStream(ins);
        try{ assertEquals(6, b64stream.skip(1024));                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        // End of stream reached
        try{ assertEquals(-1, b64stream.read());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1, b64stream.read());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Codec_13
@@@
Split test: org.apache.commons.codec.language.DoubleMetaphoneTest::testIsDoubleMetaphoneEqualBasic
file: /tmp/Codec_13/src/test/java//org/apache/commons/codec/language/DoubleMetaphoneTest.java
Begin: Pos(1122, 5)
End: Pos(1138, 5)
Source: /tmp/Codec_13/src/test/java//org/apache/commons/codec/language/DoubleMetaphoneTest.java
Name: testIsDoubleMetaphoneEqualBasic
Childs: [StatementAssertion<Begin: Pos(1136, 9), End: Pos(1136, 53)>,
StatementAssertion<Begin: Pos(1137, 9), End: Pos(1137, 52)>,
]
---
    @Test
    public void testIsDoubleMetaphoneEqualBasic$catena_0() {
        final String[][] testFixture = new String[][] { { 
                "", "" }, {
                "Case", "case" }, {
                "CASE", "Case" }, {
                "caSe", "cAsE" }, {
                "cookie", "quick" }, {
                "quick", "cookie" }, {
                "Brian", "Bryan" }, {
                "Auto", "Otto" }, {
                "Steven", "Stefan" }, {
                "Philipowitz", "Filipowicz" }
        };
        doubleMetaphoneEqualTest(testFixture, false);                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ doubleMetaphoneEqualTest(testFixture, true);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testIsDoubleMetaphoneEqualBasic$catena_1() {
        final String[][] testFixture = new String[][] { { 
                "", "" }, {
                "Case", "case" }, {
                "CASE", "Case" }, {
                "caSe", "cAsE" }, {
                "cookie", "quick" }, {
                "quick", "cookie" }, {
                "Brian", "Bryan" }, {
                "Auto", "Otto" }, {
                "Steven", "Stefan" }, {
                "Philipowitz", "Filipowicz" }
        };
        try{ doubleMetaphoneEqualTest(testFixture, false);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        doubleMetaphoneEqualTest(testFixture, true);                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.codec.language.DoubleMetaphoneTest::testCodec184
file: /tmp/Codec_13/src/test/java//org/apache/commons/codec/language/DoubleMetaphoneTest.java
Begin: Pos(1063, 5)
End: Pos(1071, 7)
Source: /tmp/Codec_13/src/test/java//org/apache/commons/codec/language/DoubleMetaphoneTest.java
Name: testCodec184
Childs: [StatementAssertion<Begin: Pos(1065, 9), End: Pos(1065, 80)>,
StatementAssertion<Begin: Pos(1066, 9), End: Pos(1066, 79)>,
StatementAssertion<Begin: Pos(1067, 9), End: Pos(1067, 83)>,
StatementAssertion<Begin: Pos(1068, 9), End: Pos(1068, 82)>,
StatementAssertion<Begin: Pos(1069, 9), End: Pos(1069, 83)>,
StatementAssertion<Begin: Pos(1070, 9), End: Pos(1070, 82)>,
]
---
    @Test
    public void testCodec184$catena_0() throws Throwable {
        assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
      }
---
---
    @Test
    public void testCodec184$catena_1() throws Throwable {
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
      }
---
---
    @Test
    public void testCodec184$catena_2() throws Throwable {
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
      }
---
---
    @Test
    public void testCodec184$catena_3() throws Throwable {
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
      }
---
---
    @Test
    public void testCodec184$catena_4() throws Throwable {
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
      }
---
---
    @Test
    public void testCodec184$catena_5() throws Throwable {
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", false));                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("", "", true));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa", "", true));                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", false));                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("", "aa", true));                          /***** ORIGINAL ASSERTION IS HERE *****/
      }
---
--------------------
Run: Codec_1
@@@
Split test: org.apache.commons.codec.language.CaverphoneTest::testLocaleIndependence
file: /tmp/Codec_1/src/test//org/apache/commons/codec/language/CaverphoneTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testLocaleIndependence> in AST

---
@@@
Split test: org.apache.commons.codec.language.DoubleMetaphoneTest::testLocaleIndependence
file: /tmp/Codec_1/src/test//org/apache/commons/codec/language/DoubleMetaphoneTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testLocaleIndependence> in AST

---
@@@
Split test: org.apache.commons.codec.language.MetaphoneTest::testLocaleIndependence
file: /tmp/Codec_1/src/test//org/apache/commons/codec/language/MetaphoneTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testLocaleIndependence> in AST

---
@@@
Split test: org.apache.commons.codec.language.RefinedSoundexTest::testLocaleIndependence
file: /tmp/Codec_1/src/test//org/apache/commons/codec/language/RefinedSoundexTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testLocaleIndependence> in AST

---
@@@
Split test: org.apache.commons.codec.language.SoundexTest::testLocaleIndependence
file: /tmp/Codec_1/src/test//org/apache/commons/codec/language/SoundexTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testLocaleIndependence> in AST

---
--------------------
Run: Codec_14
@@@
Split test: org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion
file: /tmp/Codec_14/src/test/java//org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java
Begin: Pos(180, 5)
End: Pos(198, 5)
Source: /tmp/Codec_14/src/test/java//org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java
Name: testCompatibilityWithOriginalVersion
Childs: [StatementAssertion<Begin: Pos(189, 9), End: Pos(189, 137)>,
StatementAssertion<Begin: Pos(190, 9), End: Pos(190, 84)>,
StatementAssertion<Begin: Pos(195, 9), End: Pos(195, 141)>,
StatementAssertion<Begin: Pos(196, 9), End: Pos(196, 113)>,
]
---
    @Test
    public void testCompatibilityWithOriginalVersion$catena_0() {
        // see CODEC-187
        // comparison: http://stevemorse.org/census/soundex.html

        Map<String, String> args = new TreeMap<String, String>();
        args.put("nameType", "GENERIC");
        args.put("ruleType", "APPROX");

        assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom");             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        args.put("nameType", "ASHKENAZI");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom");    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn");                                }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void testCompatibilityWithOriginalVersion$catena_1() {
        // see CODEC-187
        // comparison: http://stevemorse.org/census/soundex.html

        Map<String, String> args = new TreeMap<String, String>();
        args.put("nameType", "GENERIC");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom");        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        args.put("nameType", "ASHKENAZI");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom");    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn");                                }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void testCompatibilityWithOriginalVersion$catena_2() {
        // see CODEC-187
        // comparison: http://stevemorse.org/census/soundex.html

        Map<String, String> args = new TreeMap<String, String>();
        args.put("nameType", "GENERIC");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom");        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        args.put("nameType", "ASHKENAZI");
        args.put("ruleType", "APPROX");

        assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom");         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn");                                }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void testCompatibilityWithOriginalVersion$catena_3() {
        // see CODEC-187
        // comparison: http://stevemorse.org/census/soundex.html

        Map<String, String> args = new TreeMap<String, String>();
        args.put("nameType", "GENERIC");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom");        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        args.put("nameType", "ASHKENAZI");
        args.put("ruleType", "APPROX");

        try{ assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom");    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn");                                     /***** ORIGINAL ASSERTION IS HERE *****/

    }
---
--------------------
Run: Codec_6
@@@
Split test: org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101
file: /tmp/Codec_6/src/test//org/apache/commons/codec/binary/Base64InputStreamTest.java
Begin: Pos(55, 12)
End: Pos(65, 5)
Source: /tmp/Codec_6/src/test//org/apache/commons/codec/binary/Base64InputStreamTest.java
Name: testCodec101
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 75)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 93)>,
]
---
    public void testCodec101$catena_0() throws Exception {
        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);
        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
        Base64InputStream in = new Base64InputStream(bais);
        byte[] result = new byte[8192];
        int c = in.read(result);
        assertTrue("Codec101: First read successful [c=" + c + "]", c > 0);                                 /***** ORIGINAL ASSERTION IS HERE *****/

        c = in.read(result);
        try{ assertTrue("Codec101: Second read should report end-of-stream [c=" + c + "]", c < 0);          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCodec101$catena_1() throws Exception {
        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);
        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
        Base64InputStream in = new Base64InputStream(bais);
        byte[] result = new byte[8192];
        int c = in.read(result);
        try{ assertTrue("Codec101: First read successful [c=" + c + "]", c > 0);                            }catch(Throwable __SHOULD_BE_IGNORED){}

        c = in.read(result);
        assertTrue("Codec101: Second read should report end-of-stream [c=" + c + "]", c < 0);               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Collections_17
--------------------
Run: Collections_8
--------------------
Run: Collections_22
--------------------
Run: Collections_25
@@@
Split test: org.apache.commons.collections4.IteratorUtilsTest::testCollatedIterator
file: /tmp/Collections_25/src/test/java//org/apache/commons/collections4/IteratorUtilsTest.java
Begin: Pos(923, 5)
End: Pos(969, 5)
Source: /tmp/Collections_25/src/test/java//org/apache/commons/collections4/IteratorUtilsTest.java
Name: testCollatedIterator
Childs: [StatementAssertion<Begin: Pos(927, 13), End: Pos(927, 51)>,
StatementAssertion<Begin: Pos(934, 13), End: Pos(934, 51)>,
StatementAssertion<Begin: Pos(944, 9), End: Pos(944, 40)>,
StatementAssertion<Begin: Pos(951, 9), End: Pos(951, 43)>,
StatementAssertion<Begin: Pos(955, 9), End: Pos(955, 44)>,
StatementAssertion<Begin: Pos(968, 9), End: Pos(968, 43)>,
]
---
    @Test
    public void testCollatedIterator$catena_0() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            fail("expecting NullPointerException");                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        try{ assertEquals(12, result.size());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(collectionOdd, result);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCollatedIterator$catena_1() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            fail("expecting NullPointerException");                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        try{ assertEquals(12, result.size());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(collectionOdd, result);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCollatedIterator$catena_2() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        assertEquals(12, result.size());                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(collectionOdd, result);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCollatedIterator$catena_3() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        try{ assertEquals(12, result.size());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        assertEquals(combinedList, result);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(collectionOdd, result);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCollatedIterator$catena_4() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        try{ assertEquals(12, result.size());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        assertEquals(collectionOdd, result);                                                                /***** ORIGINAL ASSERTION IS HERE *****/

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCollatedIterator$catena_5() {
        try {
            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        try {
            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());
            try{ fail("expecting NullPointerException");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (NullPointerException npe) {
            // expected
        }

        // natural ordering
        Iterator<Integer> it = 
                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());

        List<Integer> result = IteratorUtils.toList(it);
        try{ assertEquals(12, result.size());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        List<Integer> combinedList = new ArrayList<Integer>();
        combinedList.addAll(collectionOdd);
        combinedList.addAll(collectionEven);
        Collections.sort(combinedList);

        try{ assertEquals(combinedList, result);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());
        result = IteratorUtils.toList(it);
        try{ assertEquals(collectionOdd, result);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        final Comparator<Integer> reverseComparator =
                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());

        Collections.reverse((List<Integer>) collectionOdd);
        Collections.reverse((List<Integer>) collectionEven);
        Collections.reverse(combinedList);

        it = IteratorUtils.collatedIterator(reverseComparator,
                                            collectionOdd.iterator(),
                                            collectionEven.iterator());
        result = IteratorUtils.toList(it);
        assertEquals(combinedList, result);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Collections_21
--------------------
Run: Collections_19
--------------------
Run: Collections_18
--------------------
Run: Collections_15
--------------------
Run: Collections_10
--------------------
Run: Collections_2
--------------------
Run: Collections_20
--------------------
Run: Collections_7
--------------------
Run: Collections_5
--------------------
Run: Collections_4
--------------------
Run: Collections_1
--------------------
Run: Collections_24
--------------------
Run: Collections_6
--------------------
Run: Compress_17
@@@
Split test: org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197
file: /tmp/Compress_17/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Begin: Pos(125, 5)
End: Pos(138, 5)
Source: /tmp/Compress_17/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Name: testCompress197
Childs: [StatementAssertion<Begin: Pos(134, 13), End: Pos(134, 52)>,
]
--------------------
Run: Compress_11
@@@
Split test: org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::shortTextFilesAreNoTARs
file: /tmp/Compress_11/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Begin: Pos(31, 5)
End: Pos(40, 5)
Source: /tmp/Compress_11/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Name: shortTextFilesAreNoTARs
Childs: [StatementAssertion<Begin: Pos(36, 13), End: Pos(36, 62)>,
StatementAssertion<Begin: Pos(38, 13), End: Pos(38, 72)>,
]
---
    @Test
    public void shortTextFilesAreNoTARs$catena_0() throws Exception {
        try {
            new ArchiveStreamFactory()
                .createArchiveInputStream(new ByteArrayInputStream("This certainly is not a tar archive, really, no kidding".getBytes()));
            fail("created an input stream for a non-archive");                                              /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (ArchiveException ae) {
            try{ assertTrue(ae.getMessage().startsWith("No Archiver found"));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void shortTextFilesAreNoTARs$catena_1() throws Exception {
        try {
            new ArchiveStreamFactory()
                .createArchiveInputStream(new ByteArrayInputStream("This certainly is not a tar archive, really, no kidding".getBytes()));
            try{ fail("created an input stream for a non-archive");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ArchiveException ae) {
            assertTrue(ae.getMessage().startsWith("No Archiver found"));                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: Compress_8
@@@
Split test: org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctalInvalid
file: /tmp/Compress_8/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Begin: Pos(61, 12)
End: Pos(111, 5)
Source: /tmp/Compress_8/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Name: testParseOctalInvalid
Childs: [StatementAssertion<Begin: Pos(66, 13), End: Pos(66, 88)>,
StatementAssertion<Begin: Pos(72, 13), End: Pos(72, 88)>,
StatementAssertion<Begin: Pos(78, 13), End: Pos(78, 69)>,
StatementAssertion<Begin: Pos(84, 13), End: Pos(84, 69)>,
StatementAssertion<Begin: Pos(90, 13), End: Pos(90, 54)>,
StatementAssertion<Begin: Pos(96, 13), End: Pos(96, 67)>,
StatementAssertion<Begin: Pos(102, 13), End: Pos(102, 71)>,
StatementAssertion<Begin: Pos(108, 13), End: Pos(108, 69)>,
]
---
    public void testParseOctalInvalid$catena_0() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - should be at least 2 bytes long");                    /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_1() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - should be at least 2 bytes long");                    /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_2() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - not all NULs");                                       /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_3() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - not all NULs");                                       /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_4() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_5() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - no trailer");                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_6() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - embedded space");                                     /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded NUL");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
    }
---
---
    public void testParseOctalInvalid$catena_7() throws Exception{
        byte [] buffer;
        buffer=new byte[0]; // empty byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0}; // 1-byte array
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - should be at least 2 bytes long");               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{0,0,' '}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer=new byte[]{' ',0,0,0}; // not all NULs
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - not all NULs");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "abcdef ".getBytes("UTF-8"); // Invalid input
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = "77777777777".getBytes("UTF-8"); // Invalid input - no trailer
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - no trailer");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0 07 ".getBytes("UTF-8"); // Invalid - embedded space
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            try{ fail("Expected IllegalArgumentException - embedded space");                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException expected) {
        }
        buffer = " 0\00007 ".getBytes("UTF-8"); // Invalid - embedded NUL
        try {
            TarUtils.parseOctal(buffer,0, buffer.length);
            fail("Expected IllegalArgumentException - embedded NUL");                                       /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException expected) {
        }
    }
---
--------------------
Run: Compress_22
@@@
Split test: org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test::testPartialReadTruncatedData
file: /tmp/Compress_22/src/test/java//org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java
Begin: Pos(84, 5)
End: Pos(105, 5)
Source: /tmp/Compress_22/src/test/java//org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java
Name: testPartialReadTruncatedData
Childs: [StatementAssertion<Begin: Pos(94, 9), End: Pos(95, 32)>,
StatementAssertion<Begin: Pos(101, 13), End: Pos(101, 56)>,
]
---
    @Test
    public void testPartialReadTruncatedData$catena_0() throws IOException {
        //with BZ2File(self.filename) as f:
        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)
        //    self.assertRaises(EOFError, f.read, 1)

        final int length = TEXT.length();
        ByteBuffer buffer = ByteBuffer.allocate(length);
        bz2Channel.read(buffer);

        assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),
                buffer.array());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        // subsequent read should throw
        buffer = ByteBuffer.allocate(1);
        try {
            bz2Channel.read(buffer);
            try{ Assert.fail("The read should have thrown.");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException e) {
            // pass
        }
    }
---
---
    @Test
    public void testPartialReadTruncatedData$catena_1() throws IOException {
        //with BZ2File(self.filename) as f:
        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)
        //    self.assertRaises(EOFError, f.read, 1)

        final int length = TEXT.length();
        ByteBuffer buffer = ByteBuffer.allocate(length);
        bz2Channel.read(buffer);

        try{ assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),
                buffer.array());                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // subsequent read should throw
        buffer = ByteBuffer.allocate(1);
        try {
            bz2Channel.read(buffer);
            Assert.fail("The read should have thrown.");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException e) {
            // pass
        }
    }
---
--------------------
Run: Compress_33
@@@
Split test: org.apache.commons.compress.compressors.DetectCompressorTestCase::testDetection
file: /tmp/Compress_33/src/test/java//org/apache/commons/compress/compressors/DetectCompressorTestCase.java
Begin: Pos(90, 5)
End: Pos(118, 5)
Source: /tmp/Compress_33/src/test/java//org/apache/commons/compress/compressors/DetectCompressorTestCase.java
Name: testDetection
Childs: [StatementAssertion<Begin: Pos(93, 9), End: Pos(93, 29)>,
StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 64)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 28)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 62)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 31)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 68)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 26)>,
StatementAssertion<Begin: Pos(106, 9), End: Pos(106, 58)>,
StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 28)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 65)>,
StatementAssertion<Begin: Pos(114, 13), End: Pos(114, 66)>,
]
---
    @Test
    public void testDetection$catena_0() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        assertNotNull(bzip2);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_1() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                            /***** ORIGINAL ASSERTION IS HERE *****/

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_2() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        assertNotNull(gzip);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_3() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(gzip instanceof GzipCompressorInputStream);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_4() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        assertNotNull(pack200);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_5() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(pack200 instanceof Pack200CompressorInputStream);                                        /***** ORIGINAL ASSERTION IS HERE *****/

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_6() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        assertNotNull(xz);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_7() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(xz instanceof XZCompressorInputStream);                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_8() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        assertNotNull(zlib);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_9() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(zlib instanceof DeflateCompressorInputStream);                                           /***** ORIGINAL ASSERTION IS HERE *****/

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            try{ fail("No exception thrown for an empty input stream");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (CompressorException e) {
            // expected
        }
    }
---
---
    @Test
    public void testDetection$catena_10() throws Exception {
        CompressorInputStream bzip2 = getStreamFor("bla.txt.bz2"); 
        try{ assertNotNull(bzip2);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(bzip2 instanceof BZip2CompressorInputStream);                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream gzip = getStreamFor("bla.tgz");
        try{ assertNotNull(gzip);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(gzip instanceof GzipCompressorInputStream);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        
        CompressorInputStream pack200 = getStreamFor("bla.pack");
        try{ assertNotNull(pack200);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(pack200 instanceof Pack200CompressorInputStream);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream xz = getStreamFor("bla.tar.xz");
        try{ assertNotNull(xz);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(xz instanceof XZCompressorInputStream);                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        CompressorInputStream zlib = getStreamFor("bla.tar.deflatez");
        try{ assertNotNull(zlib);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(zlib instanceof DeflateCompressorInputStream);                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try {
            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));
            fail("No exception thrown for an empty input stream");                                          /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (CompressorException e) {
            // expected
        }
    }
---
--------------------
Run: Compress_42
@@@
Split test: org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet
file: /tmp/Compress_42/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Begin: Pos(276, 5)
End: Pos(282, 5)
Source: /tmp/Compress_42/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Name: isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet
Childs: [StatementAssertion<Begin: Pos(280, 13), End: Pos(280, 44)>,
]
--------------------
Run: Compress_29
@@@
Split test: org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStream
file: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Begin: Pos(306, 5)
End: Pos(321, 5)
Source: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Name: testEncodingInputStream
Childs: [StatementAssertion<Begin: Pos(319, 13), End: Pos(319, 44)>,
]
@@@
Split test: org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStreamAutodetect
file: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Begin: Pos(289, 5)
End: Pos(304, 5)
Source: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Name: testEncodingInputStreamAutodetect
Childs: [StatementAssertion<Begin: Pos(302, 13), End: Pos(302, 44)>,
]
@@@
Split test: org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingOutputStream
file: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Begin: Pos(323, 5)
End: Pos(340, 5)
Source: /tmp/Compress_29/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Name: testEncodingOutputStream
Childs: [StatementAssertion<Begin: Pos(338, 13), End: Pos(338, 44)>,
]
--------------------
Run: Compress_21
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSevenEmptyFiles
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(182, 12)
End: Pos(184, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testSevenEmptyFiles
Childs: [StatementAssertion<Begin: Pos(183, 9), End: Pos(183, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testEightFilesSomeNotEmpty
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(194, 12)
End: Pos(196, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testEightFilesSomeNotEmpty
Childs: [StatementAssertion<Begin: Pos(195, 9), End: Pos(195, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSixEmptyFiles
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(174, 12)
End: Pos(176, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testSixEmptyFiles
Childs: [StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testEightEmptyFiles
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(190, 12)
End: Pos(192, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testEightEmptyFiles
Childs: [StatementAssertion<Begin: Pos(191, 9), End: Pos(191, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testNineEmptyFiles
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(198, 12)
End: Pos(200, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testNineEmptyFiles
Childs: [StatementAssertion<Begin: Pos(199, 9), End: Pos(199, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSixFilesSomeNotEmpty
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(178, 12)
End: Pos(180, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testSixFilesSomeNotEmpty
Childs: [StatementAssertion<Begin: Pos(179, 9), End: Pos(179, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testNineFilesSomeNotEmpty
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(202, 12)
End: Pos(204, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testNineFilesSomeNotEmpty
Childs: [StatementAssertion<Begin: Pos(203, 9), End: Pos(203, 30)>,
]
@@@
Split test: org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSevenFilesSomeNotEmpty
file: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Begin: Pos(186, 12)
End: Pos(188, 5)
Source: /tmp/Compress_21/src/test/java//org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java
Name: testSevenFilesSomeNotEmpty
Childs: [StatementAssertion<Begin: Pos(187, 9), End: Pos(187, 30)>,
]
--------------------
Run: Compress_9
@@@
Split test: org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount
file: /tmp/Compress_9/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java
Begin: Pos(31, 12)
End: Pos(56, 5)
Source: /tmp/Compress_9/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java
Name: testCount
Childs: [StatementAssertion<Begin: Pos(55, 9), End: Pos(55, 59)>,
]
--------------------
Run: Compress_35
@@@
Split test: org.apache.commons.compress.DetectArchiverTestCase::testCOMPRESS335
file: /tmp/Compress_35/src/test/java//org/apache/commons/compress/DetectArchiverTestCase.java
Begin: Pos(58, 5)
End: Pos(63, 5)
Source: /tmp/Compress_35/src/test/java//org/apache/commons/compress/DetectArchiverTestCase.java
Name: testCOMPRESS335
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 27)>,
StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 57)>,
]
---
    @Test
    public void testCOMPRESS335$catena_0() throws Exception {
        final ArchiveInputStream tar = getStreamFor("COMPRESS-335.tar");
        assertNotNull(tar);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(tar instanceof TarArchiveInputStream);                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCOMPRESS335$catena_1() throws Exception {
        final ArchiveInputStream tar = getStreamFor("COMPRESS-335.tar");
        try{ assertNotNull(tar);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(tar instanceof TarArchiveInputStream);                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_43
@@@
Split test: org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries
file: /tmp/Compress_43/src/test/java//org/apache/commons/compress/archivers/zip/DataDescriptorTest.java
Begin: Pos(134, 5)
End: Pos(183, 5)
Source: /tmp/Compress_43/src/test/java//org/apache/commons/compress/archivers/zip/DataDescriptorTest.java
Name: doesntWriteDataDescriptorWhenAddingRawEntries
Childs: [StatementAssertion<Begin: Pos(159, 9), End: Pos(159, 62)>,
StatementAssertion<Begin: Pos(162, 9), End: Pos(162, 57)>,
StatementAssertion<Begin: Pos(166, 9), End: Pos(166, 62)>,
StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 57)>,
StatementAssertion<Begin: Pos(171, 9), End: Pos(171, 68)>,
StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 37)>,
StatementAssertion<Begin: Pos(178, 9), End: Pos(178, 45)>,
StatementAssertion<Begin: Pos(180, 9), End: Pos(180, 49)>,
StatementAssertion<Begin: Pos(182, 9), End: Pos(182, 47)>,
]
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_0() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_1() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_2() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_3() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_4() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                        /***** ORIGINAL ASSERTION IS HERE *****/
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_5() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        assertEquals(3, sizeFromLFH);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_6() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        assertEquals(crcFromLFH, crcFromCDH);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_7() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        assertEquals(cSizeFromLFH, cSizeFromCDH);                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        try{ assertEquals(sizeFromLFH, sizeFromCDH);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void doesntWriteDataDescriptorWhenAddingRawEntries$catena_8() throws IOException {
        ByteArrayOutputStream init = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {
            zos.putArchiveEntry(new ZipArchiveEntry("test1.txt"));
            zos.write("foo".getBytes("UTF-8"));
            zos.closeArchiveEntry();
        }

        File f = new File(dir, "test.zip");
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(init.toByteArray());
        }

        ByteArrayOutputStream o = new ByteArrayOutputStream();
        ZipArchiveEntry zae;
        try (ZipFile zf = new ZipFile(f);
             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {
            zae = zf.getEntry("test1.txt");
            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));
        }

        byte[] data = o.toByteArray();
        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);
        // still 2.0 because of Deflate
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);
        // no DD but EFS flag
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int cdhStart = findCentralDirectory(data);
        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);
        try{ assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);
        try{ assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        int ddStart = cdhStart - 16;
        try{ assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        long crcFromLFH = ZipLong.getValue(data, 14);
        long cSizeFromLFH = ZipLong.getValue(data, 18);
        long sizeFromLFH = ZipLong.getValue(data, 22);
        try{ assertEquals(3, sizeFromLFH);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);
        try{ assertEquals(crcFromLFH, crcFromCDH);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);
        try{ assertEquals(cSizeFromLFH, cSizeFromCDH);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);
        assertEquals(sizeFromLFH, sizeFromCDH);                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_41
@@@
Split test: org.apache.commons.compress.archivers.ZipTestCase::testListAllFilesWithNestedArchive
file: /tmp/Compress_41/src/test/java//org/apache/commons/compress/archivers/ZipTestCase.java
Begin: Pos(242, 5)
End: Pos(282, 5)
Source: /tmp/Compress_41/src/test/java//org/apache/commons/compress/archivers/ZipTestCase.java
Name: testListAllFilesWithNestedArchive
Childs: [StatementAssertion<Begin: Pos(277, 9), End: Pos(277, 57)>,
StatementAssertion<Begin: Pos(278, 9), End: Pos(278, 50)>,
StatementAssertion<Begin: Pos(279, 9), End: Pos(279, 50)>,
StatementAssertion<Begin: Pos(280, 9), End: Pos(280, 50)>,
StatementAssertion<Begin: Pos(281, 9), End: Pos(281, 51)>,
]
---
    @Test
    public void testListAllFilesWithNestedArchive$catena_0() throws Exception {
        final File input = getFile("OSX_ArchiveWithNestedArchive.zip");

        final List<String> results = new ArrayList<>();
        final List<ZipException> expectedExceptions = new ArrayList<>();

        final InputStream is = new FileInputStream(input);
        ArchiveInputStream in = null;
        try {
            in = new ArchiveStreamFactory().createArchiveInputStream("zip", is);

            ZipArchiveEntry entry = null;
            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
                results.add(entry.getName());

                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream("zip", in);
                try {
                    ZipArchiveEntry nestedEntry = null;
                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {
                        results.add(nestedEntry.getName());
                    }
                } catch (ZipException ex) {
                    // expected since you cannot create a final ArchiveInputStream from test3.xml
                    expectedExceptions.add(ex);
                }
                // nested stream must not be closed here
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
        is.close();

        assertTrue(results.contains("NestedArchiv.zip"));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(results.contains("test1.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test2.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test3.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, expectedExceptions.size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testListAllFilesWithNestedArchive$catena_1() throws Exception {
        final File input = getFile("OSX_ArchiveWithNestedArchive.zip");

        final List<String> results = new ArrayList<>();
        final List<ZipException> expectedExceptions = new ArrayList<>();

        final InputStream is = new FileInputStream(input);
        ArchiveInputStream in = null;
        try {
            in = new ArchiveStreamFactory().createArchiveInputStream("zip", is);

            ZipArchiveEntry entry = null;
            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
                results.add(entry.getName());

                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream("zip", in);
                try {
                    ZipArchiveEntry nestedEntry = null;
                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {
                        results.add(nestedEntry.getName());
                    }
                } catch (ZipException ex) {
                    // expected since you cannot create a final ArchiveInputStream from test3.xml
                    expectedExceptions.add(ex);
                }
                // nested stream must not be closed here
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
        is.close();

        try{ assertTrue(results.contains("NestedArchiv.zip"));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(results.contains("test1.xml"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(results.contains("test2.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test3.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, expectedExceptions.size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testListAllFilesWithNestedArchive$catena_2() throws Exception {
        final File input = getFile("OSX_ArchiveWithNestedArchive.zip");

        final List<String> results = new ArrayList<>();
        final List<ZipException> expectedExceptions = new ArrayList<>();

        final InputStream is = new FileInputStream(input);
        ArchiveInputStream in = null;
        try {
            in = new ArchiveStreamFactory().createArchiveInputStream("zip", is);

            ZipArchiveEntry entry = null;
            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
                results.add(entry.getName());

                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream("zip", in);
                try {
                    ZipArchiveEntry nestedEntry = null;
                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {
                        results.add(nestedEntry.getName());
                    }
                } catch (ZipException ex) {
                    // expected since you cannot create a final ArchiveInputStream from test3.xml
                    expectedExceptions.add(ex);
                }
                // nested stream must not be closed here
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
        is.close();

        try{ assertTrue(results.contains("NestedArchiv.zip"));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test1.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(results.contains("test2.xml"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(results.contains("test3.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, expectedExceptions.size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testListAllFilesWithNestedArchive$catena_3() throws Exception {
        final File input = getFile("OSX_ArchiveWithNestedArchive.zip");

        final List<String> results = new ArrayList<>();
        final List<ZipException> expectedExceptions = new ArrayList<>();

        final InputStream is = new FileInputStream(input);
        ArchiveInputStream in = null;
        try {
            in = new ArchiveStreamFactory().createArchiveInputStream("zip", is);

            ZipArchiveEntry entry = null;
            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
                results.add(entry.getName());

                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream("zip", in);
                try {
                    ZipArchiveEntry nestedEntry = null;
                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {
                        results.add(nestedEntry.getName());
                    }
                } catch (ZipException ex) {
                    // expected since you cannot create a final ArchiveInputStream from test3.xml
                    expectedExceptions.add(ex);
                }
                // nested stream must not be closed here
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
        is.close();

        try{ assertTrue(results.contains("NestedArchiv.zip"));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test1.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test2.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(results.contains("test3.xml"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, expectedExceptions.size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testListAllFilesWithNestedArchive$catena_4() throws Exception {
        final File input = getFile("OSX_ArchiveWithNestedArchive.zip");

        final List<String> results = new ArrayList<>();
        final List<ZipException> expectedExceptions = new ArrayList<>();

        final InputStream is = new FileInputStream(input);
        ArchiveInputStream in = null;
        try {
            in = new ArchiveStreamFactory().createArchiveInputStream("zip", is);

            ZipArchiveEntry entry = null;
            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {
                results.add(entry.getName());

                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream("zip", in);
                try {
                    ZipArchiveEntry nestedEntry = null;
                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {
                        results.add(nestedEntry.getName());
                    }
                } catch (ZipException ex) {
                    // expected since you cannot create a final ArchiveInputStream from test3.xml
                    expectedExceptions.add(ex);
                }
                // nested stream must not be closed here
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
        is.close();

        try{ assertTrue(results.contains("NestedArchiv.zip"));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test1.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test2.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(results.contains("test3.xml"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, expectedExceptions.size());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::testThrowOnInvalidEntry
file: /tmp/Compress_41/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java
Begin: Pos(235, 5)
End: Pos(249, 5)
Source: /tmp/Compress_41/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java
Name: testThrowOnInvalidEntry
Childs: [StatementAssertion<Begin: Pos(243, 13), End: Pos(243, 41)>,
StatementAssertion<Begin: Pos(245, 13), End: Pos(245, 86)>,
]
---
    @Test
    public void testThrowOnInvalidEntry$catena_0() throws Exception {
        final InputStream is = ZipArchiveInputStreamTest.class
                .getResourceAsStream("/invalid-zip.zip");
        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);

        try {
            zip.getNextZipEntry();
            fail("IOException expected");                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (ZipException expected) {
            try{ assertTrue(expected.getMessage().contains("Unexpected record signature"));                 }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            zip.close();
        }
    }
---
---
    @Test
    public void testThrowOnInvalidEntry$catena_1() throws Exception {
        final InputStream is = ZipArchiveInputStreamTest.class
                .getResourceAsStream("/invalid-zip.zip");
        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);

        try {
            zip.getNextZipEntry();
            try{ fail("IOException expected");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ZipException expected) {
            assertTrue(expected.getMessage().contains("Unexpected record signature"));                      /***** ORIGINAL ASSERTION IS HERE *****/
        } finally {
            zip.close();
        }
    }
---
--------------------
Run: Compress_18
@@@
Split test: org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testWriteNonAsciiDirectoryNamePosixMode
file: /tmp/Compress_18/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java
Begin: Pos(412, 12)
End: Pos(428, 5)
Source: /tmp/Compress_18/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java
Name: testWriteNonAsciiDirectoryNamePosixMode
Childs: [StatementAssertion<Begin: Pos(425, 9), End: Pos(425, 37)>,
StatementAssertion<Begin: Pos(426, 9), End: Pos(426, 36)>,
]
---
    public void testWriteNonAsciiDirectoryNamePosixMode$catena_0() throws Exception {
        String n = "f\u00f6\u00f6/";
        TarArchiveEntry t = new TarArchiveEntry(n);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);
        tos.setAddPaxHeadersForNonAsciiNames(true);
        tos.putArchiveEntry(t);
        tos.closeArchiveEntry();
        tos.close();
        byte[] data = bos.toByteArray();
        TarArchiveInputStream tin =
            new TarArchiveInputStream(new ByteArrayInputStream(data));
        TarArchiveEntry e = tin.getNextTarEntry();
        assertEquals(n, e.getName());                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(e.isDirectory());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        tin.close();
    }
---
---
    public void testWriteNonAsciiDirectoryNamePosixMode$catena_1() throws Exception {
        String n = "f\u00f6\u00f6/";
        TarArchiveEntry t = new TarArchiveEntry(n);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);
        tos.setAddPaxHeadersForNonAsciiNames(true);
        tos.putArchiveEntry(t);
        tos.closeArchiveEntry();
        tos.close();
        byte[] data = bos.toByteArray();
        TarArchiveInputStream tin =
            new TarArchiveInputStream(new ByteArrayInputStream(data));
        TarArchiveEntry e = tin.getNextTarEntry();
        try{ assertEquals(n, e.getName());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(e.isDirectory());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        tin.close();
    }
---
--------------------
Run: Compress_15
@@@
Split test: org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment
file: /tmp/Compress_15/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Begin: Pos(243, 12)
End: Pos(253, 5)
Source: /tmp/Compress_15/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Name: testNullCommentEqualsEmptyComment
Childs: [StatementAssertion<Begin: Pos(250, 9), End: Pos(250, 37)>,
StatementAssertion<Begin: Pos(251, 9), End: Pos(251, 43)>,
StatementAssertion<Begin: Pos(252, 9), End: Pos(252, 43)>,
]
---
    public void testNullCommentEqualsEmptyComment$catena_0() {
        ZipArchiveEntry entry1 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry2 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry3 = new ZipArchiveEntry("foo");
        entry1.setComment(null);
        entry2.setComment("");
        entry3.setComment("bar");
        assertEquals(entry1, entry2);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(entry1.equals(entry3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(entry2.equals(entry3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullCommentEqualsEmptyComment$catena_1() {
        ZipArchiveEntry entry1 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry2 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry3 = new ZipArchiveEntry("foo");
        entry1.setComment(null);
        entry2.setComment("");
        entry3.setComment("bar");
        try{ assertEquals(entry1, entry2);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(entry1.equals(entry3));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(entry2.equals(entry3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullCommentEqualsEmptyComment$catena_2() {
        ZipArchiveEntry entry1 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry2 = new ZipArchiveEntry("foo");
        ZipArchiveEntry entry3 = new ZipArchiveEntry("foo");
        entry1.setComment(null);
        entry2.setComment("");
        entry3.setComment("bar");
        try{ assertEquals(entry1, entry2);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(entry1.equals(entry3));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(entry2.equals(entry3));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_16
@@@
Split test: org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::aiffFilesAreNoTARs
file: /tmp/Compress_16/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Begin: Pos(50, 5)
End: Pos(64, 5)
Source: /tmp/Compress_16/src/test/java//org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
Name: aiffFilesAreNoTARs
Childs: [StatementAssertion<Begin: Pos(56, 13), End: Pos(56, 62)>,
StatementAssertion<Begin: Pos(58, 13), End: Pos(58, 72)>,
]
---
    @Test
    public void aiffFilesAreNoTARs$catena_0() throws Exception {
        InputStream is = null;
        try {
            is = new BufferedInputStream(new FileInputStream("src/test/resources/testAIFF.aif"));
            new ArchiveStreamFactory().createArchiveInputStream(is);
            fail("created an input stream for a non-archive");                                              /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (ArchiveException ae) {
            try{ assertTrue(ae.getMessage().startsWith("No Archiver found"));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            if (is != null) {
                is.close();
            }
        }
    }
---
---
    @Test
    public void aiffFilesAreNoTARs$catena_1() throws Exception {
        InputStream is = null;
        try {
            is = new BufferedInputStream(new FileInputStream("src/test/resources/testAIFF.aif"));
            new ArchiveStreamFactory().createArchiveInputStream(is);
            try{ fail("created an input stream for a non-archive");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ArchiveException ae) {
            assertTrue(ae.getMessage().startsWith("No Archiver found"));                                    /***** ORIGINAL ASSERTION IS HERE *****/
        } finally {
            if (is != null) {
                is.close();
            }
        }
    }
---
--------------------
Run: Compress_45
@@@
Split test: org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripOctalOrBinary8
file: /tmp/Compress_45/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Begin: Pos(146, 5)
End: Pos(149, 5)
Source: /tmp/Compress_45/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Name: testRoundTripOctalOrBinary8
Childs: [StatementAssertion<Begin: Pos(148, 9), End: Pos(148, 38)>,
]
--------------------
Run: Compress_10
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive
file: /tmp/Compress_10/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(126, 12)
End: Pos(138, 5)
Source: /tmp/Compress_10/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testReadWinZipArchive
Childs: [StatementAssertion<Begin: Pos(132, 13), End: Pos(132, 41)>,
StatementAssertion<Begin: Pos(133, 13), End: Pos(133, 51)>,
StatementAssertion<Begin: Pos(134, 13), End: Pos(134, 46)>,
]
---
    public void testReadWinZipArchive$catena_0() throws IOException, URISyntaxException {
        URL zip = getClass().getResource("/utf8-winzip-test.zip");
        File archive = new File(new URI(zip.toString()));
        ZipFile zf = null;
        try {
            zf = new ZipFile(archive, null, true);
            assertCanRead(zf, ASCII_TXT);                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertCanRead(zf, EURO_FOR_DOLLAR_TXT);                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertCanRead(zf, OIL_BARREL_TXT);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            ZipFile.closeQuietly(zf);
        }
    }
---
---
    public void testReadWinZipArchive$catena_1() throws IOException, URISyntaxException {
        URL zip = getClass().getResource("/utf8-winzip-test.zip");
        File archive = new File(new URI(zip.toString()));
        ZipFile zf = null;
        try {
            zf = new ZipFile(archive, null, true);
            try{ assertCanRead(zf, ASCII_TXT);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);                                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertCanRead(zf, OIL_BARREL_TXT);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            ZipFile.closeQuietly(zf);
        }
    }
---
---
    public void testReadWinZipArchive$catena_2() throws IOException, URISyntaxException {
        URL zip = getClass().getResource("/utf8-winzip-test.zip");
        File archive = new File(new URI(zip.toString()));
        ZipFile zf = null;
        try {
            zf = new ZipFile(archive, null, true);
            try{ assertCanRead(zf, ASCII_TXT);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertCanRead(zf, EURO_FOR_DOLLAR_TXT);                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertCanRead(zf, OIL_BARREL_TXT);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        } finally {
            ZipFile.closeQuietly(zf);
        }
    }
---
--------------------
Run: Compress_2
@@@
Split test: org.apache.commons.compress.archivers.ArTestCase::testArDelete
file: /tmp/Compress_2/src/test/java//org/apache/commons/compress/archivers/ArTestCase.java
Begin: Pos(89, 12)
End: Pos(178, 5)
Source: /tmp/Compress_2/src/test/java//org/apache/commons/compress/archivers/ArTestCase.java
Name: testArDelete
Childs: [StatementAssertion<Begin: Pos(110, 9), End: Pos(113, 38)>,
StatementAssertion<Begin: Pos(150, 9), End: Pos(150, 32)>,
StatementAssertion<Begin: Pos(151, 9), End: Pos(151, 33)>,
StatementAssertion<Begin: Pos(152, 9), End: Pos(152, 44)>,
StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 31)>,
StatementAssertion<Begin: Pos(176, 9), End: Pos(176, 30)>,
]
---
    public void testArDelete$catena_0() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        try{ assertEquals(1, copied);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, deleted);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(144, output2.length());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        try{ assertEquals(1, files);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(76, sum);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    public void testArDelete$catena_1() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        try{ assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        assertEquals(1, copied);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, deleted);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(144, output2.length());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        try{ assertEquals(1, files);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(76, sum);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    public void testArDelete$catena_2() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        try{ assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        try{ assertEquals(1, copied);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, deleted);                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(144, output2.length());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        try{ assertEquals(1, files);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(76, sum);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    public void testArDelete$catena_3() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        try{ assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        try{ assertEquals(1, copied);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, deleted);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(144, output2.length());                                                                /***** ORIGINAL ASSERTION IS HERE *****/

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        try{ assertEquals(1, files);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(76, sum);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    public void testArDelete$catena_4() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        try{ assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        try{ assertEquals(1, copied);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, deleted);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(144, output2.length());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        assertEquals(1, files);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(76, sum);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    public void testArDelete$catena_5() throws Exception {
        final File output = new File(dir, "bla.ar");

        final File file1 = getFile("test1.xml");
        final File file2 = getFile("test2.xml");
        {
            // create

            final OutputStream out = new FileOutputStream(output);
            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream("ar", out);
            os.putArchiveEntry(new ArArchiveEntry("test1.xml", file1.length()));
            IOUtils.copy(new FileInputStream(file1), os);
            os.closeArchiveEntry();

            os.putArchiveEntry(new ArArchiveEntry("test2.xml", file2.length()));
            IOUtils.copy(new FileInputStream(file2), os);
            os.closeArchiveEntry();
            os.close();
            out.close();
        }

        try{ assertEquals(8
                     + 60 + file1.length() + (file1.length() % 2)
                     + 60 + file2.length() + (file2.length() % 2),
                     output.length());                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        final File output2 = new File(dir, "bla2.ar");

        int copied = 0;
        int deleted = 0;

        {
            // remove all but one file

            final InputStream is = new FileInputStream(output);
            final OutputStream os = new FileOutputStream(output2);
            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream("ar", os);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                if ("test1.xml".equals(entry.getName())) {
                    aos.putArchiveEntry(entry);
                    IOUtils.copy(ais, aos);
                    aos.closeArchiveEntry();
                    copied++;
                } else {
                    IOUtils.copy(ais, new ByteArrayOutputStream());
                    deleted++;
                }

            }
            ais.close();
            aos.close();
            is.close();
            os.close();
        }

        try{ assertEquals(1, copied);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, deleted);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(144, output2.length());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        long files = 0;
        long sum = 0;

        {
            final InputStream is = new FileInputStream(output2);
            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));
            while(true) {
                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();
                if (entry == null) {
                    break;
                }

                IOUtils.copy(ais, new ByteArrayOutputStream());

                sum +=  entry.getLength();
                files++;
            }
            ais.close();
            is.close();
        }

        try{ assertEquals(1, files);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(76, sum);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/

    }
---
--------------------
Run: Compress_40
@@@
Split test: org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow
file: /tmp/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java
Begin: Pos(124, 5)
End: Pos(146, 5)
Source: /tmp/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java
Name: littleEndianWithOverflow
Childs: [StatementAssertion<Begin: Pos(139, 9), End: Pos(140, 38)>,
StatementAssertion<Begin: Pos(141, 9), End: Pos(142, 39)>,
StatementAssertion<Begin: Pos(143, 9), End: Pos(144, 39)>,
StatementAssertion<Begin: Pos(145, 9), End: Pos(145, 43)>,
]
---
    @Test
    public void littleEndianWithOverflow$catena_0() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);
        assertEquals(23, // 10111
                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1186, // 01001010-0010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void littleEndianWithOverflow$catena_1() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);
        try{ assertEquals(23, // 10111
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010
                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1186, // 01001010-0010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void littleEndianWithOverflow$catena_2() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);
        try{ assertEquals(23, // 10111
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1186, // 01001010-0010
                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void littleEndianWithOverflow$catena_3() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);
        try{ assertEquals(23, // 10111
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1186, // 01001010-0010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.compress.utils.BitInputStreamTest::bigEndianWithOverflow
file: /tmp/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java
Begin: Pos(148, 5)
End: Pos(170, 5)
Source: /tmp/Compress_40/src/test/java//org/apache/commons/compress/utils/BitInputStreamTest.java
Name: bigEndianWithOverflow
Childs: [StatementAssertion<Begin: Pos(163, 9), End: Pos(164, 38)>,
StatementAssertion<Begin: Pos(165, 9), End: Pos(166, 39)>,
StatementAssertion<Begin: Pos(167, 9), End: Pos(168, 39)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 43)>,
]
---
    @Test
    public void bigEndianWithOverflow$catena_0() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);
        assertEquals(10, // 01010
                     bin.readBits(5));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(330, // 0001-01001010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void bigEndianWithOverflow$catena_1() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);
        try{ assertEquals(10, // 01010
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010
                     bin.readBits(63));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(330, // 0001-01001010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void bigEndianWithOverflow$catena_2() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);
        try{ assertEquals(10, // 01010
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(330, // 0001-01001010
                     bin.readBits(12));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1 , bin.readBits(1));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void bigEndianWithOverflow$catena_3() throws Exception {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {
                87, // 01010111
                45, // 00101101
                66, // 01000010
                15, // 00001111
                90, // 01011010
                29, // 00011101
                88, // 01011000
                61, // 00111101
                33, // 00100001
                74  // 01001010
            });
        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);
        try{ assertEquals(10, // 01010
                     bin.readBits(5));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010
                     bin.readBits(63));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(330, // 0001-01001010
                     bin.readBits(12));                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1 , bin.readBits(1));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_20
@@@
Split test: org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest::testCpioUnarchiveCreatedByRedlineRpm
file: /tmp/Compress_20/src/test/java//org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java
Begin: Pos(49, 12)
End: Pos(61, 5)
Source: /tmp/Compress_20/src/test/java//org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java
Name: testCpioUnarchiveCreatedByRedlineRpm
Childs: [StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 31)>,
]
--------------------
Run: Compress_28
@@@
Split test: org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldThrowAnExceptionOnTruncatedEntries
file: /tmp/Compress_28/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Begin: Pos(212, 5)
End: Pos(234, 5)
Source: /tmp/Compress_28/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Name: shouldThrowAnExceptionOnTruncatedEntries
Childs: []
--------------------
Run: Compress_34
@@@
Split test: org.apache.commons.compress.archivers.zip.X7875_NewUnixTest::testParseReparse
file: /tmp/Compress_34/src/test/java//org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java
Begin: Pos(138, 5)
End: Pos(193, 5)
Source: /tmp/Compress_34/src/test/java//org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java
Name: testParseReparse
Childs: [StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 43)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 47)>,
StatementAssertion<Begin: Pos(170, 9), End: Pos(170, 46)>,
StatementAssertion<Begin: Pos(171, 9), End: Pos(171, 67)>,
StatementAssertion<Begin: Pos(172, 9), End: Pos(172, 59)>,
StatementAssertion<Begin: Pos(173, 9), End: Pos(173, 57)>,
StatementAssertion<Begin: Pos(174, 9), End: Pos(174, 83)>,
StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 103)>,
StatementAssertion<Begin: Pos(182, 9), End: Pos(182, 39)>,
StatementAssertion<Begin: Pos(183, 9), End: Pos(183, 39)>,
StatementAssertion<Begin: Pos(184, 9), End: Pos(184, 73)>,
StatementAssertion<Begin: Pos(190, 9), End: Pos(190, 41)>,
StatementAssertion<Begin: Pos(191, 9), End: Pos(191, 39)>,
StatementAssertion<Begin: Pos(192, 9), End: Pos(192, 73)>,
]
---
    @Test
    public void testParseReparse$catena_0() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_1() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_2() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_3() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_4() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_5() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_6() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_7() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);         /***** ORIGINAL ASSERTION IS HERE *****/

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_8() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        assertEquals(255, xf.getUID());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_9() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(128, xf.getGID());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_10() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                       /***** ORIGINAL ASSERTION IS HERE *****/

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_11() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        assertEquals(65535, xf.getUID());                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_12() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(513, xf.getGID());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseReparse$catena_13() throws ZipException {

        // Version=1, Len=0, Len=0.
        final byte[] ZERO_LEN = {1, 0, 0};

        // Version=1, Len=1, zero, Len=1, zero.
        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};

        // Version=1, Len=1, one, Len=1, one
        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};

        // Version=1, Len=2, one thousand, Len=2, one thousand
        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};

        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in
        // two's complement, and -1 often has a special meaning.
        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};

        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1
        // Esoteric test:  can we handle 40 bit numbers?
        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};

        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1
        // Esoteric test:  can we handle 64 bit numbers?
        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};

        final long TWO_TO_32 = 0x100000000L;
        final long MAX = TWO_TO_32 - 2;

        try{ parseReparse(0, 0, ZERO_LEN, 0, 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(0, 0, ZERO_UID_GID, 0, 0);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1, 1, ONE_UID_GID, 1, 1);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);    }catch(Throwable __SHOULD_BE_IGNORED){}

        // We never emit this, but we should be able to parse it:
        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};
        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);

        try{ assertEquals(255, xf.getUID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(128, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};
        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};
        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);

        try{ assertEquals(65535, xf.getUID());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(513, xf.getGID());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_7
@@@
Split test: org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames
file: /tmp/Compress_7/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Begin: Pos(120, 12)
End: Pos(127, 5)
Source: /tmp/Compress_7/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Name: testRoundTripNames
Childs: [StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 22)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 43)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 26)>,
StatementAssertion<Begin: Pos(126, 9), End: Pos(126, 93)>,
]
---
    public void testRoundTripNames$catena_0(){
        checkName("");                                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ checkName("The quick brown fox\n");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ checkName("\177");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // checkName("\0"); // does not work, because NUL is ignored
        // COMPRESS-114
        try{ checkName("0302-0601-3F06W220ZBLALALACANDC04060302MOE.model");          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testRoundTripNames$catena_1(){
        try{ checkName("");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        checkName("The quick brown fox\n");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ checkName("\177");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // checkName("\0"); // does not work, because NUL is ignored
        // COMPRESS-114
        try{ checkName("0302-0601-3F06W220ZBLALALACANDC04060302MOE.model");          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testRoundTripNames$catena_2(){
        try{ checkName("");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ checkName("The quick brown fox\n");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        checkName("\177");                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        // checkName("\0"); // does not work, because NUL is ignored
        // COMPRESS-114
        try{ checkName("0302-0601-3F06W220ZBLALALACANDC04060302MOE.model");          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testRoundTripNames$catena_3(){
        try{ checkName("");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ checkName("The quick brown fox\n");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ checkName("\177");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // checkName("\0"); // does not work, because NUL is ignored
        // COMPRESS-114
        checkName("0302-0601-3F06W220ZBLALALACANDC04060302MOE.model");               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_3
@@@
Split test: org.apache.commons.compress.archivers.ArchiveOutputStreamTest::testFinish
file: /tmp/Compress_3/src/test/java//org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java
Begin: Pos(24, 12)
End: Pos(71, 5)
Source: /tmp/Compress_3/src/test/java//org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java
Name: testFinish
Childs: [StatementAssertion<Begin: Pos(31, 13), End: Pos(31, 64)>,
StatementAssertion<Begin: Pos(40, 13), End: Pos(40, 64)>,
StatementAssertion<Begin: Pos(49, 13), End: Pos(49, 64)>,
StatementAssertion<Begin: Pos(58, 13), End: Pos(58, 64)>,
StatementAssertion<Begin: Pos(67, 13), End: Pos(67, 64)>,
]
---
    public void testFinish$catena_0() throws Exception {
        OutputStream out1 = new ByteArrayOutputStream();
        
        ArchiveOutputStream aos1 = factory.createArchiveOutputStream("zip", out1);
        aos1.putArchiveEntry(new ZipArchiveEntry("dummy"));
        try {
            aos1.finish();
            fail("After putArchive should follow closeArchive");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("jar", out1);
        aos1.putArchiveEntry(new JarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("ar", out1);
        aos1.putArchiveEntry(new ArArchiveEntry("dummy", 100));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("cpio", out1);
        aos1.putArchiveEntry(new CpioArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("tar", out1);
        aos1.putArchiveEntry(new TarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
    }
---
---
    public void testFinish$catena_1() throws Exception {
        OutputStream out1 = new ByteArrayOutputStream();
        
        ArchiveOutputStream aos1 = factory.createArchiveOutputStream("zip", out1);
        aos1.putArchiveEntry(new ZipArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("jar", out1);
        aos1.putArchiveEntry(new JarArchiveEntry("dummy"));
        try {
            aos1.finish();
            fail("After putArchive should follow closeArchive");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("ar", out1);
        aos1.putArchiveEntry(new ArArchiveEntry("dummy", 100));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("cpio", out1);
        aos1.putArchiveEntry(new CpioArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("tar", out1);
        aos1.putArchiveEntry(new TarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
    }
---
---
    public void testFinish$catena_2() throws Exception {
        OutputStream out1 = new ByteArrayOutputStream();
        
        ArchiveOutputStream aos1 = factory.createArchiveOutputStream("zip", out1);
        aos1.putArchiveEntry(new ZipArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("jar", out1);
        aos1.putArchiveEntry(new JarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("ar", out1);
        aos1.putArchiveEntry(new ArArchiveEntry("dummy", 100));
        try {
            aos1.finish();
            fail("After putArchive should follow closeArchive");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("cpio", out1);
        aos1.putArchiveEntry(new CpioArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("tar", out1);
        aos1.putArchiveEntry(new TarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
    }
---
---
    public void testFinish$catena_3() throws Exception {
        OutputStream out1 = new ByteArrayOutputStream();
        
        ArchiveOutputStream aos1 = factory.createArchiveOutputStream("zip", out1);
        aos1.putArchiveEntry(new ZipArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("jar", out1);
        aos1.putArchiveEntry(new JarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("ar", out1);
        aos1.putArchiveEntry(new ArArchiveEntry("dummy", 100));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("cpio", out1);
        aos1.putArchiveEntry(new CpioArchiveEntry("dummy"));
        try {
            aos1.finish();
            fail("After putArchive should follow closeArchive");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("tar", out1);
        aos1.putArchiveEntry(new TarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
    }
---
---
    public void testFinish$catena_4() throws Exception {
        OutputStream out1 = new ByteArrayOutputStream();
        
        ArchiveOutputStream aos1 = factory.createArchiveOutputStream("zip", out1);
        aos1.putArchiveEntry(new ZipArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("jar", out1);
        aos1.putArchiveEntry(new JarArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("ar", out1);
        aos1.putArchiveEntry(new ArArchiveEntry("dummy", 100));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("cpio", out1);
        aos1.putArchiveEntry(new CpioArchiveEntry("dummy"));
        try {
            aos1.finish();
            try{ fail("After putArchive should follow closeArchive");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException io) {
            // Exception expected
        }
        
        aos1 = factory.createArchiveOutputStream("tar", out1);
        aos1.putArchiveEntry(new TarArchiveEntry("dummy"));
        try {
            aos1.finish();
            fail("After putArchive should follow closeArchive");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException io) {
            // Exception expected
        }
    }
---
--------------------
Run: Compress_4
@@@
Split test: org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java
Begin: Pos(33, 12)
End: Pos(70, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java
Name: testJarMarker
Childs: [StatementAssertion<Begin: Pos(50, 13), End: Pos(50, 30)>,
StatementAssertion<Begin: Pos(52, 13), End: Pos(52, 40)>,
StatementAssertion<Begin: Pos(53, 13), End: Pos(53, 52)>,
StatementAssertion<Begin: Pos(56, 13), End: Pos(56, 30)>,
StatementAssertion<Begin: Pos(58, 13), End: Pos(58, 40)>,
]
---
    public void testJarMarker$catena_0() throws IOException {
        File testArchive = File.createTempFile("jar-aostest", ".jar");
        JarArchiveOutputStream out = null;
        ZipFile zf = null;
        try {

            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));
            out.putArchiveEntry(new ZipArchiveEntry("foo/"));
            out.closeArchiveEntry();
            out.putArchiveEntry(new ZipArchiveEntry("bar/"));
            out.closeArchiveEntry();
            out.finish();
            out.close();
            out = null;

            zf = new ZipFile(testArchive);
            ZipArchiveEntry ze = zf.getEntry("foo/");
            assertNotNull(ze);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
            ZipExtraField[] fes = ze.getExtraFields();
            try{ assertEquals(1, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertTrue(fes[0] instanceof JarMarker);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

            ze = zf.getEntry("bar/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            fes = ze.getExtraFields();
            try{ assertEquals(0, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) { /* swallow */ }
            }
            ZipFile.closeQuietly(zf);
            if (testArchive.exists()) {
                testArchive.delete();
            }
        }
    }
---
---
    public void testJarMarker$catena_1() throws IOException {
        File testArchive = File.createTempFile("jar-aostest", ".jar");
        JarArchiveOutputStream out = null;
        ZipFile zf = null;
        try {

            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));
            out.putArchiveEntry(new ZipArchiveEntry("foo/"));
            out.closeArchiveEntry();
            out.putArchiveEntry(new ZipArchiveEntry("bar/"));
            out.closeArchiveEntry();
            out.finish();
            out.close();
            out = null;

            zf = new ZipFile(testArchive);
            ZipArchiveEntry ze = zf.getEntry("foo/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            ZipExtraField[] fes = ze.getExtraFields();
            assertEquals(1, fes.length);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertTrue(fes[0] instanceof JarMarker);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

            ze = zf.getEntry("bar/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            fes = ze.getExtraFields();
            try{ assertEquals(0, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) { /* swallow */ }
            }
            ZipFile.closeQuietly(zf);
            if (testArchive.exists()) {
                testArchive.delete();
            }
        }
    }
---
---
    public void testJarMarker$catena_2() throws IOException {
        File testArchive = File.createTempFile("jar-aostest", ".jar");
        JarArchiveOutputStream out = null;
        ZipFile zf = null;
        try {

            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));
            out.putArchiveEntry(new ZipArchiveEntry("foo/"));
            out.closeArchiveEntry();
            out.putArchiveEntry(new ZipArchiveEntry("bar/"));
            out.closeArchiveEntry();
            out.finish();
            out.close();
            out = null;

            zf = new ZipFile(testArchive);
            ZipArchiveEntry ze = zf.getEntry("foo/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            ZipExtraField[] fes = ze.getExtraFields();
            try{ assertEquals(1, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            assertTrue(fes[0] instanceof JarMarker);                                                        /***** ORIGINAL ASSERTION IS HERE *****/

            ze = zf.getEntry("bar/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            fes = ze.getExtraFields();
            try{ assertEquals(0, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) { /* swallow */ }
            }
            ZipFile.closeQuietly(zf);
            if (testArchive.exists()) {
                testArchive.delete();
            }
        }
    }
---
---
    public void testJarMarker$catena_3() throws IOException {
        File testArchive = File.createTempFile("jar-aostest", ".jar");
        JarArchiveOutputStream out = null;
        ZipFile zf = null;
        try {

            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));
            out.putArchiveEntry(new ZipArchiveEntry("foo/"));
            out.closeArchiveEntry();
            out.putArchiveEntry(new ZipArchiveEntry("bar/"));
            out.closeArchiveEntry();
            out.finish();
            out.close();
            out = null;

            zf = new ZipFile(testArchive);
            ZipArchiveEntry ze = zf.getEntry("foo/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            ZipExtraField[] fes = ze.getExtraFields();
            try{ assertEquals(1, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertTrue(fes[0] instanceof JarMarker);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

            ze = zf.getEntry("bar/");
            assertNotNull(ze);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
            fes = ze.getExtraFields();
            try{ assertEquals(0, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) { /* swallow */ }
            }
            ZipFile.closeQuietly(zf);
            if (testArchive.exists()) {
                testArchive.delete();
            }
        }
    }
---
---
    public void testJarMarker$catena_4() throws IOException {
        File testArchive = File.createTempFile("jar-aostest", ".jar");
        JarArchiveOutputStream out = null;
        ZipFile zf = null;
        try {

            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));
            out.putArchiveEntry(new ZipArchiveEntry("foo/"));
            out.closeArchiveEntry();
            out.putArchiveEntry(new ZipArchiveEntry("bar/"));
            out.closeArchiveEntry();
            out.finish();
            out.close();
            out = null;

            zf = new ZipFile(testArchive);
            ZipArchiveEntry ze = zf.getEntry("foo/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            ZipExtraField[] fes = ze.getExtraFields();
            try{ assertEquals(1, fes.length);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertTrue(fes[0] instanceof JarMarker);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

            ze = zf.getEntry("bar/");
            try{ assertNotNull(ze);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            fes = ze.getExtraFields();
            assertEquals(0, fes.length);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) { /* swallow */ }
            }
            ZipFile.closeQuietly(zf);
            if (testArchive.exists()) {
                testArchive.delete();
            }
        }
    }
---
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripImplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(73, 12)
End: Pos(76, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testCP437FileRoundtripImplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(75, 9), End: Pos(75, 47)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripImplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(63, 12)
End: Pos(66, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testUtf8FileRoundtripImplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 46)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripExplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(53, 12)
End: Pos(56, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testCP437FileRoundtripExplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(55, 9), End: Pos(55, 46)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripExplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(43, 12)
End: Pos(46, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testUtf8FileRoundtripExplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(45, 9), End: Pos(45, 45)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripImplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(78, 12)
End: Pos(81, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testASCIIFileRoundtripImplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(80, 9), End: Pos(80, 50)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSImplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(68, 12)
End: Pos(71, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testUtf8FileRoundtripNoEFSImplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 47)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
# check: Use pattern matching: .createTestFile
Begin: Pos(177, 12)
End: Pos(193, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testZipArchiveInputStreamReadsUnicodeFields
Childs: [StatementAssertion<Begin: Pos(182, 13), End: Pos(182, 56)>,
StatementAssertion<Begin: Pos(184, 13), End: Pos(184, 50)>,
StatementAssertion<Begin: Pos(185, 13), End: Pos(185, 60)>,
StatementAssertion<Begin: Pos(186, 13), End: Pos(186, 55)>,
]
---
    public void testZipArchiveInputStreamReadsUnicodeFields$catena_0()
        throws IOException {
        File file = File.createTempFile("unicode-test", ".zip");
        ZipFile zf = null;
        try {
            createTestFile(file, US_ASCII, false, true);                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            zf = new ZipFile(file, US_ASCII, true);
            try{ assertNotNull(zf.getEntry(ASCII_TXT));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNotNull(zf.getEntry(OIL_BARREL_TXT));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            ZipFile.closeQuietly(zf);
            if (file.exists()) {
                file.delete();
            }
        }
    }
---
---
    public void testZipArchiveInputStreamReadsUnicodeFields$catena_1()
        throws IOException {
        File file = File.createTempFile("unicode-test", ".zip");
        ZipFile zf = null;
        try {
            try{ createTestFile(file, US_ASCII, false, true);                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            zf = new ZipFile(file, US_ASCII, true);
            assertNotNull(zf.getEntry(ASCII_TXT));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNotNull(zf.getEntry(OIL_BARREL_TXT));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            ZipFile.closeQuietly(zf);
            if (file.exists()) {
                file.delete();
            }
        }
    }
---
---
    public void testZipArchiveInputStreamReadsUnicodeFields$catena_2()
        throws IOException {
        File file = File.createTempFile("unicode-test", ".zip");
        ZipFile zf = null;
        try {
            try{ createTestFile(file, US_ASCII, false, true);                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            zf = new ZipFile(file, US_ASCII, true);
            try{ assertNotNull(zf.getEntry(ASCII_TXT));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));                                                /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertNotNull(zf.getEntry(OIL_BARREL_TXT));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        } finally {
            ZipFile.closeQuietly(zf);
            if (file.exists()) {
                file.delete();
            }
        }
    }
---
---
    public void testZipArchiveInputStreamReadsUnicodeFields$catena_3()
        throws IOException {
        File file = File.createTempFile("unicode-test", ".zip");
        ZipFile zf = null;
        try {
            try{ createTestFile(file, US_ASCII, false, true);                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            zf = new ZipFile(file, US_ASCII, true);
            try{ assertNotNull(zf.getEntry(ASCII_TXT));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            assertNotNull(zf.getEntry(OIL_BARREL_TXT));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        } finally {
            ZipFile.closeQuietly(zf);
            if (file.exists()) {
                file.delete();
            }
        }
    }
---
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripExplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(58, 12)
End: Pos(61, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testASCIIFileRoundtripExplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 49)>,
]
@@@
Split test: org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSExplicitUnicodeExtra
file: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Begin: Pos(48, 12)
End: Pos(51, 5)
Source: /tmp/Compress_4/src/test/java//org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
Name: testUtf8FileRoundtripNoEFSExplicitUnicodeExtra
Childs: [StatementAssertion<Begin: Pos(50, 9), End: Pos(50, 46)>,
]
--------------------
Run: Compress_44
@@@
Split test: org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne
file: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Begin: Pos(110, 5)
End: Pos(116, 5)
Source: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Name: testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne
Childs: []
@@@
Split test: org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo
file: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Begin: Pos(119, 5)
End: Pos(125, 5)
Source: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Name: testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo
Childs: []
@@@
Split test: org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree
file: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Begin: Pos(128, 5)
End: Pos(133, 5)
Source: /tmp/Compress_44/src/test/java//org/apache/commons/compress/utils/ChecksumCalculatingInputStreamTest.java
Name: testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree
Childs: []
--------------------
Run: Compress_47
@@@
Split test: org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown
file: /tmp/Compress_47/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java
Begin: Pos(329, 5)
End: Pos(341, 5)
Source: /tmp/Compress_47/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java
Name: properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown
Childs: [StatementAssertion<Begin: Pos(335, 13), End: Pos(335, 48)>,
StatementAssertion<Begin: Pos(337, 13), End: Pos(337, 48)>,
StatementAssertion<Begin: Pos(339, 13), End: Pos(339, 49)>,
]
---
    @Test
    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown$catena_0() throws Exception {
        // we never read any data
        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {
            ZipArchiveEntry e = new ZipArchiveEntry("test");
            e.setMethod(ZipMethod.DEFLATED.getCode());
            assertTrue(zis.canReadEntryData(e));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());
            try{ assertTrue(zis.canReadEntryData(e));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            e.setMethod(ZipMethod.BZIP2.getCode());
            try{ assertFalse(zis.canReadEntryData(e));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown$catena_1() throws Exception {
        // we never read any data
        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {
            ZipArchiveEntry e = new ZipArchiveEntry("test");
            e.setMethod(ZipMethod.DEFLATED.getCode());
            try{ assertTrue(zis.canReadEntryData(e));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());
            assertTrue(zis.canReadEntryData(e));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
            e.setMethod(ZipMethod.BZIP2.getCode());
            try{ assertFalse(zis.canReadEntryData(e));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown$catena_2() throws Exception {
        // we never read any data
        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {
            ZipArchiveEntry e = new ZipArchiveEntry("test");
            e.setMethod(ZipMethod.DEFLATED.getCode());
            try{ assertTrue(zis.canReadEntryData(e));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());
            try{ assertTrue(zis.canReadEntryData(e));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            e.setMethod(ZipMethod.BZIP2.getCode());
            assertFalse(zis.canReadEntryData(e));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: Compress_32
@@@
Split test: org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldReadBigGid
file: /tmp/Compress_32/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Begin: Pos(238, 5)
End: Pos(257, 5)
Source: /tmp/Compress_32/src/test/java//org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java
Name: shouldReadBigGid
Childs: [StatementAssertion<Begin: Pos(255, 9), End: Pos(255, 54)>,
]
--------------------
Run: Compress_39
@@@
Split test: org.apache.commons.compress.ArchiveUtilsTest::sanitizeShortensString
file: /tmp/Compress_39/src/test/java//org/apache/commons/compress/ArchiveUtilsTest.java
Begin: Pos(70, 5)
End: Pos(83, 5)
Source: /tmp/Compress_39/src/test/java//org/apache/commons/compress/ArchiveUtilsTest.java
Name: sanitizeShortensString
Childs: [StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 61)>,
]
--------------------
Run: Compress_24
@@@
Split test: org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal
file: /tmp/Compress_24/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Begin: Pos(46, 12)
End: Pos(67, 5)
Source: /tmp/Compress_24/src/test/java//org/apache/commons/compress/archivers/tar/TarUtilsTest.java
Name: testParseOctal
Childs: [StatementAssertion<Begin: Pos(54, 9), End: Pos(54, 48)>,
StatementAssertion<Begin: Pos(57, 9), End: Pos(57, 39)>,
StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 39)>,
StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 31)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 31)>,
]
---
    public void testParseOctal$catena_0() throws Exception{
        long value; 
        byte [] buffer;
        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits
        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations
        final String maxOctal = "777777777777"; // Maximum valid octal
        buffer = maxOctal.getBytes(CharsetNames.UTF_8);
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        assertEquals(MAX_OCTAL_OVERFLOW, value);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        buffer[buffer.length - 1] = ' ';
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length-1]=0;
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,0};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,' '};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testParseOctal$catena_1() throws Exception{
        long value; 
        byte [] buffer;
        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits
        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations
        final String maxOctal = "777777777777"; // Maximum valid octal
        buffer = maxOctal.getBytes(CharsetNames.UTF_8);
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL_OVERFLOW, value);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length - 1] = ' ';
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        assertEquals(MAX_OCTAL, value);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        buffer[buffer.length-1]=0;
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,0};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,' '};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testParseOctal$catena_2() throws Exception{
        long value; 
        byte [] buffer;
        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits
        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations
        final String maxOctal = "777777777777"; // Maximum valid octal
        buffer = maxOctal.getBytes(CharsetNames.UTF_8);
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL_OVERFLOW, value);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length - 1] = ' ';
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length-1]=0;
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        assertEquals(MAX_OCTAL, value);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        buffer=new byte[]{0,0};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,' '};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testParseOctal$catena_3() throws Exception{
        long value; 
        byte [] buffer;
        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits
        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations
        final String maxOctal = "777777777777"; // Maximum valid octal
        buffer = maxOctal.getBytes(CharsetNames.UTF_8);
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL_OVERFLOW, value);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length - 1] = ' ';
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length-1]=0;
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,0};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        assertEquals(0, value);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        buffer=new byte[]{0,' '};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testParseOctal$catena_4() throws Exception{
        long value; 
        byte [] buffer;
        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits
        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations
        final String maxOctal = "777777777777"; // Maximum valid octal
        buffer = maxOctal.getBytes(CharsetNames.UTF_8);
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL_OVERFLOW, value);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length - 1] = ' ';
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer[buffer.length-1]=0;
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(MAX_OCTAL, value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,0};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        try{ assertEquals(0, value);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        buffer=new byte[]{0,' '};
        value = TarUtils.parseOctal(buffer,0, buffer.length);
        assertEquals(0, value);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Compress_6
@@@
Split test: org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNotEquals
file: /tmp/Compress_6/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Begin: Pos(227, 12)
End: Pos(231, 5)
Source: /tmp/Compress_6/src/test/java//org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java
Name: testNotEquals
Childs: [StatementAssertion<Begin: Pos(230, 9), End: Pos(230, 43)>,
]
--------------------
Run: Csv_8
@@@
Split test: org.apache.commons.csv.CSVFormatTest::testDuplicateHeaderElements
file: /tmp/Csv_8/src/test/java//org/apache/commons/csv/CSVFormatTest.java
# check: Use pattern matching: None.validate
Selector contains assertion
Begin: Pos(64, 5)
End: Pos(67, 5)
Source: /tmp/Csv_8/src/test/java//org/apache/commons/csv/CSVFormatTest.java
Name: testDuplicateHeaderElements
Childs: [StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 58)>,
]
--------------------
Run: Csv_16
@@@
Split test: org.apache.commons.csv.CSVParserTest::testIteratorSequenceBreaking
file: /tmp/Csv_16/src/test/java//org/apache/commons/csv/CSVParserTest.java
Begin: Pos(1001, 5)
End: Pos(1055, 5)
Source: /tmp/Csv_16/src/test/java//org/apache/commons/csv/CSVParserTest.java
Name: testIteratorSequenceBreaking
Childs: [StatementAssertion<Begin: Pos(1013, 13), End: Pos(1013, 70)>,
StatementAssertion<Begin: Pos(1022, 13), End: Pos(1022, 70)>,
StatementAssertion<Begin: Pos(1030, 13), End: Pos(1030, 70)>,
StatementAssertion<Begin: Pos(1037, 13), End: Pos(1037, 70)>,
StatementAssertion<Begin: Pos(1045, 13), End: Pos(1045, 70)>,
StatementAssertion<Begin: Pos(1053, 13), End: Pos(1053, 70)>,
]
---
    @Test
    public void testIteratorSequenceBreaking$catena_0() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void testIteratorSequenceBreaking$catena_1() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void testIteratorSequenceBreaking$catena_2() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void testIteratorSequenceBreaking$catena_3() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void testIteratorSequenceBreaking$catena_4() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    @Test
    public void testIteratorSequenceBreaking$catena_5() throws IOException {
        final String fiveRows = "1\n2\n3\n4\n5\n";

        // Iterator hasNext() shouldn't break sequence
        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        int recordNumber = 0;
        Iterator<CSVRecord> iter = parser.iterator();
        recordNumber = 0;
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        iter.hasNext();
        while (iter.hasNext()) {
            CSVRecord record = iter.next();
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence
        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));
        recordNumber = 0;
        for (CSVRecord record : parser) {
            recordNumber++;
            try{ assertEquals(String.valueOf(recordNumber), record.get(0));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            if (recordNumber >= 2) {
                break;
            }
        }
        parser.iterator().hasNext();
        for (CSVRecord record : parser) {
            recordNumber++;
            assertEquals(String.valueOf(recordNumber), record.get(0));                                      /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: Csv_2
@@@
Split test: org.apache.commons.csv.CSVRecordTest::testGetStringInconsistentRecord
file: /tmp/Csv_2/src/test/java//org/apache/commons/csv/CSVRecordTest.java
Begin: Pos(66, 5)
End: Pos(70, 5)
Source: /tmp/Csv_2/src/test/java//org/apache/commons/csv/CSVRecordTest.java
Name: testGetStringInconsistentRecord
Childs: []
--------------------
Run: Csv_7
@@@
Split test: org.apache.commons.csv.CSVParserTest::testDuplicateHeaderEntries
file: /tmp/Csv_7/src/test/java//org/apache/commons/csv/CSVParserTest.java
Begin: Pos(498, 5)
End: Pos(501, 5)
Source: /tmp/Csv_7/src/test/java//org/apache/commons/csv/CSVParserTest.java
Name: testDuplicateHeaderEntries
Childs: []
--------------------
Run: Csv_3
@@@
Split test: org.apache.commons.csv.CSVLexerTest::testEscapedMySqlNullValue
file: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVLexerTest.java
Begin: Pos(331, 5)
End: Pos(336, 5)
Source: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVLexerTest.java
Name: testEscapedMySqlNullValue
Childs: [StatementAssertion<Begin: Pos(335, 9), End: Pos(335, 84)>,
]
@@@
Split test: org.apache.commons.csv.CSVLexerTest::testEscapedCharacter
file: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVLexerTest.java
Begin: Pos(338, 5)
End: Pos(342, 5)
Source: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVLexerTest.java
Name: testEscapedCharacter
Childs: [StatementAssertion<Begin: Pos(341, 9), End: Pos(341, 84)>,
]
@@@
Split test: org.apache.commons.csv.CSVParserTest::testBackslashEscaping
file: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVParserTest.java
Begin: Pos(282, 5)
End: Pos(323, 5)
Source: /tmp/Csv_3/src/test/java//org/apache/commons/csv/CSVParserTest.java
Name: testBackslashEscaping
Childs: [StatementAssertion<Begin: Pos(320, 9), End: Pos(320, 39)>,
StatementAssertion<Begin: Pos(322, 9), End: Pos(322, 76)>,
]
---
    @Test
    public void testBackslashEscaping$catena_0() throws IOException {

        // To avoid confusion over the need for escaping chars in java code,
        // We will test with a forward slash as the escape char, and a single
        // quote as the encapsulator.

        final String code =
                "one,two,three\n" // 0
                        + "'',''\n"       // 1) empty encapsulators
                        + "/',/'\n"       // 2) single encapsulators
                        + "'/'','/''\n"   // 3) single encapsulators encapsulated via escape
                        + "'''',''''\n"   // 4) single encapsulators encapsulated via doubling
                        + "/,,/,\n"       // 5) separator escaped
                        + "//,//\n"       // 6) escape escaped
                        + "'//','//'\n"   // 7) escape escaped in encapsulation
                        + "   8   ,   \"quoted \"\" /\" // string\"   \n"     // don't eat spaces
                        + "9,   /\n   \n"  // escaped newline
                        + "";
        final String[][] res = {
                {"one", "two", "three"}, // 0
                {"", ""},                // 1
                {"'", "'"},              // 2
                {"'", "'"},              // 3
                {"'", "'"},              // 4
                {",", ","},              // 5
                {"/", "/"},              // 6
                {"/", "/"},              // 7
                {"   8   ", "   \"quoted \"\" /\" / string\"   "},
                {"9", "   \n   "},
        };


        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\'').withEscape('/')
                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();

        final CSVParser parser = new CSVParser(code, format);
        final List<CSVRecord> records = parser.getRecords();
        assertTrue(records.size() > 0);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        try{ Utils.compare("Records do not match expected result", res, records);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testBackslashEscaping$catena_1() throws IOException {

        // To avoid confusion over the need for escaping chars in java code,
        // We will test with a forward slash as the escape char, and a single
        // quote as the encapsulator.

        final String code =
                "one,two,three\n" // 0
                        + "'',''\n"       // 1) empty encapsulators
                        + "/',/'\n"       // 2) single encapsulators
                        + "'/'','/''\n"   // 3) single encapsulators encapsulated via escape
                        + "'''',''''\n"   // 4) single encapsulators encapsulated via doubling
                        + "/,,/,\n"       // 5) separator escaped
                        + "//,//\n"       // 6) escape escaped
                        + "'//','//'\n"   // 7) escape escaped in encapsulation
                        + "   8   ,   \"quoted \"\" /\" // string\"   \n"     // don't eat spaces
                        + "9,   /\n   \n"  // escaped newline
                        + "";
        final String[][] res = {
                {"one", "two", "three"}, // 0
                {"", ""},                // 1
                {"'", "'"},              // 2
                {"'", "'"},              // 3
                {"'", "'"},              // 4
                {",", ","},              // 5
                {"/", "/"},              // 6
                {"/", "/"},              // 7
                {"   8   ", "   \"quoted \"\" /\" / string\"   "},
                {"9", "   \n   "},
        };


        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\'').withEscape('/')
                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();

        final CSVParser parser = new CSVParser(code, format);
        final List<CSVRecord> records = parser.getRecords();
        try{ assertTrue(records.size() > 0);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Utils.compare("Records do not match expected result", res, records);                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Csv_13
@@@
Split test: org.apache.commons.csv.CSVPrinterTest::testMySqlNullOutput
file: /tmp/Csv_13/src/test/java//org/apache/commons/csv/CSVPrinterTest.java
Begin: Pos(322, 5)
End: Pos(422, 5)
Source: /tmp/Csv_13/src/test/java//org/apache/commons/csv/CSVPrinterTest.java
Name: testMySqlNullOutput
Childs: [StatementAssertion<Begin: Pos(331, 9), End: Pos(331, 50)>,
StatementAssertion<Begin: Pos(333, 9), End: Pos(333, 50)>,
StatementAssertion<Begin: Pos(342, 9), End: Pos(342, 50)>,
StatementAssertion<Begin: Pos(344, 9), End: Pos(344, 59)>,
StatementAssertion<Begin: Pos(353, 9), End: Pos(353, 50)>,
StatementAssertion<Begin: Pos(355, 9), End: Pos(355, 59)>,
StatementAssertion<Begin: Pos(364, 9), End: Pos(364, 50)>,
StatementAssertion<Begin: Pos(366, 9), End: Pos(366, 59)>,
StatementAssertion<Begin: Pos(375, 9), End: Pos(375, 50)>,
StatementAssertion<Begin: Pos(377, 9), End: Pos(377, 59)>,
StatementAssertion<Begin: Pos(386, 9), End: Pos(386, 50)>,
StatementAssertion<Begin: Pos(388, 9), End: Pos(388, 59)>,
StatementAssertion<Begin: Pos(397, 9), End: Pos(397, 50)>,
StatementAssertion<Begin: Pos(399, 9), End: Pos(399, 59)>,
StatementAssertion<Begin: Pos(408, 9), End: Pos(408, 50)>,
StatementAssertion<Begin: Pos(410, 9), End: Pos(410, 59)>,
StatementAssertion<Begin: Pos(419, 9), End: Pos(419, 50)>,
StatementAssertion<Begin: Pos(421, 9), End: Pos(421, 59)>,
]
---
    @Test
    public void testMySqlNullOutput$catena_0() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_1() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(new Object[2], record0);                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_2() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_3() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_4() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_5() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_6() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_7() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_8() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_9() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_10() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_11() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_12() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_13() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_14() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_15() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_16() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        assertEquals(expected, writer.toString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMySqlNullOutput$catena_17() throws IOException {
        Object[] s = new String[] { "NULL", null };
        CSVFormat format = CSVFormat.MYSQL.withQuote('"').withNullString("NULL").withQuoteMode(QuoteMode.NON_NUMERIC);
        StringWriter writer = new StringWriter();
        CSVPrinter printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        String expected = "\"NULL\"\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        String[] record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(new Object[2], record0);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", null };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\n", "A" };
        format = CSVFormat.MYSQL.withNullString("\\N");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\n\tA\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL.withNullString("NULL");
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\tNULL\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "", null };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\t\\N\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\N", "", "\u000e,\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\N\t\t\u000e,\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "NULL", "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "NULL\t\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        try{ assertArrayEquals(expectNulls(s, format), record0);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        s = new String[] { "\\\r" };
        format = CSVFormat.MYSQL;
        writer = new StringWriter();
        printer = new CSVPrinter(writer, format);
        printer.printRecord(s);
        printer.close();
        expected = "\\\\\\r\n";
        try{ assertEquals(expected, writer.toString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        record0 = toFirstRecordValues(expected, format);
        assertArrayEquals(expectNulls(s, format), record0);                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.csv.CSVPrinterTest::testMySqlNullStringDefault
file: /tmp/Csv_13/src/test/java//org/apache/commons/csv/CSVPrinterTest.java
Begin: Pos(317, 5)
End: Pos(320, 5)
Source: /tmp/Csv_13/src/test/java//org/apache/commons/csv/CSVPrinterTest.java
Name: testMySqlNullStringDefault
Childs: [StatementAssertion<Begin: Pos(319, 9), End: Pos(319, 61)>,
]
--------------------
Run: Csv_5
@@@
Split test: org.apache.commons.csv.CSVFormatTest::testNullRecordSeparatorCsv106
file: /tmp/Csv_5/src/test/java//org/apache/commons/csv/CSVFormatTest.java
Begin: Pos(232, 5)
End: Pos(238, 5)
Source: /tmp/Csv_5/src/test/java//org/apache/commons/csv/CSVFormatTest.java
Name: testNullRecordSeparatorCsv106
Childs: [StatementAssertion<Begin: Pos(236, 9), End: Pos(236, 33)>,
StatementAssertion<Begin: Pos(237, 9), End: Pos(237, 48)>,
]
---
    @Test
    public void testNullRecordSeparatorCsv106$catena_0() {
        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader("H1", "H2");
        final String formatStr = format.format("A", "B");
        assertNotNull(formatStr);                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(formatStr.endsWith("null"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testNullRecordSeparatorCsv106$catena_1() {
        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader("H1", "H2");
        final String formatStr = format.format("A", "B");
        try{ assertNotNull(formatStr);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(formatStr.endsWith("null"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Csv_6
@@@
Split test: org.apache.commons.csv.CSVRecordTest::testToMapWithShortRecord
file: /tmp/Csv_6/src/test/java//org/apache/commons/csv/CSVRecordTest.java
Begin: Pos(163, 5)
End: Pos(168, 5)
Source: /tmp/Csv_6/src/test/java//org/apache/commons/csv/CSVRecordTest.java
Name: testToMapWithShortRecord
Childs: []
--------------------
Run: Gson_8
@@@
Split test: com.google.gson.internal.UnsafeAllocatorInstantiationTest::testInterfaceInstantiation
file: /tmp/Gson_8/gson/src/test/java//com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
Begin: Pos(39, 10)
End: Pos(47, 3)
Source: /tmp/Gson_8/gson/src/test/java//com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
Name: testInterfaceInstantiation
Childs: [StatementAssertion<Begin: Pos(43, 7), End: Pos(43, 13)>,
StatementAssertion<Begin: Pos(45, 7), End: Pos(45, 70)>,
]
---
  public void testInterfaceInstantiation$catena_0() {
    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
    try {
      unsafeAllocator.newInstance(Interface.class);
      fail();                                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    } catch (Exception e) {
      try{ assertEquals(e.getClass(), UnsupportedOperationException.class);                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
  }
---
---
  public void testInterfaceInstantiation$catena_1() {
    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
    try {
      unsafeAllocator.newInstance(Interface.class);
      try{ fail();                                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    } catch (Exception e) {
      assertEquals(e.getClass(), UnsupportedOperationException.class);                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
  }
---
@@@
Split test: com.google.gson.internal.UnsafeAllocatorInstantiationTest::testAbstractClassInstantiation
file: /tmp/Gson_8/gson/src/test/java//com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
Begin: Pos(53, 10)
End: Pos(61, 3)
Source: /tmp/Gson_8/gson/src/test/java//com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
Name: testAbstractClassInstantiation
Childs: [StatementAssertion<Begin: Pos(57, 7), End: Pos(57, 13)>,
StatementAssertion<Begin: Pos(59, 7), End: Pos(59, 70)>,
]
---
  public void testAbstractClassInstantiation$catena_0() {
    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
    try {
      unsafeAllocator.newInstance(AbstractClass.class);
      fail();                                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    } catch (Exception e) {
      try{ assertEquals(e.getClass(), UnsupportedOperationException.class);                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
  }
---
---
  public void testAbstractClassInstantiation$catena_1() {
    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
    try {
      unsafeAllocator.newInstance(AbstractClass.class);
      try{ fail();                                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    } catch (Exception e) {
      assertEquals(e.getClass(), UnsupportedOperationException.class);                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
  }
---
--------------------
Run: Gson_9
@@@
Split test: com.google.gson.stream.JsonWriterTest::testBoxedBooleans
file: /tmp/Gson_9/gson/src/test/java//com/google/gson/stream/JsonWriterTest.java
Begin: Pos(286, 10)
End: Pos(295, 3)
Source: /tmp/Gson_9/gson/src/test/java//com/google/gson/stream/JsonWriterTest.java
Name: testBoxedBooleans
Childs: [StatementAssertion<Begin: Pos(294, 5), End: Pos(294, 63)>,
]
--------------------
Run: Gson_18
@@@
Split test: com.google.gson.functional.CollectionTest::testIssue1107
file: /tmp/Gson_18/gson/src/test/java//com/google/gson/functional/CollectionTest.java
Begin: Pos(401, 10)
End: Pos(413, 3)
Source: /tmp/Gson_18/gson/src/test/java//com/google/gson/functional/CollectionTest.java
Name: testIssue1107
Childs: [StatementAssertion<Begin: Pos(411, 5), End: Pos(411, 25)>,
StatementAssertion<Begin: Pos(412, 5), End: Pos(412, 41)>,
]
---
  public void testIssue1107$catena_0() {
    String json = "{\n" +
            "  \"inBig\": {\n" +
            "    \"key\": [\n" +
            "      { \"inSmall\": \"hello\" }\n" +
            "    ]\n" +
            "  }\n" +
            "}";
    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
    SmallClass small = bigClass.inBig.get("key").get(0);
    assertNotNull(small);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals("hello", small.inSmall);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testIssue1107$catena_1() {
    String json = "{\n" +
            "  \"inBig\": {\n" +
            "    \"key\": [\n" +
            "      { \"inSmall\": \"hello\" }\n" +
            "    ]\n" +
            "  }\n" +
            "}";
    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
    SmallClass small = bigClass.inBig.get("key").get(0);
    try{ assertNotNull(small);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals("hello", small.inSmall);                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
--------------------
Run: Gson_12
@@@
Split test: com.google.gson.internal.bind.JsonTreeReaderTest::testSkipValue_filledJsonObject
file: /tmp/Gson_12/gson/src/test/java//com/google/gson/internal/bind/JsonTreeReaderTest.java
Begin: Pos(33, 10)
End: Pos(49, 3)
Source: /tmp/Gson_12/gson/src/test/java//com/google/gson/internal/bind/JsonTreeReaderTest.java
Name: testSkipValue_filledJsonObject
Childs: [StatementAssertion<Begin: Pos(48, 5), End: Pos(48, 52)>,
]
@@@
Split test: com.google.gson.internal.bind.JsonTreeReaderTest::testSkipValue_emptyJsonObject
file: /tmp/Gson_12/gson/src/test/java//com/google/gson/internal/bind/JsonTreeReaderTest.java
Begin: Pos(27, 10)
End: Pos(31, 3)
Source: /tmp/Gson_12/gson/src/test/java//com/google/gson/internal/bind/JsonTreeReaderTest.java
Name: testSkipValue_emptyJsonObject
Childs: [StatementAssertion<Begin: Pos(30, 5), End: Pos(30, 52)>,
]
--------------------
Run: Gson_16
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveTypeVariablesResolve12
file: /tmp/Gson_16/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(107, 10)
End: Pos(110, 3)
Source: /tmp/Gson_16/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testRecursiveTypeVariablesResolve12
Childs: [StatementAssertion<Begin: Pos(109, 5), End: Pos(109, 27)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveTypeVariablesResolve1
file: /tmp/Gson_16/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(102, 10)
End: Pos(105, 3)
Source: /tmp/Gson_16/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testRecursiveTypeVariablesResolve1
Childs: [StatementAssertion<Begin: Pos(104, 5), End: Pos(104, 27)>,
]
--------------------
Run: Gson_2
@@@
Split test: com.google.gson.functional.DefaultTypeAdaptersTest::testJsonElementTypeMismatch
file: /tmp/Gson_2/gson/src/test/java//com/google/gson/functional/DefaultTypeAdaptersTest.java
Begin: Pos(621, 10)
End: Pos(629, 3)
Source: /tmp/Gson_2/gson/src/test/java//com/google/gson/functional/DefaultTypeAdaptersTest.java
Name: testJsonElementTypeMismatch
Childs: [StatementAssertion<Begin: Pos(624, 7), End: Pos(624, 13)>,
StatementAssertion<Begin: Pos(626, 7), End: Pos(627, 33)>,
]
---
  public void testJsonElementTypeMismatch$catena_0() {
    try {
      gson.fromJson("\"abc\"", JsonObject.class);
      fail();                                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    } catch (JsonSyntaxException expected) {
      try{ assertEquals("Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive",
          expected.getMessage());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
  }
---
---
  public void testJsonElementTypeMismatch$catena_1() {
    try {
      gson.fromJson("\"abc\"", JsonObject.class);
      try{ fail();                                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    } catch (JsonSyntaxException expected) {
      assertEquals("Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive",
          expected.getMessage());                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
  }
---
--------------------
Run: Gson_7
@@@
Split test: com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedLongKeys
file: /tmp/Gson_7/gson/src/test/java//com/google/gson/functional/MapTest.java
Begin: Pos(188, 10)
End: Pos(196, 3)
Source: /tmp/Gson_7/gson/src/test/java//com/google/gson/functional/MapTest.java
Name: testMapDeserializationWithUnquotedLongKeys
Childs: [StatementAssertion<Begin: Pos(193, 5), End: Pos(193, 32)>,
StatementAssertion<Begin: Pos(194, 5), End: Pos(194, 41)>,
StatementAssertion<Begin: Pos(195, 5), End: Pos(195, 42)>,
]
---
  public void testMapDeserializationWithUnquotedLongKeys$catena_0() {
    long longKey = 9876543210L;
    String json = String.format("{%d:\"456\"}", longKey);
    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
    Map<Long, String> map = gson.fromJson(json, typeOfMap);
    assertEquals(1, map.size());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(map.containsKey(longKey));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(longKey));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testMapDeserializationWithUnquotedLongKeys$catena_1() {
    long longKey = 9876543210L;
    String json = String.format("{%d:\"456\"}", longKey);
    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
    Map<Long, String> map = gson.fromJson(json, typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(map.containsKey(longKey));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals("456", map.get(longKey));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testMapDeserializationWithUnquotedLongKeys$catena_2() {
    long longKey = 9876543210L;
    String json = String.format("{%d:\"456\"}", longKey);
    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
    Map<Long, String> map = gson.fromJson(json, typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(longKey));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals("456", map.get(longKey));                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
@@@
Split test: com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedIntegerKeys
file: /tmp/Gson_7/gson/src/test/java//com/google/gson/functional/MapTest.java
Begin: Pos(170, 10)
End: Pos(176, 3)
Source: /tmp/Gson_7/gson/src/test/java//com/google/gson/functional/MapTest.java
Name: testMapDeserializationWithUnquotedIntegerKeys
Childs: [StatementAssertion<Begin: Pos(173, 5), End: Pos(173, 32)>,
StatementAssertion<Begin: Pos(174, 5), End: Pos(174, 37)>,
StatementAssertion<Begin: Pos(175, 5), End: Pos(175, 38)>,
]
---
  public void testMapDeserializationWithUnquotedIntegerKeys$catena_0() {
    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();
    Map<Integer, String> map = gson.fromJson("{123:\"456\"}", typeOfMap);
    assertEquals(1, map.size());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testMapDeserializationWithUnquotedIntegerKeys$catena_1() {
    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();
    Map<Integer, String> map = gson.fromJson("{123:\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(map.containsKey(123));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testMapDeserializationWithUnquotedIntegerKeys$catena_2() {
    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();
    Map<Integer, String> map = gson.fromJson("{123:\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals("456", map.get(123));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
@@@
Split test: com.google.gson.stream.JsonReaderTest::testPeekingUnquotedStringsPrefixedWithIntegers
file: /tmp/Gson_7/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Begin: Pos(496, 10)
End: Pos(507, 3)
Source: /tmp/Gson_7/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Name: testPeekingUnquotedStringsPrefixedWithIntegers
Childs: [StatementAssertion<Begin: Pos(500, 5), End: Pos(500, 40)>,
StatementAssertion<Begin: Pos(503, 7), End: Pos(503, 13)>,
StatementAssertion<Begin: Pos(506, 5), End: Pos(506, 50)>,
]
---
  public void testPeekingUnquotedStringsPrefixedWithIntegers$catena_0() throws IOException {
    JsonReader reader = new JsonReader(reader("[12.34e5x]"));
    reader.setLenient(true);
    reader.beginArray();
    assertEquals(STRING, reader.peek());                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try {
      reader.nextInt();
      try{ fail();                                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    } catch (NumberFormatException expected) {
    }
    try{ assertEquals("12.34e5x", reader.nextString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testPeekingUnquotedStringsPrefixedWithIntegers$catena_1() throws IOException {
    JsonReader reader = new JsonReader(reader("[12.34e5x]"));
    reader.setLenient(true);
    reader.beginArray();
    try{ assertEquals(STRING, reader.peek());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try {
      reader.nextInt();
      fail();                                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    } catch (NumberFormatException expected) {
    }
    try{ assertEquals("12.34e5x", reader.nextString());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testPeekingUnquotedStringsPrefixedWithIntegers$catena_2() throws IOException {
    JsonReader reader = new JsonReader(reader("[12.34e5x]"));
    reader.setLenient(true);
    reader.beginArray();
    try{ assertEquals(STRING, reader.peek());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try {
      reader.nextInt();
      try{ fail();                                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    } catch (NumberFormatException expected) {
    }
    assertEquals("12.34e5x", reader.nextString());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
--------------------
Run: Gson_3
@@@
Split test: com.google.gson.functional.MapTest::testConcurrentMap
file: /tmp/Gson_3/gson/src/test/java//com/google/gson/functional/MapTest.java
Begin: Pos(186, 10)
End: Pos(194, 3)
Source: /tmp/Gson_3/gson/src/test/java//com/google/gson/functional/MapTest.java
Name: testConcurrentMap
Childs: [StatementAssertion<Begin: Pos(189, 5), End: Pos(189, 32)>,
StatementAssertion<Begin: Pos(190, 5), End: Pos(190, 37)>,
StatementAssertion<Begin: Pos(191, 5), End: Pos(191, 38)>,
StatementAssertion<Begin: Pos(193, 5), End: Pos(193, 44)>,
]
---
  public void testConcurrentMap$catena_0() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();
    ConcurrentMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    assertEquals(1, map.size());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentMap$catena_1() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();
    ConcurrentMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(map.containsKey(123));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentMap$catena_2() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();
    ConcurrentMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals("456", map.get(123));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentMap$catena_3() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();
    ConcurrentMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    assertEquals("{\"123\":\"456\"}", json);                                                                /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
@@@
Split test: com.google.gson.functional.MapTest::testConcurrentNavigableMap
file: /tmp/Gson_3/gson/src/test/java//com/google/gson/functional/MapTest.java
Begin: Pos(206, 10)
End: Pos(214, 3)
Source: /tmp/Gson_3/gson/src/test/java//com/google/gson/functional/MapTest.java
Name: testConcurrentNavigableMap
Childs: [StatementAssertion<Begin: Pos(209, 5), End: Pos(209, 32)>,
StatementAssertion<Begin: Pos(210, 5), End: Pos(210, 37)>,
StatementAssertion<Begin: Pos(211, 5), End: Pos(211, 38)>,
StatementAssertion<Begin: Pos(213, 5), End: Pos(213, 44)>,
]
---
  public void testConcurrentNavigableMap$catena_0() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();
    ConcurrentNavigableMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    assertEquals(1, map.size());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentNavigableMap$catena_1() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();
    ConcurrentNavigableMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(map.containsKey(123));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentNavigableMap$catena_2() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();
    ConcurrentNavigableMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals("456", map.get(123));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    String json = gson.toJson(map);
    try{ assertEquals("{\"123\":\"456\"}", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testConcurrentNavigableMap$catena_3() throws Exception {
    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();
    ConcurrentNavigableMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
    try{ assertEquals(1, map.size());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(map.containsKey(123));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals("456", map.get(123));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    String json = gson.toJson(map);
    assertEquals("{\"123\":\"456\"}", json);                                                                /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
--------------------
Run: Gson_4
@@@
Split test: com.google.gson.stream.JsonReaderTest::testTopLevelValueTypeWithSkipValue
file: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Begin: Pos(1249, 10)
End: Pos(1253, 3)
Source: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Name: testTopLevelValueTypeWithSkipValue
Childs: [StatementAssertion<Begin: Pos(1252, 5), End: Pos(1252, 56)>,
]
@@@
Split test: com.google.gson.stream.JsonReaderTest::testTopLevelValueTypes
file: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Begin: Pos(1222, 10)
End: Pos(1247, 3)
Source: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonReaderTest.java
Name: testTopLevelValueTypes
Childs: [StatementAssertion<Begin: Pos(1224, 5), End: Pos(1224, 38)>,
StatementAssertion<Begin: Pos(1225, 5), End: Pos(1225, 57)>,
StatementAssertion<Begin: Pos(1228, 5), End: Pos(1228, 39)>,
StatementAssertion<Begin: Pos(1229, 5), End: Pos(1229, 57)>,
StatementAssertion<Begin: Pos(1232, 5), End: Pos(1232, 49)>,
StatementAssertion<Begin: Pos(1234, 5), End: Pos(1234, 57)>,
StatementAssertion<Begin: Pos(1237, 5), End: Pos(1237, 41)>,
StatementAssertion<Begin: Pos(1238, 5), End: Pos(1238, 57)>,
StatementAssertion<Begin: Pos(1241, 5), End: Pos(1241, 46)>,
StatementAssertion<Begin: Pos(1242, 5), End: Pos(1242, 57)>,
StatementAssertion<Begin: Pos(1245, 5), End: Pos(1245, 44)>,
StatementAssertion<Begin: Pos(1246, 5), End: Pos(1246, 57)>,
]
---
  public void testTopLevelValueTypes$catena_0() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    assertTrue(reader1.nextBoolean());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_1() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_2() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    assertFalse(reader2.nextBoolean());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_3() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_4() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    assertEquals(JsonToken.NULL, reader3.peek());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_5() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_6() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    assertEquals(123, reader4.nextInt());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_7() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_8() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    assertEquals(123.4, reader5.nextDouble());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_9() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_10() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    assertEquals("a", reader6.nextString());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_11() throws IOException {
    JsonReader reader1 = new JsonReader(reader("true"));
    try{ assertTrue(reader1.nextBoolean());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader1.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader2 = new JsonReader(reader("false"));
    try{ assertFalse(reader2.nextBoolean());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader2.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader3 = new JsonReader(reader("null"));
    try{ assertEquals(JsonToken.NULL, reader3.peek());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    reader3.nextNull();
    try{ assertEquals(JsonToken.END_DOCUMENT, reader3.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader4 = new JsonReader(reader("123"));
    try{ assertEquals(123, reader4.nextInt());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader4.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader5 = new JsonReader(reader("123.4"));
    try{ assertEquals(123.4, reader5.nextDouble());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertEquals(JsonToken.END_DOCUMENT, reader5.peek());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    JsonReader reader6 = new JsonReader(reader("\"a\""));
    try{ assertEquals("a", reader6.nextString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
@@@
Split test: com.google.gson.stream.JsonWriterTest::testTopLevelValueTypes
file: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonWriterTest.java
Begin: Pos(28, 10)
End: Pos(58, 3)
Source: /tmp/Gson_4/gson/src/test/java//com/google/gson/stream/JsonWriterTest.java
Name: testTopLevelValueTypes
Childs: [StatementAssertion<Begin: Pos(33, 5), End: Pos(33, 45)>,
StatementAssertion<Begin: Pos(39, 5), End: Pos(39, 45)>,
StatementAssertion<Begin: Pos(45, 5), End: Pos(45, 44)>,
StatementAssertion<Begin: Pos(51, 5), End: Pos(51, 46)>,
StatementAssertion<Begin: Pos(57, 5), End: Pos(57, 46)>,
]
---
  public void testTopLevelValueTypes$catena_0() throws IOException {
    StringWriter string1 = new StringWriter();
    JsonWriter writer1 = new JsonWriter(string1);
    writer1.value(true);
    writer1.close();
    assertEquals("true", string1.toString());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

    StringWriter string2 = new StringWriter();
    JsonWriter writer2 = new JsonWriter(string2);
    writer2.nullValue();
    writer2.close();
    try{ assertEquals("null", string2.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string3 = new StringWriter();
    JsonWriter writer3 = new JsonWriter(string3);
    writer3.value(123);
    writer3.close();
    try{ assertEquals("123", string3.toString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string4 = new StringWriter();
    JsonWriter writer4 = new JsonWriter(string4);
    writer4.value(123.4);
    writer4.close();
    try{ assertEquals("123.4", string4.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string5 = new StringWriter();
    JsonWriter writert = new JsonWriter(string5);
    writert.value("a");
    writert.close();
    try{ assertEquals("\"a\"", string5.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_1() throws IOException {
    StringWriter string1 = new StringWriter();
    JsonWriter writer1 = new JsonWriter(string1);
    writer1.value(true);
    writer1.close();
    try{ assertEquals("true", string1.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string2 = new StringWriter();
    JsonWriter writer2 = new JsonWriter(string2);
    writer2.nullValue();
    writer2.close();
    assertEquals("null", string2.toString());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

    StringWriter string3 = new StringWriter();
    JsonWriter writer3 = new JsonWriter(string3);
    writer3.value(123);
    writer3.close();
    try{ assertEquals("123", string3.toString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string4 = new StringWriter();
    JsonWriter writer4 = new JsonWriter(string4);
    writer4.value(123.4);
    writer4.close();
    try{ assertEquals("123.4", string4.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string5 = new StringWriter();
    JsonWriter writert = new JsonWriter(string5);
    writert.value("a");
    writert.close();
    try{ assertEquals("\"a\"", string5.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_2() throws IOException {
    StringWriter string1 = new StringWriter();
    JsonWriter writer1 = new JsonWriter(string1);
    writer1.value(true);
    writer1.close();
    try{ assertEquals("true", string1.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string2 = new StringWriter();
    JsonWriter writer2 = new JsonWriter(string2);
    writer2.nullValue();
    writer2.close();
    try{ assertEquals("null", string2.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string3 = new StringWriter();
    JsonWriter writer3 = new JsonWriter(string3);
    writer3.value(123);
    writer3.close();
    assertEquals("123", string3.toString());                                                                /***** ORIGINAL ASSERTION IS HERE *****/

    StringWriter string4 = new StringWriter();
    JsonWriter writer4 = new JsonWriter(string4);
    writer4.value(123.4);
    writer4.close();
    try{ assertEquals("123.4", string4.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string5 = new StringWriter();
    JsonWriter writert = new JsonWriter(string5);
    writert.value("a");
    writert.close();
    try{ assertEquals("\"a\"", string5.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_3() throws IOException {
    StringWriter string1 = new StringWriter();
    JsonWriter writer1 = new JsonWriter(string1);
    writer1.value(true);
    writer1.close();
    try{ assertEquals("true", string1.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string2 = new StringWriter();
    JsonWriter writer2 = new JsonWriter(string2);
    writer2.nullValue();
    writer2.close();
    try{ assertEquals("null", string2.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string3 = new StringWriter();
    JsonWriter writer3 = new JsonWriter(string3);
    writer3.value(123);
    writer3.close();
    try{ assertEquals("123", string3.toString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string4 = new StringWriter();
    JsonWriter writer4 = new JsonWriter(string4);
    writer4.value(123.4);
    writer4.close();
    assertEquals("123.4", string4.toString());                                                              /***** ORIGINAL ASSERTION IS HERE *****/

    StringWriter string5 = new StringWriter();
    JsonWriter writert = new JsonWriter(string5);
    writert.value("a");
    writert.close();
    try{ assertEquals("\"a\"", string5.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
  }
---
---
  public void testTopLevelValueTypes$catena_4() throws IOException {
    StringWriter string1 = new StringWriter();
    JsonWriter writer1 = new JsonWriter(string1);
    writer1.value(true);
    writer1.close();
    try{ assertEquals("true", string1.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string2 = new StringWriter();
    JsonWriter writer2 = new JsonWriter(string2);
    writer2.nullValue();
    writer2.close();
    try{ assertEquals("null", string2.toString());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string3 = new StringWriter();
    JsonWriter writer3 = new JsonWriter(string3);
    writer3.value(123);
    writer3.close();
    try{ assertEquals("123", string3.toString());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string4 = new StringWriter();
    JsonWriter writer4 = new JsonWriter(string4);
    writer4.value(123.4);
    writer4.close();
    try{ assertEquals("123.4", string4.toString());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    StringWriter string5 = new StringWriter();
    JsonWriter writert = new JsonWriter(string5);
    writert.value("a");
    writert.close();
    assertEquals("\"a\"", string5.toString());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
  }
---
--------------------
Run: Gson_1
@@@
Split test: com.google.gson.functional.TypeVariableTest::testSingle
file: /tmp/Gson_1/gson/src/test/java//com/google/gson/functional/TypeVariableTest.java
Begin: Pos(33, 10)
End: Pos(46, 3)
Source: /tmp/Gson_1/gson/src/test/java//com/google/gson/functional/TypeVariableTest.java
Name: testSingle
Childs: [StatementAssertion<Begin: Pos(45, 5), End: Pos(45, 29)>,
]
--------------------
Run: Gson_14
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testDoubleSupertype
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(70, 10)
End: Pos(73, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testDoubleSupertype
Childs: [StatementAssertion<Begin: Pos(71, 5), End: Pos(72, 76)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testIssue440WeakReference
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(61, 10)
End: Pos(64, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testIssue440WeakReference
Childs: [StatementAssertion<Begin: Pos(63, 5), End: Pos(63, 27)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testSubSupertype
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(85, 10)
End: Pos(88, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testSubSupertype
Childs: [StatementAssertion<Begin: Pos(86, 5), End: Pos(87, 74)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testDoubleSubtype
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(75, 10)
End: Pos(78, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testDoubleSubtype
Childs: [StatementAssertion<Begin: Pos(76, 5), End: Pos(77, 72)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testIssue603PrintStream
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(56, 10)
End: Pos(59, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testIssue603PrintStream
Childs: [StatementAssertion<Begin: Pos(58, 5), End: Pos(58, 27)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testSuperSubtype
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(80, 10)
End: Pos(83, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testSuperSubtype
Childs: [StatementAssertion<Begin: Pos(81, 5), End: Pos(82, 74)>,
]
@@@
Split test: com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveResolveSimple
file: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Begin: Pos(48, 10)
End: Pos(51, 3)
Source: /tmp/Gson_14/gson/src/test/java//com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Name: testRecursiveResolveSimple
Childs: [StatementAssertion<Begin: Pos(50, 5), End: Pos(50, 27)>,
]
--------------------
Run: Gson_6
@@@
Split test: com.google.gson.regression.JsonAdapterNullSafeTest::testNullSafeBugDeserialize
file: /tmp/Gson_6/gson/src/test/java//com/google/gson/regression/JsonAdapterNullSafeTest.java
Begin: Pos(34, 10)
End: Pos(37, 3)
Source: /tmp/Gson_6/gson/src/test/java//com/google/gson/regression/JsonAdapterNullSafeTest.java
Name: testNullSafeBugDeserialize
Childs: [StatementAssertion<Begin: Pos(36, 5), End: Pos(36, 41)>,
]
@@@
Split test: com.google.gson.regression.JsonAdapterNullSafeTest::testNullSafeBugSerialize
file: /tmp/Gson_6/gson/src/test/java//com/google/gson/regression/JsonAdapterNullSafeTest.java
Begin: Pos(29, 10)
End: Pos(32, 3)
Source: /tmp/Gson_6/gson/src/test/java//com/google/gson/regression/JsonAdapterNullSafeTest.java
Name: testNullSafeBugSerialize
Childs: []
--------------------
Run: JacksonCore_17
@@@
Split test: com.fasterxml.jackson.core.json.RawValueWithSurrogatesTest::testRawWithSurrogatesString
file: /tmp/JacksonCore_17/src/test/java//com/fasterxml/jackson/core/json/RawValueWithSurrogatesTest.java
Begin: Pos(53, 12)
End: Pos(55, 5)
Source: /tmp/JacksonCore_17/src/test/java//com/fasterxml/jackson/core/json/RawValueWithSurrogatesTest.java
Name: testRawWithSurrogatesString
Childs: [StatementAssertion<Begin: Pos(54, 9), End: Pos(54, 44)>,
]
--------------------
Run: JacksonCore_22
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testSingleMatchFilteringWithPath
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(94, 12)
End: Pos(106, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testSingleMatchFilteringWithPath
Childs: [StatementAssertion<Begin: Pos(104, 9), End: Pos(104, 56)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 43)>,
]
---
    public void testSingleMatchFilteringWithPath$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("a"),
                true, // includePath
                false // multipleMatches
        );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'a':123}"), result);                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSingleMatchFilteringWithPath$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("a"),
                true, // includePath
                false // multipleMatches
        );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'a':123}"), result);                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testAllowMultipleMatchesWithPath1
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(154, 5)
End: Pos(167, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testAllowMultipleMatchesWithPath1
Childs: [StatementAssertion<Begin: Pos(165, 9), End: Pos(165, 112)>,
StatementAssertion<Begin: Pos(166, 9), End: Pos(166, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithPath1$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value"),
                true, // includePath
                true // multipleMatches - true
        );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{\"ob\":{\"value\":3,\"value\":{\"value0\":2}},\"value\":\"val\"}"), result);         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, p.getMatchCount());                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithPath1$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value"),
                true, // includePath
                true // multipleMatches - true
        );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{\"ob\":{\"value\":3,\"value\":{\"value0\":2}},\"value\":\"val\"}"), result);    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, p.getMatchCount());                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testAllowMultipleMatchesWithPath2
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(170, 5)
End: Pos(183, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testAllowMultipleMatchesWithPath2
Childs: [StatementAssertion<Begin: Pos(181, 9), End: Pos(181, 85)>,
StatementAssertion<Begin: Pos(182, 9), End: Pos(182, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithPath2$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'array':[3,4],'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new IndexMatchFilter(1),
                true, // includePath
                true // multipleMatches - true
        );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{\"array\":[2],\"ob\":{\"array\":[4]}}"), result);                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithPath2$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'array':[3,4],'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new IndexMatchFilter(1),
                true, // includePath
                true // multipleMatches - true
        );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{\"array\":[2],\"ob\":{\"array\":[4]}}"), result);                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testMultipleMatchFilteringWithPath1
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(185, 5)
End: Pos(196, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testMultipleMatchFilteringWithPath1
Childs: [StatementAssertion<Begin: Pos(193, 9), End: Pos(193, 77)>,
StatementAssertion<Begin: Pos(194, 9), End: Pos(194, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath1$catena_0() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value0", "value2"),
                true, /* includePath */ true /* multipleMatches */ );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'ob':{'value0':2,'value2':4}}"), result);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath1$catena_1() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value0", "value2"),
                true, /* includePath */ true /* multipleMatches */ );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'ob':{'value0':2,'value2':4}}"), result);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testMultipleMatchFilteringWithPath2
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(198, 5)
End: Pos(210, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testMultipleMatchFilteringWithPath2
Childs: [StatementAssertion<Begin: Pos(208, 9), End: Pos(208, 74)>,
StatementAssertion<Begin: Pos(209, 9), End: Pos(209, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath2$catena_0() throws Exception
    {
        String INPUT = aposToQuotes("{'a':123,'ob':{'value0':2,'value':3,'value2':4},'b':true}");
        JsonParser p0 = JSON_F.createParser(INPUT);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("b", "value"),
                true, true);

        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'ob':{'value':3},'b':true}"), result);                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath2$catena_1() throws Exception
    {
        String INPUT = aposToQuotes("{'a':123,'ob':{'value0':2,'value':3,'value2':4},'b':true}");
        JsonParser p0 = JSON_F.createParser(INPUT);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("b", "value"),
                true, true);

        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'ob':{'value':3},'b':true}"), result);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testMultipleMatchFilteringWithPath3
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(212, 5)
End: Pos(223, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testMultipleMatchFilteringWithPath3
Childs: [StatementAssertion<Begin: Pos(221, 9), End: Pos(221, 95)>,
StatementAssertion<Begin: Pos(222, 9), End: Pos(222, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath3$catena_0() throws Exception
    {
        final String JSON = aposToQuotes("{'root':{'a0':true,'a':{'value':3},'b':{'value':\"foo\"}},'b0':false}");
        JsonParser p0 = JSON_F.createParser(JSON);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value"),
                true, true);
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'root':{'a':{'value':3},'b':{'value':\"foo\"}}}"), result);             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testMultipleMatchFilteringWithPath3$catena_1() throws Exception
    {
        final String JSON = aposToQuotes("{'root':{'a0':true,'a':{'value':3},'b':{'value':\"foo\"}},'b0':false}");
        JsonParser p0 = JSON_F.createParser(JSON);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new NameMatchFilter("value"),
                true, true);
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'root':{'a':{'value':3},'b':{'value':\"foo\"}}}"), result);        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testSingleMatchFilteringWithoutPath
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(80, 5)
End: Pos(92, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testSingleMatchFilteringWithoutPath
Childs: [StatementAssertion<Begin: Pos(90, 9), End: Pos(90, 48)>,
StatementAssertion<Begin: Pos(91, 9), End: Pos(91, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testSingleMatchFilteringWithoutPath$catena_0() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   false // multipleMatches
                );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("3"), result);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testSingleMatchFilteringWithoutPath$catena_1() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   false // multipleMatches
                );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("3"), result);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testNotAllowMultipleMatchesWithoutPath1
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(108, 5)
End: Pos(121, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testNotAllowMultipleMatchesWithoutPath1
Childs: [StatementAssertion<Begin: Pos(119, 9), End: Pos(119, 48)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testNotAllowMultipleMatchesWithoutPath1$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   false // multipleMatches -false
                );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("3"), result);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testNotAllowMultipleMatchesWithoutPath1$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   false // multipleMatches -false
                );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("3"), result);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testNotAllowMultipleMatchesWithoutPath2
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(123, 5)
End: Pos(136, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testNotAllowMultipleMatchesWithoutPath2
Childs: [StatementAssertion<Begin: Pos(134, 9), End: Pos(134, 48)>,
StatementAssertion<Begin: Pos(135, 9), End: Pos(135, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testNotAllowMultipleMatchesWithoutPath2$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'array':[3,4],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new IndexMatchFilter(1),
                false, // includePath
                false // multipleMatches -false
        );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("2"), result);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testNotAllowMultipleMatchesWithoutPath2$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'array':[3,4],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
                new IndexMatchFilter(1),
                false, // includePath
                false // multipleMatches -false
        );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("2"), result);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testIndexMatchWithPath1
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(225, 5)
End: Pos(239, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testIndexMatchWithPath1
Childs: [StatementAssertion<Begin: Pos(231, 9), End: Pos(231, 60)>,
StatementAssertion<Begin: Pos(232, 9), End: Pos(232, 43)>,
StatementAssertion<Begin: Pos(237, 9), End: Pos(237, 60)>,
StatementAssertion<Begin: Pos(238, 9), End: Pos(238, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath1$catena_0() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(1), true, true);
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'array':[2]}"), result);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0), true, true);
        result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[1]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath1$catena_1() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(1), true, true);
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[2]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0), true, true);
        result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[1]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath1$catena_2() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(1), true, true);
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[2]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0), true, true);
        result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("{'array':[1]}"), result);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath1$catena_3() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(1), true, true);
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[2]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0), true, true);
        result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("{'array':[1]}"), result);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testIndexMatchWithPath2
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(241, 5)
End: Pos(254, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testIndexMatchWithPath2
Childs: [StatementAssertion<Begin: Pos(246, 9), End: Pos(246, 79)>,
StatementAssertion<Begin: Pos(247, 9), End: Pos(247, 43)>,
StatementAssertion<Begin: Pos(252, 9), End: Pos(252, 87)>,
StatementAssertion<Begin: Pos(253, 9), End: Pos(253, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath2$catena_0() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0, 1), true, true);
        assertEquals(aposToQuotes("{'array':[1,2]}"), readAndWrite(JSON_F, p));                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    
        String JSON = aposToQuotes("{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}");
        p = new FilteringParserDelegate(JSON_F.createParser(JSON),
                new IndexMatchFilter(1, 3), true, true);
        try{ assertEquals(aposToQuotes("{'array':[2,4],'b':[2]}"), readAndWrite(JSON_F, p));                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath2$catena_1() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0, 1), true, true);
        try{ assertEquals(aposToQuotes("{'array':[1,2]}"), readAndWrite(JSON_F, p));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    
        String JSON = aposToQuotes("{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}");
        p = new FilteringParserDelegate(JSON_F.createParser(JSON),
                new IndexMatchFilter(1, 3), true, true);
        try{ assertEquals(aposToQuotes("{'array':[2,4],'b':[2]}"), readAndWrite(JSON_F, p));                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath2$catena_2() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0, 1), true, true);
        try{ assertEquals(aposToQuotes("{'array':[1,2]}"), readAndWrite(JSON_F, p));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    
        String JSON = aposToQuotes("{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}");
        p = new FilteringParserDelegate(JSON_F.createParser(JSON),
                new IndexMatchFilter(1, 3), true, true);
        assertEquals(aposToQuotes("{'array':[2,4],'b':[2]}"), readAndWrite(JSON_F, p));                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testIndexMatchWithPath2$catena_3() throws Exception
    {
        FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),
                new IndexMatchFilter(0, 1), true, true);
        try{ assertEquals(aposToQuotes("{'array':[1,2]}"), readAndWrite(JSON_F, p));                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    
        String JSON = aposToQuotes("{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}");
        p = new FilteringParserDelegate(JSON_F.createParser(JSON),
                new IndexMatchFilter(1, 3), true, true);
        try{ assertEquals(aposToQuotes("{'array':[2,4],'b':[2]}"), readAndWrite(JSON_F, p));                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testAllowMultipleMatchesWithoutPath
file: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(138, 5)
End: Pos(151, 5)
Source: /tmp/JacksonCore_22/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testAllowMultipleMatchesWithoutPath
Childs: [StatementAssertion<Begin: Pos(149, 9), End: Pos(149, 71)>,
StatementAssertion<Begin: Pos(150, 9), End: Pos(150, 43)>,
]
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithoutPath$catena_0() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   true // multipleMatches - true
                );
        String result = readAndWrite(JSON_F, p);
        assertEquals(aposToQuotes("3 {\"value0\":2} \"val\""), result);                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, p.getMatchCount());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testAllowMultipleMatchesWithoutPath$catena_1() throws Exception
    {
        String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}");
        JsonParser p0 = JSON_F.createParser(jsonString);
        FilteringParserDelegate p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   false, // includePath
                   true // multipleMatches - true
                );
        String result = readAndWrite(JSON_F, p);
        try{ assertEquals(aposToQuotes("3 {\"value0\":2} \"val\""), result);                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, p.getMatchCount());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonCore_21
@@@
Split test: com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testTokensSingleMatchWithPath
file: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Begin: Pos(65, 5)
End: Pos(118, 5)
Source: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Name: testTokensSingleMatchWithPath
Childs: [StatementAssertion<Begin: Pos(75, 9), End: Pos(75, 41)>,
StatementAssertion<Begin: Pos(76, 9), End: Pos(76, 40)>,
StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 69)>,
StatementAssertion<Begin: Pos(78, 9), End: Pos(78, 52)>,
StatementAssertion<Begin: Pos(79, 9), End: Pos(79, 51)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 59)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 66)>,
StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 51)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 51)>,
StatementAssertion<Begin: Pos(90, 9), End: Pos(90, 57)>,
StatementAssertion<Begin: Pos(91, 9), End: Pos(91, 64)>,
StatementAssertion<Begin: Pos(92, 9), End: Pos(92, 47)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 59)>,
StatementAssertion<Begin: Pos(96, 9), End: Pos(96, 47)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 57)>,
StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 50)>,
StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 43)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 63)>,
StatementAssertion<Begin: Pos(103, 9), End: Pos(103, 70)>,
StatementAssertion<Begin: Pos(104, 9), End: Pos(104, 56)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 41)>,
StatementAssertion<Begin: Pos(106, 9), End: Pos(106, 50)>,
StatementAssertion<Begin: Pos(108, 9), End: Pos(108, 57)>,
StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 64)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 57)>,
StatementAssertion<Begin: Pos(112, 9), End: Pos(112, 64)>,
StatementAssertion<Begin: Pos(115, 9), End: Pos(115, 40)>,
]
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_0() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        assertFalse(p.hasCurrentToken());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_1() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(p.getCurrentToken());                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_2() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_3() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(p.isExpectedStartObjectToken());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_4() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(p.isExpectedStartArrayToken());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_5() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        assertToken(JsonToken.START_OBJECT, p.nextToken());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_6() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_7() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(p.isExpectedStartObjectToken());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_8() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(p.isExpectedStartArrayToken());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_9() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.FIELD_NAME, p.nextToken());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_10() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_11() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("ob", p.getCurrentName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_12() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        assertToken(JsonToken.START_OBJECT, p.nextToken());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_13() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("ob", p.getCurrentName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_14() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.FIELD_NAME, p.nextToken());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_15() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("value", p.getCurrentName());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_16() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("value", p.getText());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_17() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_18() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_19() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(NumberType.INT, p.getNumberType());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_20() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, p.getIntValue());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_21() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("value", p.getCurrentName());                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_22() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.END_OBJECT, p.nextToken());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_23() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_24() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.END_OBJECT, p.nextToken());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_25() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        p.clearCurrentToken();
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        p.close();
    }
---
---
    @SuppressWarnings("resource")
    public void testTokensSingleMatchWithPath$catena_26() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

        try{ assertFalse(p.hasCurrentToken());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.getCurrentToken());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartObjectToken());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}
//      String result = readAndWrite(JSON_F, p);
//      assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(p.isExpectedStartObjectToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(p.isExpectedStartArrayToken());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
//        assertEquals("ob", p.getText());

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ob", p.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getText());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.INT, p.getNumberType());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.getIntValue());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", p.getCurrentName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        p.clearCurrentToken();
        assertNull(p.getCurrentToken());                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        
        p.close();
    }
---
@@@
Split test: com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testBasicSingleMatchFilteringWithPath
file: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Begin: Pos(50, 5)
End: Pos(63, 5)
Source: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Name: testBasicSingleMatchFilteringWithPath
Childs: [StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 65)>,
]
@@@
Split test: com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testSkippingForSingleWithPath
file: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Begin: Pos(120, 5)
End: Pos(136, 5)
Source: /tmp/JacksonCore_21/src/test/java//com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
Name: testSkippingForSingleWithPath
Childs: [StatementAssertion<Begin: Pos(132, 9), End: Pos(132, 59)>,
StatementAssertion<Begin: Pos(134, 9), End: Pos(134, 64)>,
StatementAssertion<Begin: Pos(135, 9), End: Pos(135, 34)>,
]
---
    @SuppressWarnings("resource")
    public void testSkippingForSingleWithPath$catena_0() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

//        assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        assertToken(JsonToken.START_OBJECT, p.nextToken());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        p.skipChildren();
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(p.nextToken());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testSkippingForSingleWithPath$catena_1() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

//        assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        p.skipChildren();
        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(p.nextToken());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("resource")
    public void testSkippingForSingleWithPath$catena_2() throws Exception
    {
        JsonParser p0 = JSON_F.createParser(SIMPLE);
        JsonParser p = new FilteringParserDelegate(p0,
               new NameMatchFilter("value"),
                   true, // includePath
                   false // multipleMatches
                );

//        assertEquals(aposToQuotes("{'ob':{'value':3}}"), result);

        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        p.skipChildren();
        try{ assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(p.nextToken());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonCore_9
@@@
Split test: com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextBytes
file: /tmp/JacksonCore_9/src/test/java//com/fasterxml/jackson/core/json/TestJsonParser.java
Begin: Pos(515, 12)
End: Pos(520, 5)
Source: /tmp/JacksonCore_9/src/test/java//com/fasterxml/jackson/core/json/TestJsonParser.java
Name: testGetValueAsTextBytes
Childs: [StatementAssertion<Begin: Pos(518, 9), End: Pos(518, 44)>,
StatementAssertion<Begin: Pos(519, 9), End: Pos(519, 43)>,
]
---
    public void testGetValueAsTextBytes$catena_0() throws Exception
    {
        JsonFactory f = new JsonFactory();
        _testGetValueAsText(f, true, false);                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testGetValueAsText(f, true, true);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetValueAsTextBytes$catena_1() throws Exception
    {
        JsonFactory f = new JsonFactory();
        try{ _testGetValueAsText(f, true, false);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        _testGetValueAsText(f, true, true);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextChars
file: /tmp/JacksonCore_9/src/test/java//com/fasterxml/jackson/core/json/TestJsonParser.java
Begin: Pos(522, 12)
End: Pos(527, 5)
Source: /tmp/JacksonCore_9/src/test/java//com/fasterxml/jackson/core/json/TestJsonParser.java
Name: testGetValueAsTextChars
Childs: [StatementAssertion<Begin: Pos(525, 9), End: Pos(525, 45)>,
StatementAssertion<Begin: Pos(526, 9), End: Pos(526, 44)>,
]
---
    public void testGetValueAsTextChars$catena_0() throws Exception
    {
        JsonFactory f = new JsonFactory();
        _testGetValueAsText(f, false, false);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testGetValueAsText(f, false, true);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetValueAsTextChars$catena_1() throws Exception
    {
        JsonFactory f = new JsonFactory();
        try{ _testGetValueAsText(f, false, false);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        _testGetValueAsText(f, false, true);                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonCore_19
@@@
Split test: com.fasterxml.jackson.core.json.TestNumericValues::testLongerFloatingPoint
file: /tmp/JacksonCore_19/src/test/java//com/fasterxml/jackson/core/json/TestNumericValues.java
Begin: Pos(557, 12)
End: Pos(576, 5)
Source: /tmp/JacksonCore_19/src/test/java//com/fasterxml/jackson/core/json/TestNumericValues.java
Name: testLongerFloatingPoint
Childs: [StatementAssertion<Begin: Pos(570, 9), End: Pos(570, 33)>,
StatementAssertion<Begin: Pos(574, 9), End: Pos(574, 33)>,
]
---
    public void testLongerFloatingPoint$catena_0() throws Exception
    {
        StringBuilder input = new StringBuilder();
        for (int i = 1; i < 201; i++) {
            input.append(1);
        }
        input.append(".0");
        final String DOC = input.toString();

        // test out with both Reader and ByteArrayInputStream
        JsonParser p;

        p = FACTORY.createParser(new StringReader(DOC));
        _testLongerFloat(p, DOC);                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        p.close();
        
        p = FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes("UTF-8")));
        try{ _testLongerFloat(p, DOC);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        p.close();
    }
---
---
    public void testLongerFloatingPoint$catena_1() throws Exception
    {
        StringBuilder input = new StringBuilder();
        for (int i = 1; i < 201; i++) {
            input.append(1);
        }
        input.append(".0");
        final String DOC = input.toString();

        // test out with both Reader and ByteArrayInputStream
        JsonParser p;

        p = FACTORY.createParser(new StringReader(DOC));
        try{ _testLongerFloat(p, DOC);                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        p.close();
        
        p = FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes("UTF-8")));
        _testLongerFloat(p, DOC);                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        p.close();
    }
---
--------------------
Run: JacksonCore_18
@@@
Split test: com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures::testTooBigBigDecimal
file: /tmp/JacksonCore_18/src/test/java//com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java
Begin: Pos(111, 12)
End: Pos(163, 5)
Source: /tmp/JacksonCore_18/src/test/java//com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java
Name: testTooBigBigDecimal
Childs: [StatementAssertion<Begin: Pos(154, 25), End: Pos(154, 82)>,
StatementAssertion<Begin: Pos(156, 25), End: Pos(156, 92)>,
StatementAssertion<Begin: Pos(157, 25), End: Pos(157, 60)>,
]
---
    public void testTooBigBigDecimal$catena_0() throws Exception
    {
        JsonFactory f = new JsonFactory();
        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);

        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]
        BigDecimal BIG = new BigDecimal("1E+9999");
        BigDecimal TOO_BIG = new BigDecimal("1E+10000");
        BigDecimal SMALL = new BigDecimal("1E-9999");
        BigDecimal TOO_SMALL = new BigDecimal("1E-10000");

        for (boolean useBytes : new boolean[] { false, true } ) {
            for (boolean asString : new boolean[] { false, true } ) {
                JsonGenerator g;
                
                if (useBytes) {
                    g = f.createGenerator(new ByteArrayOutputStream());
                } else {
                    g = f.createGenerator(new StringWriter());
                }
                if (asString) {
                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                }

                // first, ok cases:
                g.writeStartArray();
                g.writeNumber(BIG);
                g.writeNumber(SMALL);
                g.writeEndArray();
                g.close();

                // then invalid
                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {
                    if (useBytes) {
                        g = f.createGenerator(new ByteArrayOutputStream());
                    } else {
                        g = f.createGenerator(new StringWriter());
                    }
                    if (asString) {
                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                    }
                    try {
                        g.writeNumber(input);
                        fail("Should not have written without exception: "+input);                          /***** ORIGINAL ASSERTION IS HERE *****/
                    } catch (JsonGenerationException e) {
                        try{ verifyException(e, "Attempt to write plain `java.math.BigDecimal`");           }catch(Throwable __SHOULD_BE_IGNORED){}
                        try{ verifyException(e, "illegal scale");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                    }
                    g.close();
                }
            }
        }
    }
---
---
    public void testTooBigBigDecimal$catena_1() throws Exception
    {
        JsonFactory f = new JsonFactory();
        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);

        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]
        BigDecimal BIG = new BigDecimal("1E+9999");
        BigDecimal TOO_BIG = new BigDecimal("1E+10000");
        BigDecimal SMALL = new BigDecimal("1E-9999");
        BigDecimal TOO_SMALL = new BigDecimal("1E-10000");

        for (boolean useBytes : new boolean[] { false, true } ) {
            for (boolean asString : new boolean[] { false, true } ) {
                JsonGenerator g;
                
                if (useBytes) {
                    g = f.createGenerator(new ByteArrayOutputStream());
                } else {
                    g = f.createGenerator(new StringWriter());
                }
                if (asString) {
                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                }

                // first, ok cases:
                g.writeStartArray();
                g.writeNumber(BIG);
                g.writeNumber(SMALL);
                g.writeEndArray();
                g.close();

                // then invalid
                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {
                    if (useBytes) {
                        g = f.createGenerator(new ByteArrayOutputStream());
                    } else {
                        g = f.createGenerator(new StringWriter());
                    }
                    if (asString) {
                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                    }
                    try {
                        g.writeNumber(input);
                        try{ fail("Should not have written without exception: "+input);                     }catch(Throwable __SHOULD_BE_IGNORED){}
                    } catch (JsonGenerationException e) {
                        verifyException(e, "Attempt to write plain `java.math.BigDecimal`");                /***** ORIGINAL ASSERTION IS HERE *****/
                        try{ verifyException(e, "illegal scale");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                    }
                    g.close();
                }
            }
        }
    }
---
---
    public void testTooBigBigDecimal$catena_2() throws Exception
    {
        JsonFactory f = new JsonFactory();
        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);

        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]
        BigDecimal BIG = new BigDecimal("1E+9999");
        BigDecimal TOO_BIG = new BigDecimal("1E+10000");
        BigDecimal SMALL = new BigDecimal("1E-9999");
        BigDecimal TOO_SMALL = new BigDecimal("1E-10000");

        for (boolean useBytes : new boolean[] { false, true } ) {
            for (boolean asString : new boolean[] { false, true } ) {
                JsonGenerator g;
                
                if (useBytes) {
                    g = f.createGenerator(new ByteArrayOutputStream());
                } else {
                    g = f.createGenerator(new StringWriter());
                }
                if (asString) {
                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                }

                // first, ok cases:
                g.writeStartArray();
                g.writeNumber(BIG);
                g.writeNumber(SMALL);
                g.writeEndArray();
                g.close();

                // then invalid
                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {
                    if (useBytes) {
                        g = f.createGenerator(new ByteArrayOutputStream());
                    } else {
                        g = f.createGenerator(new StringWriter());
                    }
                    if (asString) {
                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);
                    }
                    try {
                        g.writeNumber(input);
                        try{ fail("Should not have written without exception: "+input);                     }catch(Throwable __SHOULD_BE_IGNORED){}
                    } catch (JsonGenerationException e) {
                        try{ verifyException(e, "Attempt to write plain `java.math.BigDecimal`");           }catch(Throwable __SHOULD_BE_IGNORED){}
                        verifyException(e, "illegal scale");                                                /***** ORIGINAL ASSERTION IS HERE *****/
                    }
                    g.close();
                }
            }
        }
    }
---
--------------------
Run: JacksonCore_15
@@@
Split test: com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testNotAllowMultipleMatches
file: /tmp/JacksonCore_15/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Begin: Pos(107, 5)
End: Pos(119, 5)
Source: /tmp/JacksonCore_15/src/test/java//com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java
Name: testNotAllowMultipleMatches
Childs: [StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 48)>,
]
--------------------
Run: JacksonCore_12
@@@
Split test: com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader
file: /tmp/JacksonCore_12/src/test/java//com/fasterxml/jackson/core/json/LocationInObjectTest.java
Begin: Pos(54, 12)
End: Pos(98, 5)
Source: /tmp/JacksonCore_12/src/test/java//com/fasterxml/jackson/core/json/LocationInObjectTest.java
Name: testOffsetWithObjectFieldsUsingReader
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 60)>,
StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 58)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 63)>,
StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 60)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 63)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 46)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 64)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 60)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 64)>,
StatementAssertion<Begin: Pos(73, 9), End: Pos(73, 46)>,
StatementAssertion<Begin: Pos(74, 9), End: Pos(74, 64)>,
StatementAssertion<Begin: Pos(75, 9), End: Pos(75, 60)>,
StatementAssertion<Begin: Pos(76, 9), End: Pos(76, 64)>,
StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 58)>,
StatementAssertion<Begin: Pos(79, 9), End: Pos(79, 46)>,
StatementAssertion<Begin: Pos(80, 9), End: Pos(80, 64)>,
StatementAssertion<Begin: Pos(81, 9), End: Pos(81, 59)>,
StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 64)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 58)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 64)>,
StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 59)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 64)>,
StatementAssertion<Begin: Pos(89, 9), End: Pos(89, 57)>,
StatementAssertion<Begin: Pos(91, 9), End: Pos(91, 46)>,
StatementAssertion<Begin: Pos(92, 9), End: Pos(92, 64)>,
StatementAssertion<Begin: Pos(93, 9), End: Pos(93, 64)>,
StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 64)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 58)>,
]
---
    public void testOffsetWithObjectFieldsUsingReader$catena_0() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        assertEquals(JsonToken.START_OBJECT, p.nextToken());                                                /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_1() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_2() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1L, p.getTokenLocation().getCharOffset());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_3() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_4() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(6L, p.getTokenLocation().getCharOffset());                                             /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_5() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("f2", p.nextFieldName());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_6() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(11L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_7() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.START_OBJECT, p.nextValue());                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_8() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(16L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_9() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("f3", p.nextFieldName());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_10() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(17L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_11() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_12() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(22L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_13() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.END_OBJECT, p.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_14() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("f4", p.nextFieldName());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_15() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(28L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_16() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.START_ARRAY, p.nextValue());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_17() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(33L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_18() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_19() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(34L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_20() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_21() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(39L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_22() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.END_ARRAY, p.nextToken());                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_23() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("f5", p.nextFieldName());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_24() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(46L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_25() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_26() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(51L, p.getTokenLocation().getCharOffset());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithObjectFieldsUsingReader$catena_27() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray();
        //            1      6      11    16 17    22      28    33 34 39      46    51
        JsonParser p = f.createParser(c);

        try{ assertEquals(JsonToken.START_OBJECT, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.FIELD_NAME, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6L, p.getTokenLocation().getCharOffset());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f2", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(11L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_OBJECT, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f3", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(17L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_STRING, p.nextValue());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(22L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_OBJECT, p.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f4", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(28L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.START_ARRAY, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(33L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_TRUE, p.nextValue());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(34L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(JsonToken.VALUE_FALSE, p.nextValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(39L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.END_ARRAY, p.nextToken());                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("f5", p.nextFieldName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(46L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(51L, p.getTokenLocation().getCharOffset());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(JsonToken.END_OBJECT, p.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        p.close();
    }
---
--------------------
Run: JacksonCore_16
@@@
Split test: com.fasterxml.jackson.core.json.ParserSequenceTest::testInitialized
file: /tmp/JacksonCore_16/src/test/java//com/fasterxml/jackson/core/json/ParserSequenceTest.java
Begin: Pos(50, 12)
End: Pos(64, 5)
Source: /tmp/JacksonCore_16/src/test/java//com/fasterxml/jackson/core/json/ParserSequenceTest.java
Name: testInitialized
Childs: [StatementAssertion<Begin: Pos(55, 9), End: Pos(55, 64)>,
StatementAssertion<Begin: Pos(56, 9), End: Pos(56, 64)>,
StatementAssertion<Begin: Pos(59, 9), End: Pos(59, 65)>,
StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 43)>,
StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 65)>,
StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 43)>,
]
---
    public void testInitialized$catena_0() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        seq.close();
    }
---
---
    public void testInitialized$catena_1() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        seq.close();
    }
---
---
    public void testInitialized$catena_2() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        seq.close();
    }
---
---
    public void testInitialized$catena_3() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, seq.getIntValue());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        seq.close();
    }
---
---
    public void testInitialized$catena_4() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        seq.close();
    }
---
---
    public void testInitialized$catena_5() throws Exception
    {
        JsonParser p1 = JSON_FACTORY.createParser("1 2");
        JsonParser p2 = JSON_FACTORY.createParser("3 false");
        // consume '1', move to '2'
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, seq.getIntValue());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, seq.getIntValue());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        seq.close();
    }
---
--------------------
Run: JacksonCore_10
@@@
Split test: com.fasterxml.jackson.core.sym.TestByteBasedSymbols::testIssue207
file: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java
Begin: Pos(102, 12)
End: Pos(121, 5)
Source: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java
Name: testIssue207
Childs: []
@@@
Split test: com.fasterxml.jackson.core.sym.TestSymbolTables::testCollisionsWithBytesNew187b
file: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Begin: Pos(303, 12)
End: Pos(327, 5)
Source: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Name: testCollisionsWithBytesNew187b
Childs: [StatementAssertion<Begin: Pos(314, 9), End: Pos(314, 44)>,
StatementAssertion<Begin: Pos(316, 9), End: Pos(316, 51)>,
StatementAssertion<Begin: Pos(320, 9), End: Pos(320, 51)>,
StatementAssertion<Begin: Pos(322, 9), End: Pos(322, 53)>,
StatementAssertion<Begin: Pos(324, 9), End: Pos(324, 52)>,
StatementAssertion<Begin: Pos(326, 9), End: Pos(326, 51)>,
]
---
    public void testCollisionsWithBytesNew187b$catena_0() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        assertEquals(COUNT, symbols.size());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        try{ assertEquals(5402, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary higher than usual, above 25%
        try{ assertEquals(2744, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(1834, symbols.tertiaryCount());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        // with a bit of spillover
        try{ assertEquals(20, symbols.spilloverCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCollisionsWithBytesNew187b$catena_1() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        
        assertEquals(16384, symbols.bucketCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        try{ assertEquals(5402, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary higher than usual, above 25%
        try{ assertEquals(2744, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(1834, symbols.tertiaryCount());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        // with a bit of spillover
        try{ assertEquals(20, symbols.spilloverCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCollisionsWithBytesNew187b$catena_2() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        assertEquals(5402, symbols.primaryCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        // secondary higher than usual, above 25%
        try{ assertEquals(2744, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(1834, symbols.tertiaryCount());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        // with a bit of spillover
        try{ assertEquals(20, symbols.spilloverCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCollisionsWithBytesNew187b$catena_3() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        try{ assertEquals(5402, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary higher than usual, above 25%
        assertEquals(2744, symbols.secondaryCount());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        // and most of remaining in tertiary
        try{ assertEquals(1834, symbols.tertiaryCount());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        // with a bit of spillover
        try{ assertEquals(20, symbols.spilloverCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCollisionsWithBytesNew187b$catena_4() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        try{ assertEquals(5402, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary higher than usual, above 25%
        try{ assertEquals(2744, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        assertEquals(1834, symbols.tertiaryCount());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        // with a bit of spillover
        try{ assertEquals(20, symbols.spilloverCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCollisionsWithBytesNew187b$catena_5() throws IOException
    {
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 10000;
        for (int i = 0; i < COUNT; ++i) {
            String id = String.valueOf(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // fragile, but essential to verify low collision counts;
        // here bit low primary, 55% 
        try{ assertEquals(5402, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary higher than usual, above 25%
        try{ assertEquals(2744, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(1834, symbols.tertiaryCount());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        // with a bit of spillover
        assertEquals(20, symbols.spilloverCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.sym.TestSymbolTables::testSyntheticWithBytesNew
file: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Begin: Pos(64, 12)
End: Pos(89, 5)
Source: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Name: testSyntheticWithBytesNew
Childs: [StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 44)>,
StatementAssertion<Begin: Pos(78, 9), End: Pos(78, 51)>,
StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 51)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 53)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 51)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 50)>,
]
---
    public void testSyntheticWithBytesNew$catena_0() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        assertEquals(COUNT, symbols.size());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        try{ assertEquals(8534, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary between 10-20%
        try{ assertEquals(2534, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(932, symbols.tertiaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // so that spill-over is empty or close to
        try{ assertEquals(0, symbols.spilloverCount());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSyntheticWithBytesNew$catena_1() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(16384, symbols.bucketCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        try{ assertEquals(8534, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary between 10-20%
        try{ assertEquals(2534, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(932, symbols.tertiaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // so that spill-over is empty or close to
        try{ assertEquals(0, symbols.spilloverCount());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSyntheticWithBytesNew$catena_2() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        assertEquals(8534, symbols.primaryCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        // secondary between 10-20%
        try{ assertEquals(2534, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(932, symbols.tertiaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // so that spill-over is empty or close to
        try{ assertEquals(0, symbols.spilloverCount());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSyntheticWithBytesNew$catena_3() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        try{ assertEquals(8534, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary between 10-20%
        assertEquals(2534, symbols.secondaryCount());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        // and most of remaining in tertiary
        try{ assertEquals(932, symbols.tertiaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // so that spill-over is empty or close to
        try{ assertEquals(0, symbols.spilloverCount());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSyntheticWithBytesNew$catena_4() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        try{ assertEquals(8534, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary between 10-20%
        try{ assertEquals(2534, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        assertEquals(932, symbols.tertiaryCount());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        // so that spill-over is empty or close to
        try{ assertEquals(0, symbols.spilloverCount());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSyntheticWithBytesNew$catena_5() throws IOException
    {
        // pass seed, to keep results consistent:
        final int SEED = 33333;
        ByteQuadsCanonicalizer symbols =
                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());

        final int COUNT = 12000;
        for (int i = 0; i < COUNT; ++i) {
            String id = fieldNameFor(i);
            int[] quads = calcQuads(id.getBytes("UTF-8"));
            symbols.addName(id, quads, quads.length);
        }
        try{ assertEquals(COUNT, symbols.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16384, symbols.bucketCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        // fragile, but essential to verify low collision counts;
        // anywhere between 70-80% primary matches
        try{ assertEquals(8534, symbols.primaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // secondary between 10-20%
        try{ assertEquals(2534, symbols.secondaryCount());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // and most of remaining in tertiary
        try{ assertEquals(932, symbols.tertiaryCount());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        // so that spill-over is empty or close to
        assertEquals(0, symbols.spilloverCount());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.core.sym.TestSymbolTables::testShortNameCollisionsDirectNew
file: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Begin: Pos(460, 12)
End: Pos(484, 5)
Source: /tmp/JacksonCore_10/src/test/java//com/fasterxml/jackson/core/sym/TestSymbolTables.java
Name: testShortNameCollisionsDirectNew
Childs: [StatementAssertion<Begin: Pos(471, 13), End: Pos(471, 48)>,
StatementAssertion<Begin: Pos(473, 13), End: Pos(473, 54)>,
StatementAssertion<Begin: Pos(476, 13), End: Pos(476, 54)>,
StatementAssertion<Begin: Pos(477, 13), End: Pos(477, 56)>,
StatementAssertion<Begin: Pos(478, 13), End: Pos(478, 54)>,
StatementAssertion<Begin: Pos(479, 13), End: Pos(479, 54)>,
StatementAssertion<Begin: Pos(481, 13), End: Pos(482, 124)>,
]
---
    public void testShortNameCollisionsDirectNew$catena_0() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            assertEquals(COUNT, symbols.size());                                                                                /***** ORIGINAL ASSERTION IS HERE *****/

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_1() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            assertEquals(1024, symbols.bucketCount());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_2() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            assertEquals(564, symbols.primaryCount());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_3() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(122, symbols.secondaryCount());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_4() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(14, symbols.tertiaryCount());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_5() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(0, symbols.spilloverCount());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

            try{ assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShortNameCollisionsDirectNew$catena_6() throws IOException
    {
        final int COUNT = 700;
        {
            ByteQuadsCanonicalizer symbols =
                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());
            for (int i = 0; i < COUNT; ++i) {
                String id = String.valueOf((char) i);
                int[] quads = calcQuads(id.getBytes("UTF-8"));
                symbols.addName(id, quads, quads.length);
            }
            try{ assertEquals(COUNT, symbols.size());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

            try{ assertEquals(1024, symbols.bucketCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            // Primary is good, but secondary spills cluster in nasty way...
            try{ assertEquals(564, symbols.primaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(122, symbols.secondaryCount());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(14, symbols.tertiaryCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(0, symbols.spilloverCount());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

            assertEquals(COUNT,
                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());    /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonCore_2
@@@
Split test: com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersBytes
file: /tmp/JacksonCore_2/src/test/java//com/fasterxml/jackson/core/json/TestParserErrorHandling.java
Begin: Pos(21, 12)
End: Pos(23, 5)
Source: /tmp/JacksonCore_2/src/test/java//com/fasterxml/jackson/core/json/TestParserErrorHandling.java
Name: testMangledNumbersBytes
Childs: [StatementAssertion<Begin: Pos(22, 9), End: Pos(22, 34)>,
]
@@@
Split test: com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersChars
file: /tmp/JacksonCore_2/src/test/java//com/fasterxml/jackson/core/json/TestParserErrorHandling.java
Begin: Pos(25, 12)
End: Pos(27, 5)
Source: /tmp/JacksonCore_2/src/test/java//com/fasterxml/jackson/core/json/TestParserErrorHandling.java
Name: testMangledNumbersChars
Childs: [StatementAssertion<Begin: Pos(26, 9), End: Pos(26, 35)>,
]
--------------------
Run: JacksonCore_3
@@@
Split test: com.fasterxml.jackson.core.json.TestLocation::testOffsetWithInputOffset
file: /tmp/JacksonCore_3/src/test/java//com/fasterxml/jackson/core/json/TestLocation.java
Begin: Pos(55, 12)
End: Pos(80, 5)
Source: /tmp/JacksonCore_3/src/test/java//com/fasterxml/jackson/core/json/TestLocation.java
Name: testOffsetWithInputOffset
Childs: [StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 59)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 46)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 47)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 41)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 43)>,
StatementAssertion<Begin: Pos(74, 9), End: Pos(74, 46)>,
StatementAssertion<Begin: Pos(75, 9), End: Pos(75, 47)>,
StatementAssertion<Begin: Pos(76, 9), End: Pos(76, 41)>,
StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 43)>,
]
---
    public void testOffsetWithInputOffset$catena_0() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        assertToken(JsonToken.START_OBJECT, p.nextToken());                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_1() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        assertEquals(0L, loc.getByteOffset());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_2() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1L, loc.getCharOffset());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_3() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, loc.getLineNr());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_4() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, loc.getColumnNr());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_5() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        assertEquals(1L, loc.getByteOffset());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_6() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(-1L, loc.getCharOffset());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_7() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, loc.getLineNr());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        p.close();
    }
---
---
    public void testOffsetWithInputOffset$catena_8() throws Exception
    {
        final JsonFactory f = new JsonFactory();
        JsonLocation loc;
        JsonParser p;
        // 3 spaces before, 2 after, just for padding
        byte[] b = "   { }  ".getBytes("UTF-8");

        // and then peel them off
        p = f.createParser(b, 3, b.length-5);
        try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        loc = p.getTokenLocation();
        try{ assertEquals(0L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getColumnNr());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        
        loc = p.getCurrentLocation();
        try{ assertEquals(1L, loc.getByteOffset());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(-1L, loc.getCharOffset());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, loc.getLineNr());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, loc.getColumnNr());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        p.close();
    }
---
--------------------
Run: JacksonCore_4
@@@
Split test: com.fasterxml.jackson.core.util.TestTextBuffer::testExpand
file: /tmp/JacksonCore_4/src/test/java//com/fasterxml/jackson/core/util/TestTextBuffer.java
Begin: Pos(67, 14)
End: Pos(79, 7)
Source: /tmp/JacksonCore_4/src/test/java//com/fasterxml/jackson/core/util/TestTextBuffer.java
Name: testExpand
Childs: [StatementAssertion<Begin: Pos(76, 19), End: Pos(76, 103)>,
]
--------------------
Run: JacksonCore_1
@@@
Split test: com.fasterxml.jackson.core.json.TestParserNonStandard::testAllowNaN
file: /tmp/JacksonCore_1/src/test/java//com/fasterxml/jackson/core/json/TestParserNonStandard.java
Begin: Pos(62, 12)
End: Pos(65, 5)
Source: /tmp/JacksonCore_1/src/test/java//com/fasterxml/jackson/core/json/TestParserNonStandard.java
Name: testAllowNaN
Childs: [StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 29)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 28)>,
]
---
    public void testAllowNaN$catena_0() throws Exception {
        _testAllowNaN(false);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testAllowNaN(true);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testAllowNaN$catena_1() throws Exception {
        try{ _testAllowNaN(false);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        _testAllowNaN(true);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonCore_14
@@@
Split test: com.fasterxml.jackson.core.io.TestIOContext::testAllocations
file: /tmp/JacksonCore_14/src/test/java//com/fasterxml/jackson/core/io/TestIOContext.java
Begin: Pos(9, 12)
End: Pos(91, 5)
Source: /tmp/JacksonCore_14/src/test/java//com/fasterxml/jackson/core/io/TestIOContext.java
Name: testAllocations
Childs: [StatementAssertion<Begin: Pos(16, 9), End: Pos(16, 48)>,
StatementAssertion<Begin: Pos(21, 13), End: Pos(21, 46)>,
StatementAssertion<Begin: Pos(27, 13), End: Pos(27, 56)>,
StatementAssertion<Begin: Pos(34, 9), End: Pos(34, 55)>,
StatementAssertion<Begin: Pos(38, 13), End: Pos(38, 46)>,
StatementAssertion<Begin: Pos(43, 13), End: Pos(43, 56)>,
StatementAssertion<Begin: Pos(49, 9), End: Pos(49, 47)>,
StatementAssertion<Begin: Pos(53, 13), End: Pos(53, 46)>,
StatementAssertion<Begin: Pos(58, 13), End: Pos(58, 56)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 48)>,
StatementAssertion<Begin: Pos(68, 13), End: Pos(68, 46)>,
StatementAssertion<Begin: Pos(73, 13), End: Pos(73, 56)>,
StatementAssertion<Begin: Pos(79, 9), End: Pos(79, 53)>,
StatementAssertion<Begin: Pos(83, 13), End: Pos(83, 46)>,
StatementAssertion<Begin: Pos(88, 13), End: Pos(88, 56)>,
]
---
    public void testAllocations$catena_0() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        assertNotNull(ctxt.allocReadIOBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_1() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            verifyException(e, "second time");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_2() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            verifyException(e, "smaller than original");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_3() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        assertNotNull(ctxt.allocWriteEncodingBuffer());                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_4() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            verifyException(e, "second time");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_5() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            verifyException(e, "smaller than original");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_6() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        assertNotNull(ctxt.allocTokenBuffer());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_7() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            verifyException(e, "second time");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_8() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            verifyException(e, "smaller than original");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_9() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        assertNotNull(ctxt.allocConcatBuffer());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_10() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            verifyException(e, "second time");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_11() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            verifyException(e, "smaller than original");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_12() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        assertNotNull(ctxt.allocNameCopyBuffer(100));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_13() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            verifyException(e, "second time");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
---
    public void testAllocations$catena_14() throws Exception
    {
        IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true);

        /* I/O Read buffer */

        // First succeeds:
        try{ assertNotNull(ctxt.allocReadIOBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // second fails
        try {
            ctxt.allocReadIOBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // Also: can't succeed with different buffer
        try {
            ctxt.releaseReadIOBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // but call with null is a NOP for convenience
        ctxt.releaseReadIOBuffer(null);

        /* I/O Write buffer */

        try{ assertNotNull(ctxt.allocWriteEncodingBuffer());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocWriteEncodingBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseWriteEncodingBuffer(new byte[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseWriteEncodingBuffer(null);

        /* Token (read) buffer */

        try{ assertNotNull(ctxt.allocTokenBuffer());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocTokenBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseTokenBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseTokenBuffer(null);

        /* Concat (write?) buffer */

        try{ assertNotNull(ctxt.allocConcatBuffer());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocConcatBuffer();
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseConcatBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            try{ verifyException(e, "smaller than original");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        ctxt.releaseConcatBuffer(null);

        /* NameCopy (write?) buffer */

        try{ assertNotNull(ctxt.allocNameCopyBuffer(100));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            ctxt.allocNameCopyBuffer(100);
        } catch (IllegalStateException e) {
            try{ verifyException(e, "second time");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try {
            ctxt.releaseNameCopyBuffer(new char[1]);
        } catch (IllegalArgumentException e) {
            verifyException(e, "smaller than original");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        }
        ctxt.releaseNameCopyBuffer(null);
    }
---
--------------------
Run: JacksonCore_24
@@@
Split test: com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToLongFailing
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
Begin: Pos(177, 12)
End: Pos(208, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
Name: testToLongFailing
Childs: [StatementAssertion<Begin: Pos(184, 9), End: Pos(184, 63)>,
StatementAssertion<Begin: Pos(185, 9), End: Pos(185, 64)>,
StatementAssertion<Begin: Pos(186, 9), End: Pos(186, 50)>,
StatementAssertion<Begin: Pos(187, 9), End: Pos(187, 46)>,
StatementAssertion<Begin: Pos(190, 13), End: Pos(190, 36)>,
StatementAssertion<Begin: Pos(192, 13), End: Pos(192, 55)>,
StatementAssertion<Begin: Pos(193, 13), End: Pos(193, 71)>,
StatementAssertion<Begin: Pos(194, 13), End: Pos(194, 55)>,
StatementAssertion<Begin: Pos(198, 9), End: Pos(198, 63)>,
StatementAssertion<Begin: Pos(199, 9), End: Pos(199, 52)>,
StatementAssertion<Begin: Pos(202, 13), End: Pos(202, 36)>,
StatementAssertion<Begin: Pos(204, 13), End: Pos(204, 55)>,
StatementAssertion<Begin: Pos(205, 13), End: Pos(205, 71)>,
StatementAssertion<Begin: Pos(206, 13), End: Pos(206, 55)>,
]
---
    public void testToLongFailing$catena_0() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_1() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_2() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(big, p.getBigIntegerValue());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_3() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(big, p.getNumberValue());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_4() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_5() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of long");                                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_6() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_7() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Long.TYPE, e.getTargetType());                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_8() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_9() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(small, p.getBigIntegerValue());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_10() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_11() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of long");                                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_12() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToLongFailing$catena_13() throws Exception
    {
        AsyncReaderWrapper p;

        // BigInteger -> error
        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getBigIntegerValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getNumberValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.TYPE, e.getTargetType());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getBigIntegerValue());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getLongValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of long");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Long.TYPE, e.getTargetType());                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
@@@
Split test: com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToIntFailing
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
Begin: Pos(63, 12)
End: Pos(141, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
Name: testToIntFailing
Childs: [StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 63)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 44)>,
StatementAssertion<Begin: Pos(74, 13), End: Pos(74, 36)>,
StatementAssertion<Begin: Pos(76, 13), End: Pos(76, 54)>,
StatementAssertion<Begin: Pos(77, 13), End: Pos(77, 71)>,
StatementAssertion<Begin: Pos(78, 13), End: Pos(78, 58)>,
StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 63)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 62)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 46)>,
StatementAssertion<Begin: Pos(87, 13), End: Pos(87, 36)>,
StatementAssertion<Begin: Pos(89, 13), End: Pos(89, 54)>,
StatementAssertion<Begin: Pos(90, 13), End: Pos(90, 71)>,
StatementAssertion<Begin: Pos(91, 13), End: Pos(91, 58)>,
StatementAssertion<Begin: Pos(96, 9), End: Pos(96, 65)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 55)>,
StatementAssertion<Begin: Pos(100, 13), End: Pos(100, 36)>,
StatementAssertion<Begin: Pos(102, 13), End: Pos(102, 54)>,
StatementAssertion<Begin: Pos(103, 13), End: Pos(103, 71)>,
StatementAssertion<Begin: Pos(104, 13), End: Pos(104, 58)>,
StatementAssertion<Begin: Pos(107, 9), End: Pos(107, 65)>,
StatementAssertion<Begin: Pos(108, 9), End: Pos(108, 57)>,
StatementAssertion<Begin: Pos(111, 13), End: Pos(111, 36)>,
StatementAssertion<Begin: Pos(113, 13), End: Pos(113, 54)>,
StatementAssertion<Begin: Pos(114, 13), End: Pos(114, 71)>,
StatementAssertion<Begin: Pos(115, 13), End: Pos(115, 58)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 63)>,
StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 70)>,
StatementAssertion<Begin: Pos(124, 13), End: Pos(124, 36)>,
StatementAssertion<Begin: Pos(126, 13), End: Pos(126, 54)>,
StatementAssertion<Begin: Pos(127, 13), End: Pos(127, 71)>,
StatementAssertion<Begin: Pos(128, 13), End: Pos(128, 58)>,
StatementAssertion<Begin: Pos(131, 9), End: Pos(131, 63)>,
StatementAssertion<Begin: Pos(132, 9), End: Pos(132, 72)>,
StatementAssertion<Begin: Pos(135, 13), End: Pos(135, 36)>,
StatementAssertion<Begin: Pos(137, 13), End: Pos(137, 54)>,
StatementAssertion<Begin: Pos(138, 13), End: Pos(138, 71)>,
StatementAssertion<Begin: Pos(139, 13), End: Pos(139, 58)>,
]
---
    public void testToIntFailing$catena_0() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_1() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(big, p.getLongValue());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_2() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_3() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_4() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_5() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_6() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_7() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Long.valueOf(small), p.getNumberValue());                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_8() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(small, p.getLongValue());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_9() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_10() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_11() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_12() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_13() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_14() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals((double) big, p.getDoubleValue());                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_15() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_16() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_17() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_18() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_19() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_20() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals((double) small, p.getDoubleValue());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_21() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_22() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_23() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_24() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_25() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_26() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_27() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_28() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_29() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_30() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_31() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_32() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_33() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_34() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            verifyException(e, "out of range of int");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_35() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                     /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testToIntFailing$catena_36() throws Exception
    {
        AsyncReaderWrapper p;

        // long -> error
        long big = 1L + Integer.MAX_VALUE;
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(big, p.getLongValue());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        long small = -1L + Integer.MIN_VALUE;
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(small, p.getLongValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // double -> error
        p = createParser(String.valueOf(big)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) big, p.getDoubleValue());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small)+".0");
        try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals((double) small, p.getDoubleValue());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // BigInteger -> error
        p = createParser(String.valueOf(big));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Integer.TYPE, e.getTargetType());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        p = createParser(String.valueOf(small));
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try {
            p.getIntValue();
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (InputCoercionException e) {
            try{ verifyException(e, "out of range of int");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Integer.TYPE, e.getTargetType());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberCoercionTest::testToLongFailing
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberCoercionTest.java
Begin: Pos(175, 5)
End: Pos(209, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberCoercionTest.java
Name: testToLongFailing
Childs: [StatementAssertion<Begin: Pos(184, 13), End: Pos(184, 67)>,
StatementAssertion<Begin: Pos(185, 13), End: Pos(185, 68)>,
StatementAssertion<Begin: Pos(186, 13), End: Pos(186, 54)>,
StatementAssertion<Begin: Pos(187, 13), End: Pos(187, 50)>,
StatementAssertion<Begin: Pos(190, 17), End: Pos(190, 40)>,
StatementAssertion<Begin: Pos(192, 17), End: Pos(192, 59)>,
StatementAssertion<Begin: Pos(193, 17), End: Pos(193, 75)>,
StatementAssertion<Begin: Pos(194, 17), End: Pos(194, 59)>,
StatementAssertion<Begin: Pos(198, 13), End: Pos(198, 67)>,
StatementAssertion<Begin: Pos(199, 13), End: Pos(199, 56)>,
StatementAssertion<Begin: Pos(202, 17), End: Pos(202, 40)>,
StatementAssertion<Begin: Pos(204, 17), End: Pos(204, 59)>,
StatementAssertion<Begin: Pos(205, 17), End: Pos(205, 75)>,
StatementAssertion<Begin: Pos(206, 17), End: Pos(206, 59)>,
]
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_0() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_1() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                        /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_2() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(big, p.getBigIntegerValue());                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_3() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(big, p.getNumberValue());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_4() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_5() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of long");                                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_6() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_7() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Long.TYPE, e.getTargetType());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_8() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_9() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(small, p.getBigIntegerValue());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_10() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_11() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of long");                                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_12() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToLongFailing$catena_13() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // BigInteger -> error
            BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getBigIntegerValue());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getNumberValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Long.TYPE, e.getTargetType());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getBigIntegerValue());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Long.TYPE, e.getTargetType());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberCoercionTest::testToIntFailing
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberCoercionTest.java
Begin: Pos(56, 5)
End: Pos(137, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberCoercionTest.java
Name: testToIntFailing
Childs: [StatementAssertion<Begin: Pos(65, 13), End: Pos(65, 67)>,
StatementAssertion<Begin: Pos(66, 13), End: Pos(66, 48)>,
StatementAssertion<Begin: Pos(69, 17), End: Pos(69, 40)>,
StatementAssertion<Begin: Pos(71, 17), End: Pos(71, 58)>,
StatementAssertion<Begin: Pos(72, 17), End: Pos(72, 75)>,
StatementAssertion<Begin: Pos(73, 17), End: Pos(73, 62)>,
StatementAssertion<Begin: Pos(77, 13), End: Pos(77, 67)>,
StatementAssertion<Begin: Pos(78, 13), End: Pos(78, 66)>,
StatementAssertion<Begin: Pos(79, 13), End: Pos(79, 50)>,
StatementAssertion<Begin: Pos(82, 17), End: Pos(82, 40)>,
StatementAssertion<Begin: Pos(84, 17), End: Pos(84, 58)>,
StatementAssertion<Begin: Pos(85, 17), End: Pos(85, 75)>,
StatementAssertion<Begin: Pos(86, 17), End: Pos(86, 62)>,
StatementAssertion<Begin: Pos(91, 13), End: Pos(91, 69)>,
StatementAssertion<Begin: Pos(92, 13), End: Pos(92, 59)>,
StatementAssertion<Begin: Pos(95, 17), End: Pos(95, 40)>,
StatementAssertion<Begin: Pos(97, 17), End: Pos(97, 58)>,
StatementAssertion<Begin: Pos(98, 17), End: Pos(98, 75)>,
StatementAssertion<Begin: Pos(99, 17), End: Pos(99, 62)>,
StatementAssertion<Begin: Pos(102, 13), End: Pos(102, 69)>,
StatementAssertion<Begin: Pos(103, 13), End: Pos(103, 61)>,
StatementAssertion<Begin: Pos(106, 17), End: Pos(106, 40)>,
StatementAssertion<Begin: Pos(108, 17), End: Pos(108, 58)>,
StatementAssertion<Begin: Pos(109, 17), End: Pos(109, 75)>,
StatementAssertion<Begin: Pos(110, 17), End: Pos(110, 62)>,
StatementAssertion<Begin: Pos(115, 13), End: Pos(115, 67)>,
StatementAssertion<Begin: Pos(116, 13), End: Pos(116, 74)>,
StatementAssertion<Begin: Pos(119, 17), End: Pos(119, 40)>,
StatementAssertion<Begin: Pos(121, 17), End: Pos(121, 58)>,
StatementAssertion<Begin: Pos(122, 17), End: Pos(122, 75)>,
StatementAssertion<Begin: Pos(123, 17), End: Pos(123, 62)>,
StatementAssertion<Begin: Pos(126, 13), End: Pos(126, 67)>,
StatementAssertion<Begin: Pos(127, 13), End: Pos(127, 76)>,
StatementAssertion<Begin: Pos(130, 17), End: Pos(130, 40)>,
StatementAssertion<Begin: Pos(132, 17), End: Pos(132, 58)>,
StatementAssertion<Begin: Pos(133, 17), End: Pos(133, 75)>,
StatementAssertion<Begin: Pos(134, 17), End: Pos(134, 62)>,
]
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_0() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_1() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(big, p.getLongValue());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_2() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_3() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_4() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_5() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_6() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_7() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(Long.valueOf(small), p.getNumberValue());                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_8() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(small, p.getLongValue());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_9() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_10() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_11() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_12() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_13() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                       /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_14() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals((double) big, p.getDoubleValue());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_15() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_16() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_17() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_18() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_19() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                       /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_20() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals((double) small, p.getDoubleValue());                                               /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_21() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_22() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_23() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_24() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_25() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_26() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                                  /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_27() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_28() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_29() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_30() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_31() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_32() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                                /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_33() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Should not pass");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_34() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of int");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_35() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                                 /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    @SuppressWarnings("resource")
    public void testToIntFailing$catena_36() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            JsonParser p;

            // long -> error
            long big = 1L + Integer.MAX_VALUE;
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(big, p.getLongValue());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            long small = -1L + Integer.MIN_VALUE;
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(Long.valueOf(small), p.getNumberValue());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(small, p.getLongValue());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // double -> error
            p = createParser(mode, String.valueOf(big)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) big, p.getDoubleValue());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small)+".0");
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals((double) small, p.getDoubleValue());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }

            // BigInteger -> error
            p = createParser(mode, String.valueOf(big));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(big), p.getBigIntegerValue());                             }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(Integer.TYPE, e.getTargetType());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p = createParser(mode, String.valueOf(small));
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(BigInteger.valueOf(small), p.getBigIntegerValue());                           }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Should not pass");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of int");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());                            }catch(Throwable __SHOULD_BE_IGNORED){}
                assertEquals(Integer.TYPE, e.getTargetType());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousLongOverflow
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Begin: Pos(64, 12)
End: Pos(81, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Name: testMaliciousLongOverflow
Childs: [StatementAssertion<Begin: Pos(69, 17), End: Pos(69, 66)>,
StatementAssertion<Begin: Pos(70, 17), End: Pos(70, 71)>,
StatementAssertion<Begin: Pos(73, 21), End: Pos(73, 44)>,
StatementAssertion<Begin: Pos(75, 21), End: Pos(75, 63)>,
StatementAssertion<Begin: Pos(76, 21), End: Pos(76, 78)>,
]
---
    public void testMaliciousLongOverflow$catena_0() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                assertToken(JsonToken.START_ARRAY, p.nextToken());                                          /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getLongValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of long");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousLongOverflow$catena_1() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                     /***** ORIGINAL ASSERTION IS HERE *****/
                try {
                    p.getLongValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of long");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousLongOverflow$catena_2() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getLongValue();
                    fail("Should not pass");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of long");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousLongOverflow$catena_3() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getLongValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    verifyException(e, "out of range of long");                                             /***** ORIGINAL ASSERTION IS HERE *****/
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousLongOverflow$catena_4() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getLongValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of long");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                    verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                              /***** ORIGINAL ASSERTION IS HERE *****/
                }
                p.close();
            }
        }
    }    
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberOverflowTest::testSimpleLongOverflow
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Begin: Pos(27, 12)
End: Pos(58, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Name: testSimpleLongOverflow
Childs: [StatementAssertion<Begin: Pos(42, 17), End: Pos(42, 113)>,
StatementAssertion<Begin: Pos(44, 17), End: Pos(44, 59)>,
StatementAssertion<Begin: Pos(52, 17), End: Pos(52, 113)>,
StatementAssertion<Begin: Pos(54, 17), End: Pos(54, 59)>,
]
---
    public void testSimpleLongOverflow$catena_0() throws Exception
    {
        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);
        below = below.subtract(BigInteger.ONE);
        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);
        above = above.add(BigInteger.ONE);

        String DOC_BELOW = below.toString() + " ";
        String DOC_ABOVE = below.toString() + " ";

        for (int mode : ALL_MODES) {
            JsonParser p = createParser(FACTORY, mode, DOC_BELOW);
            p.nextToken();
            try {
                long x = p.getLongValue();
                fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);         /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();

            p = createParser(mode, DOC_ABOVE);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();
        }
    }
---
---
    public void testSimpleLongOverflow$catena_1() throws Exception
    {
        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);
        below = below.subtract(BigInteger.ONE);
        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);
        above = above.add(BigInteger.ONE);

        String DOC_BELOW = below.toString() + " ";
        String DOC_ABOVE = below.toString() + " ";

        for (int mode : ALL_MODES) {
            JsonParser p = createParser(FACTORY, mode, DOC_BELOW);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of long");                                                               /***** ORIGINAL ASSERTION IS HERE *****/
            }
            p.close();

            p = createParser(mode, DOC_ABOVE);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();
        }
    }
---
---
    public void testSimpleLongOverflow$catena_2() throws Exception
    {
        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);
        below = below.subtract(BigInteger.ONE);
        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);
        above = above.add(BigInteger.ONE);

        String DOC_BELOW = below.toString() + " ";
        String DOC_ABOVE = below.toString() + " ";

        for (int mode : ALL_MODES) {
            JsonParser p = createParser(FACTORY, mode, DOC_BELOW);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();

            p = createParser(mode, DOC_ABOVE);
            p.nextToken();
            try {
                long x = p.getLongValue();
                fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);         /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();
        }
    }
---
---
    public void testSimpleLongOverflow$catena_3() throws Exception
    {
        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);
        below = below.subtract(BigInteger.ONE);
        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);
        above = above.add(BigInteger.ONE);

        String DOC_BELOW = below.toString() + " ";
        String DOC_ABOVE = below.toString() + " ";

        for (int mode : ALL_MODES) {
            JsonParser p = createParser(FACTORY, mode, DOC_BELOW);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "out of range of long");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            }
            p.close();

            p = createParser(mode, DOC_ABOVE);
            p.nextToken();
            try {
                long x = p.getLongValue();
                try{ fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);    }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "out of range of long");                                                               /***** ORIGINAL ASSERTION IS HERE *****/
            }
            p.close();
        }
    }
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberOverflowTest::testMaliciousIntOverflow
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Begin: Pos(84, 12)
End: Pos(101, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberOverflowTest.java
Name: testMaliciousIntOverflow
Childs: [StatementAssertion<Begin: Pos(89, 17), End: Pos(89, 66)>,
StatementAssertion<Begin: Pos(90, 17), End: Pos(90, 71)>,
StatementAssertion<Begin: Pos(93, 21), End: Pos(93, 44)>,
StatementAssertion<Begin: Pos(95, 21), End: Pos(95, 62)>,
StatementAssertion<Begin: Pos(96, 21), End: Pos(96, 78)>,
]
---
    public void testMaliciousIntOverflow$catena_0() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                assertToken(JsonToken.START_ARRAY, p.nextToken());                                          /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getIntValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of int");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousIntOverflow$catena_1() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                     /***** ORIGINAL ASSERTION IS HERE *****/
                try {
                    p.getIntValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of int");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousIntOverflow$catena_2() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getIntValue();
                    fail("Should not pass");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of int");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousIntOverflow$catena_3() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getIntValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    verifyException(e, "out of range of int");                                              /***** ORIGINAL ASSERTION IS HERE *****/
                    try{ verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                         }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                p.close();
            }
        }
    }    
---
---
    public void testMaliciousIntOverflow$catena_4() throws Exception
    {
        for (int mode : ALL_STREAMING_MODES) {
            for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
                JsonParser p = createParser(mode, doc);
                try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    p.getIntValue();
                    try{ fail("Should not pass");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
                } catch (InputCoercionException e) {
                    try{ verifyException(e, "out of range of int");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
                    verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");                              /***** ORIGINAL ASSERTION IS HERE *****/
                }
                p.close();
            }
        }
    }    
---
@@@
Split test: com.fasterxml.jackson.core.read.NumberParsingTest::testSimpleLong
file: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberParsingTest.java
Begin: Pos(106, 12)
End: Pos(112, 5)
Source: /tmp/JacksonCore_24/src/test/java//com/fasterxml/jackson/core/read/NumberParsingTest.java
Name: testSimpleLong
Childs: [StatementAssertion<Begin: Pos(108, 9), End: Pos(108, 43)>,
StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 53)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 37)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 41)>,
]
---
    public void testSimpleLong$catena_0() throws Exception
    {
        _testSimpleLong(MODE_INPUT_STREAM);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_READER);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_DATA_INPUT);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSimpleLong$catena_1() throws Exception
    {
        try{ _testSimpleLong(MODE_INPUT_STREAM);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testSimpleLong(MODE_READER);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_DATA_INPUT);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSimpleLong$catena_2() throws Exception
    {
        try{ _testSimpleLong(MODE_INPUT_STREAM);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        _testSimpleLong(MODE_READER);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testSimpleLong(MODE_DATA_INPUT);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSimpleLong$catena_3() throws Exception
    {
        try{ _testSimpleLong(MODE_INPUT_STREAM);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_INPUT_STREAM_THROTTLED);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testSimpleLong(MODE_READER);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        _testSimpleLong(MODE_DATA_INPUT);                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_30
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965
file: /tmp/JacksonDatabind_30/src/test/java//com/fasterxml/jackson/databind/jsontype/TestExternalId.java
Begin: Pos(544, 12)
End: Pos(567, 5)
Source: /tmp/JacksonDatabind_30/src/test/java//com/fasterxml/jackson/databind/jsontype/TestExternalId.java
Name: testBigDecimal965
Childs: [StatementAssertion<Begin: Pos(556, 13), End: Pos(556, 95)>,
StatementAssertion<Begin: Pos(563, 9), End: Pos(563, 46)>,
StatementAssertion<Begin: Pos(564, 9), End: Pos(566, 38)>,
]
---
    public void testBigDecimal965$catena_0() throws Exception
    {

        Wrapper965 w = new Wrapper965();
        w.typeEnum = Type965.BIG_DECIMAL;
        final String NUM_STR = "-10000000000.0000000001";
        w.value = new BigDecimal(NUM_STR);

        String json = MAPPER.writeValueAsString(w);

        // simple sanity check so serialization is faithful
        if (!json.contains(NUM_STR)) {
            fail("JSON content should contain value '"+NUM_STR+"', does not appear to: "+json);             /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)
                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)
                .readValue(json);

        try{ assertEquals(w.typeEnum, w2.typeEnum);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(String.format("Expected %s = %s; got back %s = %s",
            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),
            w.value.equals(w2.value));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBigDecimal965$catena_1() throws Exception
    {

        Wrapper965 w = new Wrapper965();
        w.typeEnum = Type965.BIG_DECIMAL;
        final String NUM_STR = "-10000000000.0000000001";
        w.value = new BigDecimal(NUM_STR);

        String json = MAPPER.writeValueAsString(w);

        // simple sanity check so serialization is faithful
        if (!json.contains(NUM_STR)) {
            try{ fail("JSON content should contain value '"+NUM_STR+"', does not appear to: "+json);        }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)
                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)
                .readValue(json);

        assertEquals(w.typeEnum, w2.typeEnum);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(String.format("Expected %s = %s; got back %s = %s",
            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),
            w.value.equals(w2.value));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBigDecimal965$catena_2() throws Exception
    {

        Wrapper965 w = new Wrapper965();
        w.typeEnum = Type965.BIG_DECIMAL;
        final String NUM_STR = "-10000000000.0000000001";
        w.value = new BigDecimal(NUM_STR);

        String json = MAPPER.writeValueAsString(w);

        // simple sanity check so serialization is faithful
        if (!json.contains(NUM_STR)) {
            try{ fail("JSON content should contain value '"+NUM_STR+"', does not appear to: "+json);        }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)
                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)
                .readValue(json);

        try{ assertEquals(w.typeEnum, w2.typeEnum);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(String.format("Expected %s = %s; got back %s = %s",
            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),
            w.value.equals(w2.value));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_11
@@@
Split test: com.fasterxml.jackson.databind.type.TestJavaType::testLocalType728
file: /tmp/JacksonDatabind_11/src/test/java//com/fasterxml/jackson/databind/type/TestJavaType.java
Begin: Pos(31, 12)
End: Pos(50, 5)
Source: /tmp/JacksonDatabind_11/src/test/java//com/fasterxml/jackson/databind/type/TestJavaType.java
Name: testLocalType728
Childs: [StatementAssertion<Begin: Pos(35, 9), End: Pos(35, 25)>,
StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 58)>,
StatementAssertion<Begin: Pos(43, 9), End: Pos(43, 58)>,
StatementAssertion<Begin: Pos(47, 9), End: Pos(47, 58)>,
StatementAssertion<Begin: Pos(49, 9), End: Pos(49, 58)>,
]
---
    public void testLocalType728$catena_0() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        Method m = Issue728.class.getMethod("method", CharSequence.class);
        assertNotNull(m);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        // Start with return type
        // first type-erased
        JavaType t = tf.constructType(m.getReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // then generic
        t = tf.constructType(m.getGenericReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // then parameter type
        t = tf.constructType(m.getParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        t = tf.constructType(m.getGenericParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocalType728$catena_1() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        Method m = Issue728.class.getMethod("method", CharSequence.class);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // Start with return type
        // first type-erased
        JavaType t = tf.constructType(m.getReturnType());
        assertEquals(CharSequence.class, t.getRawClass());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        // then generic
        t = tf.constructType(m.getGenericReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // then parameter type
        t = tf.constructType(m.getParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        t = tf.constructType(m.getGenericParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocalType728$catena_2() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        Method m = Issue728.class.getMethod("method", CharSequence.class);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // Start with return type
        // first type-erased
        JavaType t = tf.constructType(m.getReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // then generic
        t = tf.constructType(m.getGenericReturnType());
        assertEquals(CharSequence.class, t.getRawClass());                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        // then parameter type
        t = tf.constructType(m.getParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        t = tf.constructType(m.getGenericParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocalType728$catena_3() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        Method m = Issue728.class.getMethod("method", CharSequence.class);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // Start with return type
        // first type-erased
        JavaType t = tf.constructType(m.getReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // then generic
        t = tf.constructType(m.getGenericReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // then parameter type
        t = tf.constructType(m.getParameterTypes()[0]);
        assertEquals(CharSequence.class, t.getRawClass());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        t = tf.constructType(m.getGenericParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocalType728$catena_4() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        Method m = Issue728.class.getMethod("method", CharSequence.class);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // Start with return type
        // first type-erased
        JavaType t = tf.constructType(m.getReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        // then generic
        t = tf.constructType(m.getGenericReturnType());
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // then parameter type
        t = tf.constructType(m.getParameterTypes()[0]);
        try{ assertEquals(CharSequence.class, t.getRawClass());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        t = tf.constructType(m.getGenericParameterTypes()[0]);
        assertEquals(CharSequence.class, t.getRawClass());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.type.TestLocalType609::testLocalPartialType609
file: /tmp/JacksonDatabind_11/src/test/java//com/fasterxml/jackson/databind/type/TestLocalType609.java
Begin: Pos(25, 12)
End: Pos(34, 5)
Source: /tmp/JacksonDatabind_11/src/test/java//com/fasterxml/jackson/databind/type/TestLocalType609.java
Name: testLocalPartialType609
Childs: [StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 51)>,
]
--------------------
Run: JacksonDatabind_8
@@@
Split test: com.fasterxml.jackson.databind.deser.TestJdkTypes::testStringBuilder
file: /tmp/JacksonDatabind_8/src/test/java//com/fasterxml/jackson/databind/deser/TestJdkTypes.java
Begin: Pos(423, 12)
End: Pos(427, 5)
Source: /tmp/JacksonDatabind_8/src/test/java//com/fasterxml/jackson/databind/deser/TestJdkTypes.java
Name: testStringBuilder
Childs: [StatementAssertion<Begin: Pos(426, 9), End: Pos(426, 43)>,
]
--------------------
Run: JacksonDatabind_22
@@@
Split test: com.fasterxml.jackson.databind.ser.TestJsonValue::testJsonValueWithCustomOverride
file: /tmp/JacksonDatabind_22/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonValue.java
Begin: Pos(270, 12)
End: Pos(283, 5)
Source: /tmp/JacksonDatabind_22/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonValue.java
Name: testJsonValueWithCustomOverride
Childs: [StatementAssertion<Begin: Pos(275, 9), End: Pos(275, 71)>,
StatementAssertion<Begin: Pos(282, 9), End: Pos(282, 61)>,
]
---
    public void testJsonValueWithCustomOverride$catena_0() throws Exception
    {
        final Bean838 INPUT = new Bean838();

        // by default, @JsonValue should be used
        assertEquals(quote("value"), MAPPER.writeValueAsString(INPUT));                                     /***** ORIGINAL ASSERTION IS HERE *****/

        // but custom serializer should override it
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new SimpleModule()
            .addSerializer(Bean838.class, new Bean838Serializer())
            );
        try{ assertEquals("42", mapper.writeValueAsString(INPUT));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testJsonValueWithCustomOverride$catena_1() throws Exception
    {
        final Bean838 INPUT = new Bean838();

        // by default, @JsonValue should be used
        try{ assertEquals(quote("value"), MAPPER.writeValueAsString(INPUT));                                }catch(Throwable __SHOULD_BE_IGNORED){}

        // but custom serializer should override it
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new SimpleModule()
            .addSerializer(Bean838.class, new Bean838Serializer())
            );
        assertEquals("42", mapper.writeValueAsString(INPUT));                                               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_49
@@@
Split test: com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1255
file: /tmp/JacksonDatabind_49/src/test/java//com/fasterxml/jackson/databind/objectid/AlwaysAsReferenceFirstTest.java
Begin: Pos(23, 12)
End: Pos(34, 5)
Source: /tmp/JacksonDatabind_49/src/test/java//com/fasterxml/jackson/databind/objectid/AlwaysAsReferenceFirstTest.java
Name: testIssue1255
Childs: [StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 30)>,
]
--------------------
Run: JacksonDatabind_58
@@@
Split test: com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral
file: /tmp/JacksonDatabind_58/src/test/java//com/fasterxml/jackson/databind/misc/AccessFixTest.java
Begin: Pos(24, 12)
End: Pos(33, 5)
Source: /tmp/JacksonDatabind_58/src/test/java//com/fasterxml/jackson/databind/misc/AccessFixTest.java
Name: testCauseOfThrowableIgnoral
Childs: [StatementAssertion<Begin: Pos(29, 13), End: Pos(29, 43)>,
]
--------------------
Run: JacksonDatabind_25
@@@
Split test: com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890
file: /tmp/JacksonDatabind_25/src/test/java//com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java
Begin: Pos(561, 12)
End: Pos(568, 5)
Source: /tmp/JacksonDatabind_25/src/test/java//com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java
Name: testByteArrayTypeOverride890
Childs: [StatementAssertion<Begin: Pos(565, 9), End: Pos(565, 30)>,
StatementAssertion<Begin: Pos(566, 9), End: Pos(566, 40)>,
StatementAssertion<Begin: Pos(567, 9), End: Pos(567, 64)>,
]
---
    public void testByteArrayTypeOverride890$catena_0() throws Exception
    {
        HiddenBinaryBean890 result = MAPPER.readValue(
                aposToQuotes("{'someBytes':'AQIDBA=='}"), HiddenBinaryBean890.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.someBytes);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(byte[].class, result.someBytes.getClass());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testByteArrayTypeOverride890$catena_1() throws Exception
    {
        HiddenBinaryBean890 result = MAPPER.readValue(
                aposToQuotes("{'someBytes':'AQIDBA=='}"), HiddenBinaryBean890.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.someBytes);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(byte[].class, result.someBytes.getClass());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testByteArrayTypeOverride890$catena_2() throws Exception
    {
        HiddenBinaryBean890 result = MAPPER.readValue(
                aposToQuotes("{'someBytes':'AQIDBA=='}"), HiddenBinaryBean890.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.someBytes);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(byte[].class, result.someBytes.getClass());                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_89
@@@
Split test: com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testJDKTypes1737
file: /tmp/JacksonDatabind_89/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Begin: Pos(59, 12)
End: Pos(63, 5)
Source: /tmp/JacksonDatabind_89/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Name: testJDKTypes1737
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 60)>,
StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 66)>,
]
---
    public void testJDKTypes1737$catena_0() throws Exception
    {
        _testTypes1737(java.util.logging.FileHandler.class);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testTypes1737(java.rmi.server.UnicastRemoteObject.class);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testJDKTypes1737$catena_1() throws Exception
    {
        try{ _testTypes1737(java.util.logging.FileHandler.class);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_68
@@@
Split test: com.fasterxml.jackson.databind.struct.SingleValueAsArrayTest::testSuccessfulDeserializationOfObjectWithChainedArrayCreators
file: /tmp/JacksonDatabind_68/src/test/java//com/fasterxml/jackson/databind/struct/SingleValueAsArrayTest.java
Begin: Pos(72, 12)
End: Pos(75, 5)
Source: /tmp/JacksonDatabind_68/src/test/java//com/fasterxml/jackson/databind/struct/SingleValueAsArrayTest.java
Name: testSuccessfulDeserializationOfObjectWithChainedArrayCreators
Childs: []
@@@
Split test: com.fasterxml.jackson.databind.struct.SingleValueAsArrayTest::testWithSingleString
file: /tmp/JacksonDatabind_68/src/test/java//com/fasterxml/jackson/databind/struct/SingleValueAsArrayTest.java
Begin: Pos(77, 12)
End: Pos(85, 5)
Source: /tmp/JacksonDatabind_68/src/test/java//com/fasterxml/jackson/databind/struct/SingleValueAsArrayTest.java
Name: testWithSingleString
Childs: [StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 40)>,
]
--------------------
Run: JacksonDatabind_101
@@@
Split test: com.fasterxml.jackson.databind.struct.TestUnwrapped::testIssue2088UnwrappedFieldsAfterLastCreatorProp
file: /tmp/JacksonDatabind_101/src/test/java//com/fasterxml/jackson/databind/struct/TestUnwrapped.java
Begin: Pos(248, 12)
End: Pos(255, 5)
Source: /tmp/JacksonDatabind_101/src/test/java//com/fasterxml/jackson/databind/struct/TestUnwrapped.java
Name: testIssue2088UnwrappedFieldsAfterLastCreatorProp
Childs: [StatementAssertion<Begin: Pos(251, 9), End: Pos(251, 32)>,
StatementAssertion<Begin: Pos(252, 9), End: Pos(252, 34)>,
StatementAssertion<Begin: Pos(253, 9), End: Pos(253, 32)>,
StatementAssertion<Begin: Pos(254, 9), End: Pos(254, 34)>,
]
---
    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp$catena_0() throws Exception
    {
        Issue2088Bean bean = MAPPER.readValue("{\"x\":1,\"a\":2,\"y\":3,\"b\":4}", Issue2088Bean.class);
        assertEquals(1, bean.x);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, bean.w.a);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.y);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(4, bean.w.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp$catena_1() throws Exception
    {
        Issue2088Bean bean = MAPPER.readValue("{\"x\":1,\"a\":2,\"y\":3,\"b\":4}", Issue2088Bean.class);
        try{ assertEquals(1, bean.x);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, bean.w.a);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, bean.y);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(4, bean.w.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp$catena_2() throws Exception
    {
        Issue2088Bean bean = MAPPER.readValue("{\"x\":1,\"a\":2,\"y\":3,\"b\":4}", Issue2088Bean.class);
        try{ assertEquals(1, bean.x);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.w.a);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, bean.y);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(4, bean.w.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp$catena_3() throws Exception
    {
        Issue2088Bean bean = MAPPER.readValue("{\"x\":1,\"a\":2,\"y\":3,\"b\":4}", Issue2088Bean.class);
        try{ assertEquals(1, bean.x);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.w.a);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.y);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(4, bean.w.b);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_88
@@@
Split test: com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test::testNestedTypeCheck1735
file: /tmp/JacksonDatabind_88/src/test/java//com/fasterxml/jackson/databind/jsontype/GenericTypeId1735Test.java
Begin: Pos(53, 12)
End: Pos(63, 5)
Source: /tmp/JacksonDatabind_88/src/test/java//com/fasterxml/jackson/databind/jsontype/GenericTypeId1735Test.java
Name: testNestedTypeCheck1735
Childs: [StatementAssertion<Begin: Pos(59, 13), End: Pos(59, 36)>,
StatementAssertion<Begin: Pos(61, 13), End: Pos(61, 49)>,
]
---
    public void testNestedTypeCheck1735$catena_0() throws Exception
    {
        try {
            MAPPER.readValue(aposToQuotes(
"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}"),
                    Wrapper1735.class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "not subtype of");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNestedTypeCheck1735$catena_1() throws Exception
    {
        try {
            MAPPER.readValue(aposToQuotes(
"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}"),
                    Wrapper1735.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "not subtype of");                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_60
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators::testWithCreatorAndJsonValue
file: /tmp/JacksonDatabind_60/src/test/java//com/fasterxml/jackson/databind/jsontype/TestDefaultWithCreators.java
Begin: Pos(83, 12)
End: Pos(97, 5)
Source: /tmp/JacksonDatabind_60/src/test/java//com/fasterxml/jackson/databind/jsontype/TestDefaultWithCreators.java
Name: testWithCreatorAndJsonValue
Childs: [StatementAssertion<Begin: Pos(92, 9), End: Pos(92, 30)>,
StatementAssertion<Begin: Pos(93, 9), End: Pos(93, 36)>,
StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 62)>,
StatementAssertion<Begin: Pos(96, 9), End: Pos(96, 47)>,
]
---
    public void testWithCreatorAndJsonValue$catena_0() throws Exception
    {
        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        String json = mapper.writeValueAsString(new Bean1385Wrapper(
                new Bean1385(BYTES)
        ));
        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Bean1385.class, result.value.getClass());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean1385 b = (Bean1385) result.value;
        try{ Assert.assertArrayEquals(BYTES, b.raw);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithCreatorAndJsonValue$catena_1() throws Exception
    {
        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        String json = mapper.writeValueAsString(new Bean1385Wrapper(
                new Bean1385(BYTES)
        ));
        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.value);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Bean1385.class, result.value.getClass());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean1385 b = (Bean1385) result.value;
        try{ Assert.assertArrayEquals(BYTES, b.raw);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithCreatorAndJsonValue$catena_2() throws Exception
    {
        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        String json = mapper.writeValueAsString(new Bean1385Wrapper(
                new Bean1385(BYTES)
        ));
        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Bean1385.class, result.value.getClass());                                              /***** ORIGINAL ASSERTION IS HERE *****/
        Bean1385 b = (Bean1385) result.value;
        try{ Assert.assertArrayEquals(BYTES, b.raw);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithCreatorAndJsonValue$catena_3() throws Exception
    {
        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        String json = mapper.writeValueAsString(new Bean1385Wrapper(
                new Bean1385(BYTES)
        ));
        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Bean1385.class, result.value.getClass());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean1385 b = (Bean1385) result.value;
        Assert.assertArrayEquals(BYTES, b.raw);                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest::testWithAsValue
file: /tmp/JacksonDatabind_60/src/test/java//com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest.java
Begin: Pos(471, 12)
End: Pos(484, 5)
Source: /tmp/JacksonDatabind_60/src/test/java//com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest.java
Name: testWithAsValue
Childs: [StatementAssertion<Begin: Pos(475, 9), End: Pos(475, 28)>,
StatementAssertion<Begin: Pos(476, 9), End: Pos(476, 68)>,
StatementAssertion<Begin: Pos(480, 9), End: Pos(480, 30)>,
StatementAssertion<Begin: Pos(481, 9), End: Pos(481, 36)>,
StatementAssertion<Begin: Pos(482, 9), End: Pos(482, 67)>,
StatementAssertion<Begin: Pos(483, 9), End: Pos(483, 69)>,
]
---
    public void testWithAsValue$catena_0() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        assertNotNull(json);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(AsValueThingy.class, result.value.getClass());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithAsValue$catena_1() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        try{ assertNotNull(json);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                        /***** ORIGINAL ASSERTION IS HERE *****/

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(AsValueThingy.class, result.value.getClass());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithAsValue$catena_2() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        try{ assertNotNull(json);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(AsValueThingy.class, result.value.getClass());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithAsValue$catena_3() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        try{ assertNotNull(json);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.value);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(AsValueThingy.class, result.value.getClass());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithAsValue$catena_4() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        try{ assertNotNull(json);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(AsValueThingy.class, result.value.getClass());                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWithAsValue$catena_5() throws Exception
    {
        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));
        String json = MAPPER.writeValueAsString(input);
        try{ assertNotNull(json);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{\"value\":12345,\"type\":\"thingy\"}", json);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // and get it back too:
        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(AsValueThingy.class, result.value.getClass());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(12345L, ((AsValueThingy) result.value).rawDate);                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_87
@@@
Split test: com.fasterxml.jackson.databind.deser.TestDateDeserialization::testDateUtilISO8601NoTimezoneNonDefault
file: /tmp/JacksonDatabind_87/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Begin: Pos(267, 12)
End: Pos(286, 5)
Source: /tmp/JacksonDatabind_87/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Name: testDateUtilISO8601NoTimezoneNonDefault
Childs: [StatementAssertion<Begin: Pos(277, 9), End: Pos(277, 35)>,
StatementAssertion<Begin: Pos(282, 9), End: Pos(282, 49)>,
StatementAssertion<Begin: Pos(283, 9), End: Pos(283, 62)>,
StatementAssertion<Begin: Pos(284, 9), End: Pos(284, 54)>,
StatementAssertion<Begin: Pos(285, 9), End: Pos(285, 53)>,
]
---
    public void testDateUtilISO8601NoTimezoneNonDefault$catena_0() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        assertEquals(date1, date2);                                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        try{ assertEquals(1970, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, c.get(Calendar.HOUR_OF_DAY));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateUtilISO8601NoTimezoneNonDefault$catena_1() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        try{ assertEquals(date1, date2);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        assertEquals(1970, c.get(Calendar.YEAR));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, c.get(Calendar.HOUR_OF_DAY));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateUtilISO8601NoTimezoneNonDefault$catena_2() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        try{ assertEquals(date1, date2);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        try{ assertEquals(1970, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, c.get(Calendar.HOUR_OF_DAY));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateUtilISO8601NoTimezoneNonDefault$catena_3() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        try{ assertEquals(date1, date2);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        try{ assertEquals(1970, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, c.get(Calendar.DAY_OF_MONTH));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, c.get(Calendar.HOUR_OF_DAY));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateUtilISO8601NoTimezoneNonDefault$catena_4() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        try{ assertEquals(date1, date2);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        try{ assertEquals(1970, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, c.get(Calendar.HOUR_OF_DAY));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_78
@@@
Split test: com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599
file: /tmp/JacksonDatabind_78/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Begin: Pos(16, 12)
End: Pos(39, 5)
Source: /tmp/JacksonDatabind_78/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Name: testIssue1599
Childs: [StatementAssertion<Begin: Pos(33, 13), End: Pos(33, 36)>,
StatementAssertion<Begin: Pos(35, 13), End: Pos(35, 47)>,
StatementAssertion<Begin: Pos(36, 13), End: Pos(36, 49)>,
StatementAssertion<Begin: Pos(37, 13), End: Pos(37, 65)>,
]
---
    public void testIssue1599$catena_0() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_1() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Illegal type");                                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_2() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            verifyException(e, "to deserialize");                                                           /***** ORIGINAL ASSERTION IS HERE *****/
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_3() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            verifyException(e, "prevented for security reasons");                                           /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_64
@@@
Split test: com.fasterxml.jackson.databind.filter.JsonIncludeTest::testIssue1351
file: /tmp/JacksonDatabind_64/src/test/java//com/fasterxml/jackson/databind/filter/JsonIncludeTest.java
Begin: Pos(313, 12)
End: Pos(322, 5)
Source: /tmp/JacksonDatabind_64/src/test/java//com/fasterxml/jackson/databind/filter/JsonIncludeTest.java
Name: testIssue1351
Childs: [StatementAssertion<Begin: Pos(317, 9), End: Pos(318, 80)>,
StatementAssertion<Begin: Pos(320, 9), End: Pos(321, 68)>,
]
---
    public void testIssue1351$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);
        assertEquals(aposToQuotes("{}"),
                mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));                            /***** ORIGINAL ASSERTION IS HERE *****/
        // [databind#1417]
        try{ assertEquals(aposToQuotes("{}"),
                mapper.writeValueAsString(new Issue1351NonBean(0)));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue1351$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);
        try{ assertEquals(aposToQuotes("{}"),
                mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // [databind#1417]
        assertEquals(aposToQuotes("{}"),
                mapper.writeValueAsString(new Issue1351NonBean(0)));                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_29
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestExternalId::testExternalTypeIdWithNull
file: /tmp/JacksonDatabind_29/src/test/java//com/fasterxml/jackson/databind/jsontype/TestExternalId.java
Begin: Pos(283, 12)
End: Pos(294, 5)
Source: /tmp/JacksonDatabind_29/src/test/java//com/fasterxml/jackson/databind/jsontype/TestExternalId.java
Name: testExternalTypeIdWithNull
Childs: [StatementAssertion<Begin: Pos(290, 9), End: Pos(290, 25)>,
StatementAssertion<Begin: Pos(293, 9), End: Pos(293, 25)>,
]
---
    public void testExternalTypeIdWithNull$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerSubtypes(ValueBean.class);
        ExternalBean b;
        b = mapper.readValue(aposToQuotes("{'bean':null,'extType':'vbean'}"),
                ExternalBean.class);
        assertNotNull(b);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        b = mapper.readValue(aposToQuotes("{'extType':'vbean','bean':null}"),
                ExternalBean.class);
        try{ assertNotNull(b);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeIdWithNull$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerSubtypes(ValueBean.class);
        ExternalBean b;
        b = mapper.readValue(aposToQuotes("{'bean':null,'extType':'vbean'}"),
                ExternalBean.class);
        try{ assertNotNull(b);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        b = mapper.readValue(aposToQuotes("{'extType':'vbean','bean':null}"),
                ExternalBean.class);
        assertNotNull(b);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_95
@@@
Split test: com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames
file: /tmp/JacksonDatabind_95/src/test/java//com/fasterxml/jackson/databind/type/TestTypeFactory.java
Begin: Pos(209, 12)
End: Pos(250, 5)
Source: /tmp/JacksonDatabind_95/src/test/java//com/fasterxml/jackson/databind/type/TestTypeFactory.java
Name: testCanonicalNames
Childs: [StatementAssertion<Begin: Pos(214, 9), End: Pos(214, 48)>,
StatementAssertion<Begin: Pos(215, 9), End: Pos(215, 56)>,
StatementAssertion<Begin: Pos(220, 9), End: Pos(220, 67)>,
StatementAssertion<Begin: Pos(221, 9), End: Pos(221, 56)>,
StatementAssertion<Begin: Pos(225, 9), End: Pos(225, 82)>,
StatementAssertion<Begin: Pos(226, 9), End: Pos(226, 56)>,
StatementAssertion<Begin: Pos(231, 9), End: Pos(232, 21)>,
StatementAssertion<Begin: Pos(233, 9), End: Pos(233, 56)>,
StatementAssertion<Begin: Pos(238, 9), End: Pos(238, 50)>,
StatementAssertion<Begin: Pos(239, 9), End: Pos(239, 57)>,
StatementAssertion<Begin: Pos(246, 9), End: Pos(246, 69)>,
StatementAssertion<Begin: Pos(248, 9), End: Pos(248, 62)>,
StatementAssertion<Begin: Pos(249, 9), End: Pos(249, 56)>,
]
---
    public void testCanonicalNames$catena_0()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        assertEquals("java.util.Calendar", can);                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_1()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_2()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        assertEquals("java.util.ArrayList<java.lang.Object>", can);                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_3()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_4()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_5()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_6()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_7()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_8()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        assertEquals(List.class, t.getRawClass());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_9()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(CollectionType.class, t.getClass());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_10()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        assertEquals(Object.class, t.getContentType().getRawClass());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_11()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        assertEquals("java.util.List<java.lang.Object>", can);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCanonicalNames$catena_12()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(java.util.Calendar.class);
        String can = t.toCanonical();
        try{ assertEquals("java.util.Calendar", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // Generic maps and collections will default to Object.class if type-erased
        t = tf.constructType(java.util.ArrayList.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.ArrayList<java.lang.Object>", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        t = tf.constructType(java.util.TreeMap.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // And then EnumMap (actual use case for us)
        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);
        can = t.toCanonical();
        try{ assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",
                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1941]: allow "raw" types too

        t = tf.constructFromCanonical("java.util.List");
        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...
        //    But currently we do NOT get any
        /*
        assertEquals(1, t.containedTypeCount());
        assertEquals(Object.class, t.containedType(0).getRawClass());
        */
        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        can = t.toCanonical();
        try{ assertEquals("java.util.List<java.lang.Object>", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_48
@@@
Split test: com.fasterxml.jackson.databind.ser.TestFeatures::testVisibilityFeatures
file: /tmp/JacksonDatabind_48/src/test/java//com/fasterxml/jackson/databind/ser/TestFeatures.java
Begin: Pos(283, 12)
End: Pos(302, 5)
Source: /tmp/JacksonDatabind_48/src/test/java//com/fasterxml/jackson/databind/ser/TestFeatures.java
Name: testVisibilityFeatures
Childs: [StatementAssertion<Begin: Pos(300, 13), End: Pos(300, 86)>,
]
--------------------
Run: JacksonDatabind_21
@@@
Split test: com.fasterxml.jackson.databind.deser.TestEnumDeserialization::testEnumWithJsonPropertyRename
file: /tmp/JacksonDatabind_21/src/test/java//com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java
Begin: Pos(470, 12)
End: Pos(483, 5)
Source: /tmp/JacksonDatabind_21/src/test/java//com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java
Name: testEnumWithJsonPropertyRename
Childs: [StatementAssertion<Begin: Pos(475, 9), End: Pos(475, 44)>,
StatementAssertion<Begin: Pos(479, 9), End: Pos(479, 30)>,
StatementAssertion<Begin: Pos(480, 9), End: Pos(480, 39)>,
StatementAssertion<Begin: Pos(481, 9), End: Pos(481, 54)>,
StatementAssertion<Begin: Pos(482, 9), End: Pos(482, 54)>,
]
---
    public void testEnumWithJsonPropertyRename$catena_0() throws Exception
    {
        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {
                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A
        });
        assertEquals("[\"b\",\"a\"]", json);                                                                /***** ORIGINAL ASSERTION IS HERE *****/

        // and while not really proper place, let's also verify deser while we're at it
        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.B, result[0]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.A, result[1]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumWithJsonPropertyRename$catena_1() throws Exception
    {
        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {
                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A
        });
        try{ assertEquals("[\"b\",\"a\"]", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        // and while not really proper place, let's also verify deser while we're at it
        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.B, result[0]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.A, result[1]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumWithJsonPropertyRename$catena_2() throws Exception
    {
        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {
                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A
        });
        try{ assertEquals("[\"b\",\"a\"]", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        // and while not really proper place, let's also verify deser while we're at it
        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, result.length);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertSame(EnumWithPropertyAnno.B, result[0]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.A, result[1]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumWithJsonPropertyRename$catena_3() throws Exception
    {
        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {
                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A
        });
        try{ assertEquals("[\"b\",\"a\"]", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        // and while not really proper place, let's also verify deser while we're at it
        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertSame(EnumWithPropertyAnno.B, result[0]);                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertSame(EnumWithPropertyAnno.A, result[1]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumWithJsonPropertyRename$catena_4() throws Exception
    {
        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {
                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A
        });
        try{ assertEquals("[\"b\",\"a\"]", json);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        // and while not really proper place, let's also verify deser while we're at it
        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(EnumWithPropertyAnno.B, result[0]);                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertSame(EnumWithPropertyAnno.A, result[1]);                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_9
@@@
Split test: com.fasterxml.jackson.databind.ser.TestMapSerialization::testClassKey
file: /tmp/JacksonDatabind_9/src/test/java//com/fasterxml/jackson/databind/ser/TestMapSerialization.java
Begin: Pos(251, 12)
End: Pos(257, 5)
Source: /tmp/JacksonDatabind_9/src/test/java//com/fasterxml/jackson/databind/ser/TestMapSerialization.java
Name: testClassKey
Childs: [StatementAssertion<Begin: Pos(256, 9), End: Pos(256, 67)>,
]
--------------------
Run: JacksonDatabind_35
@@@
Split test: com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest::testSimple
file: /tmp/JacksonDatabind_35/src/test/java//com/fasterxml/jackson/databind/jsontype/WrapperObjectWithObjectIdTest.java
Begin: Pos(69, 12)
End: Pos(87, 5)
Source: /tmp/JacksonDatabind_35/src/test/java//com/fasterxml/jackson/databind/jsontype/WrapperObjectWithObjectIdTest.java
Name: testSimple
Childs: [StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 30)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 40)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 49)>,
]
---
    public void testSimple$catena_0() throws Exception
    {
        Company comp = new Company();
        comp.addComputer(new DesktopComputer("computer-1", "Bangkok"));
        comp.addComputer(new DesktopComputer("computer-2", "Pattaya"));
        comp.addComputer(new LaptopComputer("computer-3", "Apple"));

        final ObjectMapper mapper = new ObjectMapper();

        String json = mapper.writerWithDefaultPrettyPrinter()
                .writeValueAsString(comp);

        System.out.println("JSON: "+json);

        Company result = mapper.readValue(json, Company.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.computers);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, result.computers.size());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSimple$catena_1() throws Exception
    {
        Company comp = new Company();
        comp.addComputer(new DesktopComputer("computer-1", "Bangkok"));
        comp.addComputer(new DesktopComputer("computer-2", "Pattaya"));
        comp.addComputer(new LaptopComputer("computer-3", "Apple"));

        final ObjectMapper mapper = new ObjectMapper();

        String json = mapper.writerWithDefaultPrettyPrinter()
                .writeValueAsString(comp);

        System.out.println("JSON: "+json);

        Company result = mapper.readValue(json, Company.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.computers);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, result.computers.size());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testSimple$catena_2() throws Exception
    {
        Company comp = new Company();
        comp.addComputer(new DesktopComputer("computer-1", "Bangkok"));
        comp.addComputer(new DesktopComputer("computer-2", "Pattaya"));
        comp.addComputer(new LaptopComputer("computer-3", "Apple"));

        final ObjectMapper mapper = new ObjectMapper();

        String json = mapper.writerWithDefaultPrettyPrinter()
                .writeValueAsString(comp);

        System.out.println("JSON: "+json);

        Company result = mapper.readValue(json, Company.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.computers);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, result.computers.size());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_43
@@@
Split test: com.fasterxml.jackson.databind.objectid.TestObjectIdSerialization::testNullStringPropertyId
file: /tmp/JacksonDatabind_43/src/test/java//com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java
Begin: Pos(314, 12)
End: Pos(320, 5)
Source: /tmp/JacksonDatabind_43/src/test/java//com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java
Name: testNullStringPropertyId
Childs: [StatementAssertion<Begin: Pos(318, 9), End: Pos(318, 29)>,
StatementAssertion<Begin: Pos(319, 9), End: Pos(319, 37)>,
]
---
    public void testNullStringPropertyId$catena_0() throws Exception
    {
        IdentifiableStringId value = MAPPER.readValue
                (aposToQuotes("{'value':3, 'next':null, 'id':null}"), IdentifiableStringId.class);
        assertNotNull(value);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, value.value);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }    
---
---
    public void testNullStringPropertyId$catena_1() throws Exception
    {
        IdentifiableStringId value = MAPPER.readValue
                (aposToQuotes("{'value':3, 'next':null, 'id':null}"), IdentifiableStringId.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, value.value);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }    
---
--------------------
Run: JacksonDatabind_41
@@@
Split test: com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testDeprecatedTypeResolution
file: /tmp/JacksonDatabind_41/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Begin: Pos(92, 5)
End: Pos(108, 5)
Source: /tmp/JacksonDatabind_41/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Name: testDeprecatedTypeResolution
Childs: [StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 51)>,
StatementAssertion<Begin: Pos(103, 9), End: Pos(103, 52)>,
StatementAssertion<Begin: Pos(107, 9), End: Pos(107, 52)>,
]
---
    @SuppressWarnings("deprecation")
    public void testDeprecatedTypeResolution$catena_0() throws Exception
    {
        TypeFactory tf = MAPPER.getTypeFactory();

        // first, with real (if irrelevant) context
        JavaType t = tf.constructType(Point.class, getClass());
        assertEquals(Point.class, t.getRawClass());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        // and then missing context
        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);
        try{ assertEquals(Point.class, t2.getRawClass());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        JavaType ctxt = tf.constructType(getClass());
        JavaType t3 = tf.constructType(Point.class, ctxt);
        try{ assertEquals(Point.class, t3.getRawClass());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testDeprecatedTypeResolution$catena_1() throws Exception
    {
        TypeFactory tf = MAPPER.getTypeFactory();

        // first, with real (if irrelevant) context
        JavaType t = tf.constructType(Point.class, getClass());
        try{ assertEquals(Point.class, t.getRawClass());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then missing context
        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);
        assertEquals(Point.class, t2.getRawClass());                                                        /***** ORIGINAL ASSERTION IS HERE *****/

        JavaType ctxt = tf.constructType(getClass());
        JavaType t3 = tf.constructType(Point.class, ctxt);
        try{ assertEquals(Point.class, t3.getRawClass());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testDeprecatedTypeResolution$catena_2() throws Exception
    {
        TypeFactory tf = MAPPER.getTypeFactory();

        // first, with real (if irrelevant) context
        JavaType t = tf.constructType(Point.class, getClass());
        try{ assertEquals(Point.class, t.getRawClass());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then missing context
        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);
        try{ assertEquals(Point.class, t2.getRawClass());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        JavaType ctxt = tf.constructType(getClass());
        JavaType t3 = tf.constructType(Point.class, ctxt);
        assertEquals(Point.class, t3.getRawClass());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_103
@@@
Split test: com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition
file: /tmp/JacksonDatabind_103/src/test/java//com/fasterxml/jackson/databind/exc/BasicExceptionTest.java
Begin: Pos(117, 12)
End: Pos(130, 5)
Source: /tmp/JacksonDatabind_103/src/test/java//com/fasterxml/jackson/databind/exc/BasicExceptionTest.java
Name: testLocationAddition
Childs: [StatementAssertion<Begin: Pos(122, 13), End: Pos(122, 36)>,
StatementAssertion<Begin: Pos(127, 17), End: Pos(127, 96)>,
]
---
    public void testLocationAddition$catena_0() throws Exception
    {
        try {
            /*Map<?,?> map =*/ MAPPER.readValue("{\"value\":\"foo\"}",
                    new TypeReference<Map<ABC, Integer>>() { });
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (MismatchedInputException e) {
            String msg = e.getMessage();
            String[] str = msg.split(" at \\[");
            if (str.length != 2) {
                try{ fail("Should only get one 'at [' marker, got "+(str.length-1)+", source: "+msg);       }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testLocationAddition$catena_1() throws Exception
    {
        try {
            /*Map<?,?> map =*/ MAPPER.readValue("{\"value\":\"foo\"}",
                    new TypeReference<Map<ABC, Integer>>() { });
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (MismatchedInputException e) {
            String msg = e.getMessage();
            String[] str = msg.split(" at \\[");
            if (str.length != 2) {
                fail("Should only get one 'at [' marker, got "+(str.length-1)+", source: "+msg);            /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
--------------------
Run: JacksonDatabind_18
@@@
Split test: com.fasterxml.jackson.databind.seq.ReadRecoveryTest::testSimpleRootRecovery
file: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Begin: Pos(49, 12)
End: Pos(75, 5)
Source: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Name: testSimpleRootRecovery
Childs: [StatementAssertion<Begin: Pos(56, 9), End: Pos(56, 28)>,
StatementAssertion<Begin: Pos(57, 9), End: Pos(57, 32)>,
StatementAssertion<Begin: Pos(63, 13), End: Pos(63, 61)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 28)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 32)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 32)>,
StatementAssertion<Begin: Pos(72, 9), End: Pos(72, 39)>,
]
---
    public void testSimpleRootRecovery$catena_0() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        assertNotNull(bean);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_1() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, bean.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_2() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            verifyException(e, "Unrecognized field \"foo\"");                                               /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_3() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        assertNotNull(bean);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_4() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, bean.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_5() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, bean.b);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleRootRecovery$catena_6() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertFalse(it.hasNextValue());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        it.close();
    }
---
@@@
Split test: com.fasterxml.jackson.databind.seq.ReadRecoveryTest::testRootBeans
file: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Begin: Pos(25, 12)
End: Pos(44, 5)
Source: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Name: testRootBeans
Childs: [StatementAssertion<Begin: Pos(30, 9), End: Pos(30, 38)>,
StatementAssertion<Begin: Pos(32, 9), End: Pos(32, 32)>,
StatementAssertion<Begin: Pos(36, 13), End: Pos(36, 46)>,
StatementAssertion<Begin: Pos(38, 13), End: Pos(38, 59)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 39)>,
]
---
    public void testRootBeans$catena_0() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3} {'x':5}");
        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        // First one should be fine
        assertTrue(it.hasNextValue());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        Bean bean = it.nextValue();
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // but second one not
        try {
            bean = it.nextValue();
            try{ fail("Should not have succeeded");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"x\"");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        it.close();
    }
---
---
    public void testRootBeans$catena_1() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3} {'x':5}");
        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        // First one should be fine
        try{ assertTrue(it.hasNextValue());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean bean = it.nextValue();
        assertEquals(3, bean.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        // but second one not
        try {
            bean = it.nextValue();
            try{ fail("Should not have succeeded");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"x\"");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        it.close();
    }
---
---
    public void testRootBeans$catena_2() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3} {'x':5}");
        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        // First one should be fine
        try{ assertTrue(it.hasNextValue());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean bean = it.nextValue();
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // but second one not
        try {
            bean = it.nextValue();
            fail("Should not have succeeded");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"x\"");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        it.close();
    }
---
---
    public void testRootBeans$catena_3() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3} {'x':5}");
        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        // First one should be fine
        try{ assertTrue(it.hasNextValue());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean bean = it.nextValue();
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // but second one not
        try {
            bean = it.nextValue();
            try{ fail("Should not have succeeded");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Unrecognized field \"x\"");                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        }
        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        it.close();
    }
---
---
    public void testRootBeans$catena_4() throws Exception
    {
        final String JSON = aposToQuotes("{'a':3} {'x':5}");
        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        // First one should be fine
        try{ assertTrue(it.hasNextValue());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        Bean bean = it.nextValue();
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        // but second one not
        try {
            bean = it.nextValue();
            try{ fail("Should not have succeeded");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"x\"");                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
        assertFalse(it.hasNextValue());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        it.close();
    }
---
@@@
Split test: com.fasterxml.jackson.databind.seq.ReadRecoveryTest::testSimpleArrayRecovery
file: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Begin: Pos(78, 12)
End: Pos(104, 5)
Source: /tmp/JacksonDatabind_18/src/test/java//com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
Name: testSimpleArrayRecovery
Childs: [StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 28)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 32)>,
StatementAssertion<Begin: Pos(92, 13), End: Pos(92, 61)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 28)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 32)>,
StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 32)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 39)>,
]
---
    public void testSimpleArrayRecovery$catena_0() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        assertNotNull(bean);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_1() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, bean.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_2() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            verifyException(e, "Unrecognized field \"foo\"");                                               /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_3() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        assertNotNull(bean);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_4() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, bean.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_5() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, bean.b);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertFalse(it.hasNextValue());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        it.close();
    }
---
---
    public void testSimpleArrayRecovery$catena_6() throws Exception
    {
        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");

        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
        Bean bean = it.nextValue();

        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // second one problematic
        try {
            it.nextValue();
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Unrecognized field \"foo\"");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // but should recover nicely
        bean = it.nextValue();
        try{ assertNotNull(bean);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, bean.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, bean.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertFalse(it.hasNextValue());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        it.close();
    }
---
--------------------
Run: JacksonDatabind_15
@@@
Split test: com.fasterxml.jackson.databind.convert.TestConvertingSerializer::testIssue731
file: /tmp/JacksonDatabind_15/src/test/java//com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java
Begin: Pos(199, 12)
End: Pos(204, 5)
Source: /tmp/JacksonDatabind_15/src/test/java//com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java
Name: testIssue731
Childs: [StatementAssertion<Begin: Pos(203, 9), End: Pos(203, 48)>,
]
--------------------
Run: JacksonDatabind_51
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom
file: /tmp/JacksonDatabind_51/src/test/java//com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
Begin: Pos(211, 12)
End: Pos(229, 5)
Source: /tmp/JacksonDatabind_51/src/test/java//com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
Name: testPolymorphicTypeViaCustom
Childs: [StatementAssertion<Begin: Pos(221, 9), End: Pos(221, 37)>,
StatementAssertion<Begin: Pos(222, 9), End: Pos(222, 52)>,
StatementAssertion<Begin: Pos(223, 9), End: Pos(223, 63)>,
StatementAssertion<Begin: Pos(227, 9), End: Pos(227, 32)>,
StatementAssertion<Begin: Pos(228, 9), End: Pos(228, 34)>,
]
---
    public void testPolymorphicTypeViaCustom$catena_0() throws Exception {
        Base1270<Poly1> req = new Base1270<Poly1>();
        Poly1 o = new Poly1();
        o.val = "optionValue";
        req.options = o;
        req.val = "some value";
        Top1270 top = new Top1270();
        top.b = req;
        String json = MAPPER.writeValueAsString(top);
        JsonNode tree = MAPPER.readTree(json);
        assertNotNull(tree.get("b"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(tree.get("b").get("options"));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options").get("val"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        // Can we reverse the process? I have some doubts
        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
        try{ assertNotNull(itemRead);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(itemRead.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testPolymorphicTypeViaCustom$catena_1() throws Exception {
        Base1270<Poly1> req = new Base1270<Poly1>();
        Poly1 o = new Poly1();
        o.val = "optionValue";
        req.options = o;
        req.val = "some value";
        Top1270 top = new Top1270();
        top.b = req;
        String json = MAPPER.writeValueAsString(top);
        JsonNode tree = MAPPER.readTree(json);
        try{ assertNotNull(tree.get("b"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(tree.get("b").get("options"));                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(tree.get("b").get("options").get("val"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        // Can we reverse the process? I have some doubts
        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
        try{ assertNotNull(itemRead);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(itemRead.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testPolymorphicTypeViaCustom$catena_2() throws Exception {
        Base1270<Poly1> req = new Base1270<Poly1>();
        Poly1 o = new Poly1();
        o.val = "optionValue";
        req.options = o;
        req.val = "some value";
        Top1270 top = new Top1270();
        top.b = req;
        String json = MAPPER.writeValueAsString(top);
        JsonNode tree = MAPPER.readTree(json);
        try{ assertNotNull(tree.get("b"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options"));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(tree.get("b").get("options").get("val"));                                             /***** ORIGINAL ASSERTION IS HERE *****/

        // Can we reverse the process? I have some doubts
        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
        try{ assertNotNull(itemRead);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(itemRead.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testPolymorphicTypeViaCustom$catena_3() throws Exception {
        Base1270<Poly1> req = new Base1270<Poly1>();
        Poly1 o = new Poly1();
        o.val = "optionValue";
        req.options = o;
        req.val = "some value";
        Top1270 top = new Top1270();
        top.b = req;
        String json = MAPPER.writeValueAsString(top);
        JsonNode tree = MAPPER.readTree(json);
        try{ assertNotNull(tree.get("b"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options"));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options").get("val"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        // Can we reverse the process? I have some doubts
        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
        assertNotNull(itemRead);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(itemRead.b);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testPolymorphicTypeViaCustom$catena_4() throws Exception {
        Base1270<Poly1> req = new Base1270<Poly1>();
        Poly1 o = new Poly1();
        o.val = "optionValue";
        req.options = o;
        req.val = "some value";
        Top1270 top = new Top1270();
        top.b = req;
        String json = MAPPER.writeValueAsString(top);
        JsonNode tree = MAPPER.readTree(json);
        try{ assertNotNull(tree.get("b"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options"));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(tree.get("b").get("options").get("val"));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        // Can we reverse the process? I have some doubts
        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
        try{ assertNotNull(itemRead);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(itemRead.b);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_91
@@@
Split test: com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest::testCachedSerialize
file: /tmp/JacksonDatabind_91/src/test/java//com/fasterxml/jackson/databind/deser/jdk/MapDeserializerCachingTest.java
Begin: Pos(35, 12)
End: Pos(51, 5)
Source: /tmp/JacksonDatabind_91/src/test/java//com/fasterxml/jackson/databind/deser/jdk/MapDeserializerCachingTest.java
Name: testCachedSerialize
Childs: [StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 52)>,
StatementAssertion<Begin: Pos(42, 9), End: Pos(42, 52)>,
StatementAssertion<Begin: Pos(49, 13), End: Pos(49, 101)>,
]
---
    public void testCachedSerialize$catena_0() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        String json = aposToQuotes("{'data':{'1st':'onedata','2nd':'twodata'}}");

        // Do deserialization with non-annotated map property
        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);
        assertTrue(ignored.data.containsKey("1st"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(ignored.data.containsKey("2nd"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

//mapper = new ObjectMapper();
        
        MapHolder model2 = mapper.readValue(json, MapHolder.class);
        if (!model2.data.containsKey("1st (CUSTOM)")
            || !model2.data.containsKey("2nd (CUSTOM)")) {
            try{ fail("Not using custom key deserializer for input: "+json+"; resulted in: "+model2.data);    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testCachedSerialize$catena_1() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        String json = aposToQuotes("{'data':{'1st':'onedata','2nd':'twodata'}}");

        // Do deserialization with non-annotated map property
        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);
        try{ assertTrue(ignored.data.containsKey("1st"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(ignored.data.containsKey("2nd"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/

//mapper = new ObjectMapper();
        
        MapHolder model2 = mapper.readValue(json, MapHolder.class);
        if (!model2.data.containsKey("1st (CUSTOM)")
            || !model2.data.containsKey("2nd (CUSTOM)")) {
            try{ fail("Not using custom key deserializer for input: "+json+"; resulted in: "+model2.data);    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testCachedSerialize$catena_2() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        String json = aposToQuotes("{'data':{'1st':'onedata','2nd':'twodata'}}");

        // Do deserialization with non-annotated map property
        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);
        try{ assertTrue(ignored.data.containsKey("1st"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(ignored.data.containsKey("2nd"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

//mapper = new ObjectMapper();
        
        MapHolder model2 = mapper.readValue(json, MapHolder.class);
        if (!model2.data.containsKey("1st (CUSTOM)")
            || !model2.data.containsKey("2nd (CUSTOM)")) {
            fail("Not using custom key deserializer for input: "+json+"; resulted in: "+model2.data);         /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_83
@@@
Split test: com.fasterxml.jackson.databind.filter.ProblemHandlerTest::testWeirdStringHandling
file: /tmp/JacksonDatabind_83/src/test/java//com/fasterxml/jackson/databind/filter/ProblemHandlerTest.java
Begin: Pos(236, 12)
End: Pos(249, 5)
Source: /tmp/JacksonDatabind_83/src/test/java//com/fasterxml/jackson/databind/filter/ProblemHandlerTest.java
Name: testWeirdStringHandling
Childs: [StatementAssertion<Begin: Pos(242, 9), End: Pos(242, 49)>,
StatementAssertion<Begin: Pos(248, 9), End: Pos(248, 28)>,
]
---
    public void testWeirdStringHandling$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))
            ;
        SingleValuedEnum result = mapper.readValue("\"B\"", SingleValuedEnum.class);
        assertEquals(SingleValuedEnum.A, result);                                                           /***** ORIGINAL ASSERTION IS HERE *****/

        // also, write [databind#1629] try this
        mapper = new ObjectMapper()
                .addHandler(new WeirdStringHandler(null));
        UUID result2 = mapper.readValue(quote("not a uuid!"), UUID.class);
        try{ assertNull(result2);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testWeirdStringHandling$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))
            ;
        SingleValuedEnum result = mapper.readValue("\"B\"", SingleValuedEnum.class);
        try{ assertEquals(SingleValuedEnum.A, result);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, write [databind#1629] try this
        mapper = new ObjectMapper()
                .addHandler(new WeirdStringHandler(null));
        UUID result2 = mapper.readValue(quote("not a uuid!"), UUID.class);
        assertNull(result2);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_10
@@@
Split test: com.fasterxml.jackson.databind.ser.TestAnyGetter::testIssue705
file: /tmp/JacksonDatabind_10/src/test/java//com/fasterxml/jackson/databind/ser/TestAnyGetter.java
Begin: Pos(135, 12)
End: Pos(140, 5)
Source: /tmp/JacksonDatabind_10/src/test/java//com/fasterxml/jackson/databind/ser/TestAnyGetter.java
Name: testIssue705
Childs: [StatementAssertion<Begin: Pos(139, 9), End: Pos(139, 58)>,
]
--------------------
Run: JacksonDatabind_63
@@@
Split test: com.fasterxml.jackson.databind.deser.exc.ExceptionPathTest::testReferenceChainForInnerClass
file: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/ExceptionPathTest.java
Begin: Pos(29, 12)
End: Pos(40, 5)
Source: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/ExceptionPathTest.java
Name: testReferenceChainForInnerClass
Childs: [StatementAssertion<Begin: Pos(34, 13), End: Pos(34, 36)>,
StatementAssertion<Begin: Pos(37, 13), End: Pos(38, 42)>,
]
---
    public void testReferenceChainForInnerClass$catena_0() throws Exception
    {
        String json = MAPPER.writeValueAsString(new Outer());
        try {
            MAPPER.readValue(json, Outer.class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            JsonMappingException.Reference reference = e.getPath().get(0);
            try{ assertEquals(getClass().getName()+"$Outer[\"inner\"]",
                    reference.toString());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testReferenceChainForInnerClass$catena_1() throws Exception
    {
        String json = MAPPER.writeValueAsString(new Outer());
        try {
            MAPPER.readValue(json, Outer.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            JsonMappingException.Reference reference = e.getPath().get(0);
            assertEquals(getClass().getName()+"$Outer[\"inner\"]",
                    reference.toString());                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
@@@
Split test: com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithDefaultDeserialization::testShouldThrowJsonMappingExceptionWithPathReference
file: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/TestExceptionHandlingWithDefaultDeserialization.java
Begin: Pos(41, 12)
End: Pos(56, 5)
Source: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/TestExceptionHandlingWithDefaultDeserialization.java
Name: testShouldThrowJsonMappingExceptionWithPathReference
Childs: [StatementAssertion<Begin: Pos(50, 13), End: Pos(50, 58)>,
StatementAssertion<Begin: Pos(53, 13), End: Pos(54, 43)>,
]
---
    public void testShouldThrowJsonMappingExceptionWithPathReference$catena_0() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";
        final String THIS = getClass().getName();

        // when
        try {
            mapper.readValue(input, Foo.class);
            fail("Upsss! Exception has not been thrown.");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException ex) {
            // then
            try{ assertEquals(THIS+"$Foo[\"bar\"]->"+THIS+"$Bar[\"baz\"]",
                    ex.getPathReference());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShouldThrowJsonMappingExceptionWithPathReference$catena_1() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";
        final String THIS = getClass().getName();

        // when
        try {
            mapper.readValue(input, Foo.class);
            try{ fail("Upsss! Exception has not been thrown.");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException ex) {
            // then
            assertEquals(THIS+"$Foo[\"bar\"]->"+THIS+"$Bar[\"baz\"]",
                    ex.getPathReference());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
@@@
Split test: com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithJsonCreatorDeserialization::testShouldThrowJsonMappingExceptionWithPathReference
file: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/TestExceptionHandlingWithJsonCreatorDeserialization.java
Begin: Pos(52, 12)
End: Pos(67, 5)
Source: /tmp/JacksonDatabind_63/src/test/java//com/fasterxml/jackson/databind/deser/exc/TestExceptionHandlingWithJsonCreatorDeserialization.java
Name: testShouldThrowJsonMappingExceptionWithPathReference
Childs: [StatementAssertion<Begin: Pos(61, 13), End: Pos(61, 58)>,
StatementAssertion<Begin: Pos(64, 13), End: Pos(65, 43)>,
]
---
    public void testShouldThrowJsonMappingExceptionWithPathReference$catena_0() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";
        final String THIS = getClass().getName();

        // when
        try {
            mapper.readValue(input, Foo.class);
            fail("Upsss! Exception has not been thrown.");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException ex) {
            // then
            try{ assertEquals(THIS+"$Foo[\"bar\"]->"+THIS+"$Bar[\"baz\"]",
                    ex.getPathReference());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testShouldThrowJsonMappingExceptionWithPathReference$catena_1() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";
        final String THIS = getClass().getName();

        // when
        try {
            mapper.readValue(input, Foo.class);
            try{ fail("Upsss! Exception has not been thrown.");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException ex) {
            // then
            assertEquals(THIS+"$Foo[\"bar\"]->"+THIS+"$Bar[\"baz\"]",
                    ex.getPathReference());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_2
@@@
Split test: com.fasterxml.jackson.databind.node.TestConversions::testConversionOfPojos
file: /tmp/JacksonDatabind_2/src/test/java//com/fasterxml/jackson/databind/node/TestConversions.java
Begin: Pos(252, 12)
End: Pos(265, 5)
Source: /tmp/JacksonDatabind_2/src/test/java//com/fasterxml/jackson/databind/node/TestConversions.java
Name: testConversionOfPojos
Childs: [StatementAssertion<Begin: Pos(259, 9), End: Pos(259, 32)>,
StatementAssertion<Begin: Pos(263, 9), End: Pos(263, 80)>,
StatementAssertion<Begin: Pos(264, 9), End: Pos(264, 59)>,
]
---
    public void testConversionOfPojos$catena_0() throws Exception
    {
        final Issue467Bean input = new Issue467Bean(13);
        final String EXP = "{\"x\":13}";
        
        // first, sanity check
        String json = MAPPER.writeValueAsString(input);
        assertEquals(EXP, json);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        // then via conversions: should become JSON Object
        JsonNode tree = MAPPER.valueToTree(input);
        try{ assertTrue("Expected Object, got "+tree.getNodeType(), tree.isObject());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(EXP, MAPPER.writeValueAsString(tree));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testConversionOfPojos$catena_1() throws Exception
    {
        final Issue467Bean input = new Issue467Bean(13);
        final String EXP = "{\"x\":13}";
        
        // first, sanity check
        String json = MAPPER.writeValueAsString(input);
        try{ assertEquals(EXP, json);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // then via conversions: should become JSON Object
        JsonNode tree = MAPPER.valueToTree(input);
        assertTrue("Expected Object, got "+tree.getNodeType(), tree.isObject());                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(EXP, MAPPER.writeValueAsString(tree));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testConversionOfPojos$catena_2() throws Exception
    {
        final Issue467Bean input = new Issue467Bean(13);
        final String EXP = "{\"x\":13}";
        
        // first, sanity check
        String json = MAPPER.writeValueAsString(input);
        try{ assertEquals(EXP, json);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        // then via conversions: should become JSON Object
        JsonNode tree = MAPPER.valueToTree(input);
        try{ assertTrue("Expected Object, got "+tree.getNodeType(), tree.isObject());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(EXP, MAPPER.writeValueAsString(tree));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_54
@@@
Split test: com.fasterxml.jackson.databind.deser.TestJDKAtomicTypes::testEmpty1256
file: /tmp/JacksonDatabind_54/src/test/java//com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java
Begin: Pos(262, 12)
End: Pos(269, 5)
Source: /tmp/JacksonDatabind_54/src/test/java//com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java
Name: testEmpty1256
Childs: [StatementAssertion<Begin: Pos(268, 9), End: Pos(268, 33)>,
]
--------------------
Run: JacksonDatabind_40
@@@
Split test: com.fasterxml.jackson.databind.deser.TestSimpleTypes::testEmptyToNullCoercionForPrimitives
file: /tmp/JacksonDatabind_40/src/test/java//com/fasterxml/jackson/databind/deser/TestSimpleTypes.java
Begin: Pos(262, 12)
End: Pos(267, 5)
Source: /tmp/JacksonDatabind_40/src/test/java//com/fasterxml/jackson/databind/deser/TestSimpleTypes.java
Name: testEmptyToNullCoercionForPrimitives
Childs: [StatementAssertion<Begin: Pos(263, 9), End: Pos(263, 64)>,
StatementAssertion<Begin: Pos(264, 9), End: Pos(264, 62)>,
StatementAssertion<Begin: Pos(265, 9), End: Pos(265, 68)>,
StatementAssertion<Begin: Pos(266, 9), End: Pos(266, 67)>,
]
---
    public void testEmptyToNullCoercionForPrimitives$catena_0() throws Exception {
        _testEmptyToNullCoercion(int.class, Integer.valueOf(0));                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testEmptyToNullCoercion(long.class, Long.valueOf(0));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyToNullCoercionForPrimitives$catena_1() throws Exception {
        try{ _testEmptyToNullCoercion(int.class, Integer.valueOf(0));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        _testEmptyToNullCoercion(long.class, Long.valueOf(0));                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyToNullCoercionForPrimitives$catena_2() throws Exception {
        try{ _testEmptyToNullCoercion(int.class, Integer.valueOf(0));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(long.class, Long.valueOf(0));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyToNullCoercionForPrimitives$catena_3() throws Exception {
        try{ _testEmptyToNullCoercion(int.class, Integer.valueOf(0));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(long.class, Long.valueOf(0));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_79
@@@
Split test: com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1607
file: /tmp/JacksonDatabind_79/src/test/java//com/fasterxml/jackson/databind/objectid/AlwaysAsReferenceFirstTest.java
Begin: Pos(79, 12)
End: Pos(83, 5)
Source: /tmp/JacksonDatabind_79/src/test/java//com/fasterxml/jackson/databind/objectid/AlwaysAsReferenceFirstTest.java
Name: testIssue1607
Childs: [StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 77)>,
]
--------------------
Run: JacksonDatabind_67
@@@
Split test: com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumValueAndKeyViaModifier
file: /tmp/JacksonDatabind_67/src/test/java//com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
Begin: Pos(229, 5)
End: Pos(280, 5)
Source: /tmp/JacksonDatabind_67/src/test/java//com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
Name: testCustomEnumValueAndKeyViaModifier
Childs: [StatementAssertion<Begin: Pos(272, 9), End: Pos(272, 46)>,
StatementAssertion<Begin: Pos(278, 9), End: Pos(278, 36)>,
StatementAssertion<Begin: Pos(279, 9), End: Pos(279, 73)>,
]
---
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public void testCustomEnumValueAndKeyViaModifier$catena_0() throws IOException
    {
        SimpleModule module = new SimpleModule();
        module.setDeserializerModifier(new BeanDeserializerModifier() {        
            @Override
            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,
                    final JavaType type, BeanDescription beanDesc,
                    final JsonDeserializer<?> deserializer) {
                return new JsonDeserializer<Enum>() {
                    @Override
                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        final String str = p.getValueAsString().toLowerCase();
                        return KeyEnum.valueOf(rawClass, str);
                    }
                };
            }

            @Override
            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,
                    final JavaType type, KeyDeserializer deserializer)
            {
                if (!type.isEnumType()) {
                    return deserializer;
                }
                return new KeyDeserializer() {
                    @Override
                    public Object deserializeKey(String key, DeserializationContext ctxt)
                            throws IOException
                    {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        return Enum.valueOf(rawClass, key.toLowerCase());
                    }
                };
            }
        });
        ObjectMapper mapper = new ObjectMapper()
                .registerModule(module);

        // First, enum value as is
        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),
                KeyEnum.class);
        assertSame(KeyEnum.replacements, key);                                                              /***** ORIGINAL ASSERTION IS HERE *****/

        // and then as key
        EnumMap<KeyEnum,String> map = mapper.readValue(
                aposToQuotes("{'REPlaceMENTS':'foobar'}"),
                new TypeReference<EnumMap<KeyEnum,String>>() { });
        try{ assertEquals(1, map.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertSame(KeyEnum.replacements, map.keySet().iterator().next());                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public void testCustomEnumValueAndKeyViaModifier$catena_1() throws IOException
    {
        SimpleModule module = new SimpleModule();
        module.setDeserializerModifier(new BeanDeserializerModifier() {        
            @Override
            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,
                    final JavaType type, BeanDescription beanDesc,
                    final JsonDeserializer<?> deserializer) {
                return new JsonDeserializer<Enum>() {
                    @Override
                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        final String str = p.getValueAsString().toLowerCase();
                        return KeyEnum.valueOf(rawClass, str);
                    }
                };
            }

            @Override
            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,
                    final JavaType type, KeyDeserializer deserializer)
            {
                if (!type.isEnumType()) {
                    return deserializer;
                }
                return new KeyDeserializer() {
                    @Override
                    public Object deserializeKey(String key, DeserializationContext ctxt)
                            throws IOException
                    {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        return Enum.valueOf(rawClass, key.toLowerCase());
                    }
                };
            }
        });
        ObjectMapper mapper = new ObjectMapper()
                .registerModule(module);

        // First, enum value as is
        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),
                KeyEnum.class);
        try{ assertSame(KeyEnum.replacements, key);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then as key
        EnumMap<KeyEnum,String> map = mapper.readValue(
                aposToQuotes("{'REPlaceMENTS':'foobar'}"),
                new TypeReference<EnumMap<KeyEnum,String>>() { });
        assertEquals(1, map.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertSame(KeyEnum.replacements, map.keySet().iterator().next());                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public void testCustomEnumValueAndKeyViaModifier$catena_2() throws IOException
    {
        SimpleModule module = new SimpleModule();
        module.setDeserializerModifier(new BeanDeserializerModifier() {        
            @Override
            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,
                    final JavaType type, BeanDescription beanDesc,
                    final JsonDeserializer<?> deserializer) {
                return new JsonDeserializer<Enum>() {
                    @Override
                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        final String str = p.getValueAsString().toLowerCase();
                        return KeyEnum.valueOf(rawClass, str);
                    }
                };
            }

            @Override
            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,
                    final JavaType type, KeyDeserializer deserializer)
            {
                if (!type.isEnumType()) {
                    return deserializer;
                }
                return new KeyDeserializer() {
                    @Override
                    public Object deserializeKey(String key, DeserializationContext ctxt)
                            throws IOException
                    {
                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        return Enum.valueOf(rawClass, key.toLowerCase());
                    }
                };
            }
        });
        ObjectMapper mapper = new ObjectMapper()
                .registerModule(module);

        // First, enum value as is
        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),
                KeyEnum.class);
        try{ assertSame(KeyEnum.replacements, key);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then as key
        EnumMap<KeyEnum,String> map = mapper.readValue(
                aposToQuotes("{'REPlaceMENTS':'foobar'}"),
                new TypeReference<EnumMap<KeyEnum,String>>() { });
        try{ assertEquals(1, map.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertSame(KeyEnum.replacements, map.keySet().iterator().next());                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_20
@@@
Split test: com.fasterxml.jackson.databind.introspect.TestNamingStrategyStd::testNamingWithObjectNode
file: /tmp/JacksonDatabind_20/src/test/java//com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java
Begin: Pos(305, 12)
End: Pos(318, 5)
Source: /tmp/JacksonDatabind_20/src/test/java//com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java
Name: testNamingWithObjectNode
Childs: [StatementAssertion<Begin: Pos(313, 9), End: Pos(313, 30)>,
StatementAssertion<Begin: Pos(314, 9), End: Pos(314, 37)>,
StatementAssertion<Begin: Pos(315, 9), End: Pos(315, 35)>,
StatementAssertion<Begin: Pos(316, 9), End: Pos(316, 44)>,
StatementAssertion<Begin: Pos(317, 9), End: Pos(317, 63)>,
]
---
    public void testNamingWithObjectNode$catena_0() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
        ClassWithObjectNodeField result =
            m.readValue(
                "{ \"id\": \"1\", \"json\": { \"foo\": \"bar\", \"baz\": \"bing\" } }",
                ClassWithObjectNodeField.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("1", result.id);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.json);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.json.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("bing", result.json.path("baz").asText());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNamingWithObjectNode$catena_1() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
        ClassWithObjectNodeField result =
            m.readValue(
                "{ \"id\": \"1\", \"json\": { \"foo\": \"bar\", \"baz\": \"bing\" } }",
                ClassWithObjectNodeField.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("1", result.id);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.json);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.json.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("bing", result.json.path("baz").asText());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNamingWithObjectNode$catena_2() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
        ClassWithObjectNodeField result =
            m.readValue(
                "{ \"id\": \"1\", \"json\": { \"foo\": \"bar\", \"baz\": \"bing\" } }",
                ClassWithObjectNodeField.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", result.id);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.json);                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, result.json.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("bing", result.json.path("baz").asText());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNamingWithObjectNode$catena_3() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
        ClassWithObjectNodeField result =
            m.readValue(
                "{ \"id\": \"1\", \"json\": { \"foo\": \"bar\", \"baz\": \"bing\" } }",
                ClassWithObjectNodeField.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", result.id);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.json);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, result.json.size());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("bing", result.json.path("baz").asText());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNamingWithObjectNode$catena_4() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
        ClassWithObjectNodeField result =
            m.readValue(
                "{ \"id\": \"1\", \"json\": { \"foo\": \"bar\", \"baz\": \"bing\" } }",
                ClassWithObjectNodeField.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", result.id);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.json);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.json.size());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("bing", result.json.path("baz").asText());                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_28
@@@
Split test: com.fasterxml.jackson.databind.node.TestObjectNode::testIssue941
file: /tmp/JacksonDatabind_28/src/test/java//com/fasterxml/jackson/databind/node/TestObjectNode.java
Begin: Pos(401, 12)
End: Pos(413, 5)
Source: /tmp/JacksonDatabind_28/src/test/java//com/fasterxml/jackson/databind/node/TestObjectNode.java
Name: testIssue941
Childs: []
--------------------
Run: JacksonDatabind_23
@@@
Split test: com.fasterxml.jackson.databind.ser.TestJsonSerialize2::testEmptyInclusionScalars
file: /tmp/JacksonDatabind_23/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerialize2.java
Begin: Pos(221, 12)
End: Pos(245, 5)
Source: /tmp/JacksonDatabind_23/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerialize2.java
Name: testEmptyInclusionScalars
Childs: [StatementAssertion<Begin: Pos(228, 9), End: Pos(228, 74)>,
StatementAssertion<Begin: Pos(229, 9), End: Pos(229, 63)>,
StatementAssertion<Begin: Pos(230, 9), End: Pos(230, 79)>,
StatementAssertion<Begin: Pos(232, 9), End: Pos(232, 97)>,
StatementAssertion<Begin: Pos(233, 9), End: Pos(233, 81)>,
StatementAssertion<Begin: Pos(236, 9), End: Pos(236, 90)>,
StatementAssertion<Begin: Pos(237, 9), End: Pos(237, 77)>,
StatementAssertion<Begin: Pos(239, 9), End: Pos(239, 97)>,
StatementAssertion<Begin: Pos(240, 9), End: Pos(240, 82)>,
StatementAssertion<Begin: Pos(243, 9), End: Pos(243, 70)>,
StatementAssertion<Begin: Pos(244, 9), End: Pos(244, 64)>,
]
---
    public void testEmptyInclusionScalars$catena_0() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_1() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", inclMapper.writeValueAsString(str));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_2() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                             /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_3() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_4() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                           /***** ORIGINAL ASSERTION IS HERE *****/

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_5() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_6() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                               /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_7() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_8() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                          /***** ORIGINAL ASSERTION IS HERE *****/

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_9() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("{}", inclMapper.writeValueAsString(zero));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEmptyInclusionScalars$catena_10() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        try{ assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(str));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));                        }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));                      }catch(Throwable __SHOULD_BE_IGNORED){}

        // Then numbers
        try{ assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));                     }catch(Throwable __SHOULD_BE_IGNORED){}

        IntWrapper zero = new IntWrapper(0);
        try{ assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("{}", inclMapper.writeValueAsString(zero));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_100
@@@
Split test: com.fasterxml.jackson.databind.node.TestConversions::testBase64Text
file: /tmp/JacksonDatabind_100/src/test/java//com/fasterxml/jackson/databind/node/TestConversions.java
Begin: Pos(155, 12)
End: Pos(196, 5)
Source: /tmp/JacksonDatabind_100/src/test/java//com/fasterxml/jackson/databind/node/TestConversions.java
Name: testBase64Text
Childs: [StatementAssertion<Begin: Pos(178, 21), End: Pos(178, 95)>,
StatementAssertion<Begin: Pos(180, 17), End: Pos(180, 36)>,
StatementAssertion<Begin: Pos(181, 17), End: Pos(181, 47)>,
StatementAssertion<Begin: Pos(185, 17), End: Pos(185, 68)>,
StatementAssertion<Begin: Pos(189, 21), End: Pos(189, 95)>,
StatementAssertion<Begin: Pos(191, 17), End: Pos(191, 36)>,
StatementAssertion<Begin: Pos(192, 17), End: Pos(192, 47)>,
]
---
    public void testBase64Text$catena_0() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());             /***** ORIGINAL ASSERTION IS HERE *****/
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_1() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                assertNotNull(data);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_2() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                assertArrayEquals(data, input);                                                             /***** ORIGINAL ASSERTION IS HERE *****/

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_3() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                        /***** ORIGINAL ASSERTION IS HERE *****/
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_4() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());             /***** ORIGINAL ASSERTION IS HERE *****/
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_5() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                assertNotNull(data);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
                p.close();
            }
        }
    }
---
---
    public void testBase64Text$catena_6() throws Exception
    {
        // let's actually iterate over sets of encoding modes, lengths
        
        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };
        final Base64Variant[] VARIANTS = {
                Base64Variants.MIME,
                Base64Variants.MIME_NO_LINEFEEDS,
                Base64Variants.MODIFIED_FOR_URL,
                Base64Variants.PEM
        };

        for (int len : LENS) {
            byte[] input = new byte[len];
            for (int i = 0; i < input.length; ++i) {
                input[i] = (byte) i;
            }
            for (Base64Variant variant : VARIANTS) {
                TextNode n = new TextNode(variant.encode(input));
                byte[] data = null;
                try {
                    data = n.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try{ assertArrayEquals(data, input);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

                // 15-Aug-2018, tatu: [databind#2096] requires another test
                JsonParser p = new TreeTraversingParser(n);
                try{ assertEquals(JsonToken.VALUE_STRING, p.nextToken());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                try {
                    data = p.getBinaryValue(variant);
                } catch (Exception e) {
                    try{ fail("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());        }catch(Throwable __SHOULD_BE_IGNORED){}
                }
                try{ assertNotNull(data);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
                assertArrayEquals(data, input);                                                             /***** ORIGINAL ASSERTION IS HERE *****/
                p.close();
            }
        }
    }
---
--------------------
Run: JacksonDatabind_94
@@@
Split test: com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testC3P0Types
file: /tmp/JacksonDatabind_94/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Begin: Pos(113, 12)
End: Pos(116, 5)
Source: /tmp/JacksonDatabind_94/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Name: testC3P0Types
Childs: [StatementAssertion<Begin: Pos(115, 9), End: Pos(115, 54)>,
]
--------------------
Run: JacksonDatabind_80
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestTypeNames::testBaseTypeId1616
file: /tmp/JacksonDatabind_80/src/test/java//com/fasterxml/jackson/databind/jsontype/TestTypeNames.java
Begin: Pos(44, 12)
End: Pos(60, 5)
Source: /tmp/JacksonDatabind_80/src/test/java//com/fasterxml/jackson/databind/jsontype/TestTypeNames.java
Name: testBaseTypeId1616
Childs: [StatementAssertion<Begin: Pos(52, 9), End: Pos(52, 41)>,
StatementAssertion<Begin: Pos(57, 17), End: Pos(57, 103)>,
]
---
    public void testBaseTypeId1616$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(
                mapper.getDeserializationConfig(),
                // note: `null` is fine here as `AnnotatedMember`:
                null,
                mapper.constructType(Base1616.class));
        assertEquals(2, subtypes.size());                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        Set<String> ok = new HashSet<>(Arrays.asList("A", "B"));
        for (NamedType type : subtypes) {
            String id = type.getName();
            if (!ok.contains(id)) {
                try{ fail("Unexpected id '"+id+"' (mapping to: "+type.getType()+"), should be one of: "+ok);    }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testBaseTypeId1616$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(
                mapper.getDeserializationConfig(),
                // note: `null` is fine here as `AnnotatedMember`:
                null,
                mapper.constructType(Base1616.class));
        try{ assertEquals(2, subtypes.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        Set<String> ok = new HashSet<>(Arrays.asList("A", "B"));
        for (NamedType type : subtypes) {
            String id = type.getName();
            if (!ok.contains(id)) {
                fail("Unexpected id '"+id+"' (mapping to: "+type.getType()+"), should be one of: "+ok);         /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
--------------------
Run: JacksonDatabind_75
@@@
Split test: com.fasterxml.jackson.databind.struct.EnumFormatShapeTest::testEnumPropertyAsNumber
file: /tmp/JacksonDatabind_75/src/test/java//com/fasterxml/jackson/databind/struct/EnumFormatShapeTest.java
Begin: Pos(112, 12)
End: Pos(115, 5)
Source: /tmp/JacksonDatabind_75/src/test/java//com/fasterxml/jackson/databind/struct/EnumFormatShapeTest.java
Name: testEnumPropertyAsNumber
Childs: [StatementAssertion<Begin: Pos(113, 9), End: Pos(114, 74)>,
]
--------------------
Run: JacksonDatabind_7
@@@
Split test: com.fasterxml.jackson.databind.creators.TestCreatorsDelegating::testDelegateWithTokenBuffer
file: /tmp/JacksonDatabind_7/src/test/java//com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java
Begin: Pos(124, 12)
End: Pos(143, 5)
Source: /tmp/JacksonDatabind_7/src/test/java//com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java
Name: testDelegateWithTokenBuffer
Childs: [StatementAssertion<Begin: Pos(128, 9), End: Pos(128, 29)>,
StatementAssertion<Begin: Pos(130, 9), End: Pos(130, 55)>,
StatementAssertion<Begin: Pos(132, 9), End: Pos(132, 60)>,
StatementAssertion<Begin: Pos(133, 9), End: Pos(133, 58)>,
StatementAssertion<Begin: Pos(134, 9), End: Pos(134, 47)>,
StatementAssertion<Begin: Pos(135, 9), End: Pos(135, 64)>,
StatementAssertion<Begin: Pos(136, 9), End: Pos(136, 42)>,
StatementAssertion<Begin: Pos(137, 9), End: Pos(137, 58)>,
StatementAssertion<Begin: Pos(138, 9), End: Pos(138, 47)>,
StatementAssertion<Begin: Pos(139, 9), End: Pos(139, 64)>,
StatementAssertion<Begin: Pos(140, 9), End: Pos(140, 42)>,
StatementAssertion<Begin: Pos(141, 9), End: Pos(141, 58)>,
]
---
    public void testDelegateWithTokenBuffer$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        assertNotNull(value);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        assertEquals(TokenBuffer.class, ob.getClass());                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_2() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        assertToken(JsonToken.START_OBJECT, jp.nextToken());                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_3() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_4() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("a", jp.getCurrentName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_5() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_6() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, jp.getIntValue());                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_7() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_8() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("b", jp.getCurrentName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_9() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_10() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, jp.getIntValue());                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertToken(JsonToken.END_OBJECT, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        jp.close();
    }
---
---
    public void testDelegateWithTokenBuffer$catena_11() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        Value592 value = mapper.readValue("{\"a\":1,\"b\":2}", Value592.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = value.stuff;
        try{ assertEquals(TokenBuffer.class, ob.getClass());                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        JsonParser jp = ((TokenBuffer) ob).asParser();
        try{ assertToken(JsonToken.START_OBJECT, jp.nextToken());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("a", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.FIELD_NAME, jp.nextToken());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", jp.getCurrentName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, jp.getIntValue());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertToken(JsonToken.END_OBJECT, jp.nextToken());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        jp.close();
    }
---
--------------------
Run: JacksonDatabind_77
@@@
Split test: com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599
file: /tmp/JacksonDatabind_77/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Begin: Pos(16, 12)
End: Pos(39, 5)
Source: /tmp/JacksonDatabind_77/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Name: testIssue1599
Childs: [StatementAssertion<Begin: Pos(33, 13), End: Pos(33, 36)>,
StatementAssertion<Begin: Pos(35, 13), End: Pos(35, 47)>,
StatementAssertion<Begin: Pos(36, 13), End: Pos(36, 49)>,
StatementAssertion<Begin: Pos(37, 13), End: Pos(37, 65)>,
]
---
    public void testIssue1599$catena_0() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_1() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Illegal type");                                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_2() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            verifyException(e, "to deserialize");                                                           /***** ORIGINAL ASSERTION IS HERE *****/
            try{ verifyException(e, "prevented for security reasons");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testIssue1599$catena_3() throws Exception
    {
        final String JSON = aposToQuotes(
 "{'id': 124,\n"
+" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"
+"  {\n"
+"    'transletBytecodes' : [ 'AAIAZQ==' ],\n"
+"    'transletName' : 'a.b',\n"
+"    'outputProperties' : { }\n"
+"  }\n"
+" ]\n"
+"}"
        );
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        try {
            mapper.readValue(JSON, Bean1599.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Illegal type");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ verifyException(e, "to deserialize");                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            verifyException(e, "prevented for security reasons");                                           /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_3
@@@
Split test: com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testStringArray
file: /tmp/JacksonDatabind_3/src/test/java//com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java
Begin: Pos(243, 12)
End: Pos(270, 5)
Source: /tmp/JacksonDatabind_3/src/test/java//com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java
Name: testStringArray
Childs: [StatementAssertion<Begin: Pos(258, 9), End: Pos(258, 30)>,
StatementAssertion<Begin: Pos(260, 9), End: Pos(260, 49)>,
StatementAssertion<Begin: Pos(262, 13), End: Pos(262, 45)>,
StatementAssertion<Begin: Pos(267, 9), End: Pos(267, 30)>,
StatementAssertion<Begin: Pos(268, 9), End: Pos(268, 39)>,
StatementAssertion<Begin: Pos(269, 9), End: Pos(269, 30)>,
]
---
    public void testStringArray$catena_0() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(STRS.length, result.length);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        for (int i = 0; i < STRS.length; ++i) {
            try{ assertEquals(STRS[i], result[i]);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(result[0]);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStringArray$catena_1() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(STRS.length, result.length);                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        for (int i = 0; i < STRS.length; ++i) {
            try{ assertEquals(STRS[i], result[i]);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(result[0]);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStringArray$catena_2() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(STRS.length, result.length);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        for (int i = 0; i < STRS.length; ++i) {
            assertEquals(STRS[i], result[i]);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(result[0]);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStringArray$catena_3() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(STRS.length, result.length);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        for (int i = 0; i < STRS.length; ++i) {
            try{ assertEquals(STRS[i], result[i]);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(result[0]);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStringArray$catena_4() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(STRS.length, result.length);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        for (int i = 0; i < STRS.length; ++i) {
            try{ assertEquals(STRS[i], result[i]);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, result.length);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(result[0]);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testStringArray$catena_5() throws Exception
    {
        final String[] STRS = new String[] {
            "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",
        };
        StringWriter sw = new StringWriter();
        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);
        jg.writeStartArray();
        for (String str : STRS) {
            jg.writeString(str);
        }
        jg.writeEndArray();
        jg.close();

        String[] result = MAPPER.readValue(sw.toString(), String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(STRS.length, result.length);                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        for (int i = 0; i < STRS.length; ++i) {
            try{ assertEquals(STRS[i], result[i]);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // [#479]: null handling was busted in 2.4.0
        result = MAPPER.readValue(" [ null ]", String[].class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.length);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(result[0]);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_13
@@@
Split test: com.fasterxml.jackson.databind.struct.TestObjectIdDeserialization::testNullObjectId
file: /tmp/JacksonDatabind_13/src/test/java//com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java
Begin: Pos(460, 12)
End: Pos(468, 5)
Source: /tmp/JacksonDatabind_13/src/test/java//com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java
Name: testNullObjectId
Childs: [StatementAssertion<Begin: Pos(466, 9), End: Pos(466, 29)>,
StatementAssertion<Begin: Pos(467, 9), End: Pos(467, 37)>,
]
---
    public void testNullObjectId$catena_0() throws Exception
    {
        // Ok, so missing Object Id is ok, but so is null.
        
        Identifiable value = MAPPER.readValue
                (aposToQuotes("{'value':3, 'next':null, 'id':null}"), Identifiable.class);
        assertNotNull(value);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, value.value);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullObjectId$catena_1() throws Exception
    {
        // Ok, so missing Object Id is ok, but so is null.
        
        Identifiable value = MAPPER.readValue
                (aposToQuotes("{'value':3, 'next':null, 'id':null}"), Identifiable.class);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, value.value);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_5
@@@
Split test: com.fasterxml.jackson.databind.introspect.TestMixinMerging::testDisappearingMixins515
file: /tmp/JacksonDatabind_5/src/test/java//com/fasterxml/jackson/databind/introspect/TestMixinMerging.java
Begin: Pos(36, 12)
End: Pos(49, 5)
Source: /tmp/JacksonDatabind_5/src/test/java//com/fasterxml/jackson/databind/introspect/TestMixinMerging.java
Name: testDisappearingMixins515
Childs: [StatementAssertion<Begin: Pos(48, 9), End: Pos(48, 92)>,
]
--------------------
Run: JacksonDatabind_61
@@@
Split test: com.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest::testDefaultTypingWithLong
file: /tmp/JacksonDatabind_61/src/test/java//com/fasterxml/jackson/databind/jsontype/DefaultTypingWithPrimitivesTest.java
Begin: Pos(17, 12)
End: Pos(41, 5)
Source: /tmp/JacksonDatabind_61/src/test/java//com/fasterxml/jackson/databind/jsontype/DefaultTypingWithPrimitivesTest.java
Name: testDefaultTypingWithLong
Childs: [StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 30)>,
StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 39)>,
]
---
    public void testDefaultTypingWithLong$catena_0() throws Exception
    {
        Data data = new Data();
        data.key = 1L;
        Map<String, Object> mapData = new HashMap<String, Object>();
        mapData.put("longInMap", 2L);
        mapData.put("longAsField", data);

        // Configure Jackson to preserve types
        ObjectMapper mapper = new ObjectMapper();
        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();
        resolver.init(JsonTypeInfo.Id.CLASS, null);
        resolver.inclusion(JsonTypeInfo.As.PROPERTY);
        resolver.typeProperty("__t");
        mapper.setDefaultTyping(resolver);
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // Serialize
        String json = mapper.writeValueAsString(mapData);

        // Deserialize
        Map<?,?> result = mapper.readValue(json, Map.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, result.size());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDefaultTypingWithLong$catena_1() throws Exception
    {
        Data data = new Data();
        data.key = 1L;
        Map<String, Object> mapData = new HashMap<String, Object>();
        mapData.put("longInMap", 2L);
        mapData.put("longAsField", data);

        // Configure Jackson to preserve types
        ObjectMapper mapper = new ObjectMapper();
        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();
        resolver.init(JsonTypeInfo.Id.CLASS, null);
        resolver.inclusion(JsonTypeInfo.As.PROPERTY);
        resolver.typeProperty("__t");
        mapper.setDefaultTyping(resolver);
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // Serialize
        String json = mapper.writeValueAsString(mapData);

        // Deserialize
        Map<?,?> result = mapper.readValue(json, Map.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, result.size());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_4
@@@
Split test: com.fasterxml.jackson.databind.deser.TestCollectionDeserialization::testArrayIndexForExceptions
file: /tmp/JacksonDatabind_4/src/test/java//com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java
Begin: Pos(205, 12)
End: Pos(243, 5)
Source: /tmp/JacksonDatabind_4/src/test/java//com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java
Name: testArrayIndexForExceptions
Childs: [StatementAssertion<Begin: Pos(210, 13), End: Pos(210, 36)>,
StatementAssertion<Begin: Pos(212, 13), End: Pos(212, 54)>,
StatementAssertion<Begin: Pos(214, 13), End: Pos(214, 41)>,
StatementAssertion<Begin: Pos(215, 13), End: Pos(215, 52)>,
StatementAssertion<Begin: Pos(220, 13), End: Pos(220, 36)>,
StatementAssertion<Begin: Pos(222, 13), End: Pos(222, 54)>,
StatementAssertion<Begin: Pos(224, 13), End: Pos(224, 41)>,
StatementAssertion<Begin: Pos(225, 13), End: Pos(225, 52)>,
StatementAssertion<Begin: Pos(230, 13), End: Pos(230, 36)>,
StatementAssertion<Begin: Pos(232, 13), End: Pos(232, 54)>,
StatementAssertion<Begin: Pos(234, 13), End: Pos(234, 41)>,
StatementAssertion<Begin: Pos(236, 13), End: Pos(236, 53)>,
StatementAssertion<Begin: Pos(237, 13), End: Pos(237, 61)>,
StatementAssertion<Begin: Pos(240, 13), End: Pos(240, 52)>,
StatementAssertion<Begin: Pos(241, 13), End: Pos(241, 51)>,
]
---
    public void testArrayIndexForExceptions$catena_0() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_1() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Can not deserialize");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_2() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            assertEquals(1, refs.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_3() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(1, refs.get(0).getIndex());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_4() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_5() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Can not deserialize");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_6() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            assertEquals(1, refs.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_7() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(1, refs.get(0).getIndex());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_8() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_9() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            verifyException(e, "Can not deserialize");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_10() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            assertEquals(2, refs.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_11() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            assertEquals(-1, refs.get(0).getIndex());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_12() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals("keys", refs.get(0).getFieldName());                                               /***** ORIGINAL ASSERTION IS HERE *****/

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_13() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            assertEquals(1, refs.get(1).getIndex());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertNull(refs.get(1).getFieldName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testArrayIndexForExceptions$catena_14() throws Exception
    {
        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
        try {
            MAPPER.readValue(OBJECTS_JSON, Key[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(1, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(1, refs.get(0).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try {
            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JsonMappingException e) {
            try{ verifyException(e, "Can not deserialize");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
            List<JsonMappingException.Reference> refs = e.getPath();
            try{ assertEquals(2, refs.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
            // Bean has no index, but has name:
            try{ assertEquals(-1, refs.get(0).getIndex());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals("keys", refs.get(0).getFieldName());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

            // and for List, reverse:
            try{ assertEquals(1, refs.get(1).getIndex());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            assertNull(refs.get(1).getFieldName());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_81
@@@
Split test: com.fasterxml.jackson.databind.introspect.TypeCoercion1592Test::testTypeCoercion1592
file: /tmp/JacksonDatabind_81/src/test/java//com/fasterxml/jackson/databind/introspect/TypeCoercion1592Test.java
Begin: Pos(28, 12)
End: Pos(34, 5)
Source: /tmp/JacksonDatabind_81/src/test/java//com/fasterxml/jackson/databind/introspect/TypeCoercion1592Test.java
Name: testTypeCoercion1592
Childs: [StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 30)>,
]
--------------------
Run: JacksonDatabind_36
@@@
Split test: com.fasterxml.jackson.databind.TestStdDateFormat::testLenient
file: /tmp/JacksonDatabind_36/src/test/java//com/fasterxml/jackson/databind/TestStdDateFormat.java
Begin: Pos(19, 12)
End: Pos(57, 5)
Source: /tmp/JacksonDatabind_36/src/test/java//com/fasterxml/jackson/databind/TestStdDateFormat.java
Name: testLenient
Childs: [StatementAssertion<Begin: Pos(24, 9), End: Pos(24, 34)>,
StatementAssertion<Begin: Pos(27, 9), End: Pos(27, 35)>,
StatementAssertion<Begin: Pos(30, 9), End: Pos(30, 36)>,
StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 35)>,
StatementAssertion<Begin: Pos(37, 9), End: Pos(37, 36)>,
StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 36)>,
StatementAssertion<Begin: Pos(43, 9), End: Pos(43, 26)>,
StatementAssertion<Begin: Pos(48, 13), End: Pos(48, 36)>,
StatementAssertion<Begin: Pos(50, 13), End: Pos(50, 53)>,
StatementAssertion<Begin: Pos(56, 9), End: Pos(56, 26)>,
]
---
    public void testLenient$catena_0() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        assertTrue(f.isLenient());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_1() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_2() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_3() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_4() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_5() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        assertFalse(f3.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_6() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_7() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            fail("Should not pass");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_8() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            verifyException(e, "can not parse date");                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLenient$catena_9() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        StdDateFormat f2 = f.clone();
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        f2.setLenient(true);
        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        StdDateFormat f3 = f2.clone();
        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            try{ fail("Should not pass");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (ParseException e) {
            try{ verifyException(e, "can not parse date");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_44
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestSubtypes::testIssue1125WithDefault
file: /tmp/JacksonDatabind_44/src/test/java//com/fasterxml/jackson/databind/jsontype/TestSubtypes.java
Begin: Pos(317, 12)
End: Pos(327, 5)
Source: /tmp/JacksonDatabind_44/src/test/java//com/fasterxml/jackson/databind/jsontype/TestSubtypes.java
Name: testIssue1125WithDefault
Childs: [StatementAssertion<Begin: Pos(321, 9), End: Pos(321, 36)>,
StatementAssertion<Begin: Pos(322, 9), End: Pos(322, 65)>,
StatementAssertion<Begin: Pos(324, 9), End: Pos(324, 32)>,
StatementAssertion<Begin: Pos(325, 9), End: Pos(325, 32)>,
StatementAssertion<Begin: Pos(326, 9), End: Pos(326, 34)>,
]
---
    public void testIssue1125WithDefault$catena_0() throws Exception
    {
        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes("{'value':{'a':3,'def':9,'b':5}}"),
        		Issue1125Wrapper.class);
        assertNotNull(result.value);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Default1125.class, result.value.getClass());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Default1125 impl = (Default1125) result.value;
        try{ assertEquals(3, impl.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, impl.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(9, impl.def);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue1125WithDefault$catena_1() throws Exception
    {
        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes("{'value':{'a':3,'def':9,'b':5}}"),
        		Issue1125Wrapper.class);
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Default1125.class, result.value.getClass());                                           /***** ORIGINAL ASSERTION IS HERE *****/
        Default1125 impl = (Default1125) result.value;
        try{ assertEquals(3, impl.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, impl.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(9, impl.def);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue1125WithDefault$catena_2() throws Exception
    {
        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes("{'value':{'a':3,'def':9,'b':5}}"),
        		Issue1125Wrapper.class);
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Default1125.class, result.value.getClass());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Default1125 impl = (Default1125) result.value;
        assertEquals(3, impl.a);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(5, impl.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(9, impl.def);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue1125WithDefault$catena_3() throws Exception
    {
        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes("{'value':{'a':3,'def':9,'b':5}}"),
        		Issue1125Wrapper.class);
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Default1125.class, result.value.getClass());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Default1125 impl = (Default1125) result.value;
        try{ assertEquals(3, impl.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(5, impl.b);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(9, impl.def);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue1125WithDefault$catena_4() throws Exception
    {
        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes("{'value':{'a':3,'def':9,'b':5}}"),
        		Issue1125Wrapper.class);
        try{ assertNotNull(result.value);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Default1125.class, result.value.getClass());                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Default1125 impl = (Default1125) result.value;
        try{ assertEquals(3, impl.a);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, impl.b);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(9, impl.def);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_31
@@@
Split test: com.fasterxml.jackson.databind.util.TestTokenBuffer::testOutputContext
file: /tmp/JacksonDatabind_31/src/test/java//com/fasterxml/jackson/databind/util/TestTokenBuffer.java
Begin: Pos(257, 12)
End: Pos(311, 5)
Source: /tmp/JacksonDatabind_31/src/test/java//com/fasterxml/jackson/databind/util/TestTokenBuffer.java
Name: testOutputContext
Childs: [StatementAssertion<Begin: Pos(267, 9), End: Pos(267, 39)>,
StatementAssertion<Begin: Pos(271, 9), End: Pos(271, 39)>,
StatementAssertion<Begin: Pos(275, 9), End: Pos(275, 39)>,
StatementAssertion<Begin: Pos(279, 9), End: Pos(279, 39)>,
StatementAssertion<Begin: Pos(283, 9), End: Pos(283, 39)>,
StatementAssertion<Begin: Pos(287, 9), End: Pos(287, 39)>,
StatementAssertion<Begin: Pos(291, 9), End: Pos(291, 39)>,
StatementAssertion<Begin: Pos(295, 9), End: Pos(295, 39)>,
StatementAssertion<Begin: Pos(299, 9), End: Pos(299, 39)>,
StatementAssertion<Begin: Pos(303, 9), End: Pos(303, 39)>,
StatementAssertion<Begin: Pos(307, 9), End: Pos(307, 39)>,
]
---
    public void testOutputContext$catena_0() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_1() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_2() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_3() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_4() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_5() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_6() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_7() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_8() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_9() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        buf.writeEndArray();
        gen.writeEndArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.close();
        gen.close();
    }
---
---
    public void testOutputContext$catena_10() throws IOException
    {
        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec
        StringWriter w = new StringWriter();
        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);
 
        // test content: [{"a":1,"b":{"c":2}},{"a":2,"b":{"c":3}}]

        buf.writeStartArray();
        gen.writeStartArray();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("a");
        gen.writeFieldName("a");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(1);
        gen.writeNumber(1);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeFieldName("b");
        gen.writeFieldName("b");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeStartObject();
        gen.writeStartObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        
        buf.writeFieldName("c");
        gen.writeFieldName("c");
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeNumber(2);
        gen.writeNumber(2);
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndObject();
        gen.writeEndObject();
        try{ _verifyOutputContext(buf, gen);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        buf.writeEndArray();
        gen.writeEndArray();
        _verifyOutputContext(buf, gen);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        
        buf.close();
        gen.close();
    }
---
--------------------
Run: JacksonDatabind_104
@@@
Split test: com.fasterxml.jackson.databind.ser.jdk.DateSerializationTest::testDateISO8601_10k
file: /tmp/JacksonDatabind_104/src/test/java//com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
Begin: Pos(130, 12)
End: Pos(137, 5)
Source: /tmp/JacksonDatabind_104/src/test/java//com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
Name: testDateISO8601_10k
Childs: [StatementAssertion<Begin: Pos(134, 9), End: Pos(134, 101)>,
StatementAssertion<Begin: Pos(136, 9), End: Pos(136, 103)>,
]
---
    public void testDateISO8601_10k$catena_0() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, "UTC"),   "+10204-01-01T00:00:00.000+0000");           /***** ORIGINAL ASSERTION IS HERE *****/
        // and although specification lacks for beyond 5 digits (well, actually even 5...), let's do our best:
        try{ serialize(w, judate(123456, 1, 1,  00, 00, 00, 0, "UTC"),   "+123456-01-01T00:00:00.000+0000");    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateISO8601_10k$catena_1() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        try{ serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, "UTC"),   "+10204-01-01T00:00:00.000+0000");      }catch(Throwable __SHOULD_BE_IGNORED){}
        // and although specification lacks for beyond 5 digits (well, actually even 5...), let's do our best:
        serialize(w, judate(123456, 1, 1,  00, 00, 00, 0, "UTC"),   "+123456-01-01T00:00:00.000+0000");         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.ser.jdk.DateSerializationTest::testDateISO8601_BCE
file: /tmp/JacksonDatabind_104/src/test/java//com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
Begin: Pos(140, 12)
End: Pos(152, 5)
Source: /tmp/JacksonDatabind_104/src/test/java//com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
Name: testDateISO8601_BCE
Childs: [StatementAssertion<Begin: Pos(148, 9), End: Pos(148, 96)>,
StatementAssertion<Begin: Pos(149, 9), End: Pos(149, 97)>,
StatementAssertion<Begin: Pos(150, 9), End: Pos(150, 98)>,
StatementAssertion<Begin: Pos(151, 9), End: Pos(151, 99)>,
]
---
    public void testDateISO8601_BCE$catena_0() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // First: I _think_ BCE-1 is what you get with year 0, and should become "+0000"
        // and from further back in time, it'll be "-0001" (BCE-2) etc)

        serialize(w, judate(0, 1, 1,  00, 00, 00, 0, "UTC"),   "+0000-01-01T00:00:00.000+0000");                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, "UTC"),   "-0001-01-01T00:00:00.000+0000");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, "UTC"),   "-0049-01-01T00:00:00.000+0000");    }catch(Throwable __SHOULD_BE_IGNORED){} // All hail Caesar
        try{ serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, "UTC"),   "-0264-01-01T00:00:00.000+0000");     }catch(Throwable __SHOULD_BE_IGNORED){} // Carthage FTW?
    }
---
---
    public void testDateISO8601_BCE$catena_1() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // First: I _think_ BCE-1 is what you get with year 0, and should become "+0000"
        // and from further back in time, it'll be "-0001" (BCE-2) etc)

        try{ serialize(w, judate(0, 1, 1,  00, 00, 00, 0, "UTC"),   "+0000-01-01T00:00:00.000+0000");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, "UTC"),   "-0001-01-01T00:00:00.000+0000");                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, "UTC"),   "-0049-01-01T00:00:00.000+0000");    }catch(Throwable __SHOULD_BE_IGNORED){} // All hail Caesar
        try{ serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, "UTC"),   "-0264-01-01T00:00:00.000+0000");     }catch(Throwable __SHOULD_BE_IGNORED){} // Carthage FTW?
    }
---
---
    public void testDateISO8601_BCE$catena_2() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // First: I _think_ BCE-1 is what you get with year 0, and should become "+0000"
        // and from further back in time, it'll be "-0001" (BCE-2) etc)

        try{ serialize(w, judate(0, 1, 1,  00, 00, 00, 0, "UTC"),   "+0000-01-01T00:00:00.000+0000");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, "UTC"),   "-0001-01-01T00:00:00.000+0000");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, "UTC"),   "-0049-01-01T00:00:00.000+0000");         /***** ORIGINAL ASSERTION IS HERE *****/ // All hail Caesar
        try{ serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, "UTC"),   "-0264-01-01T00:00:00.000+0000");     }catch(Throwable __SHOULD_BE_IGNORED){} // Carthage FTW?
    }
---
---
    public void testDateISO8601_BCE$catena_3() throws IOException
    {
        ObjectWriter w = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // First: I _think_ BCE-1 is what you get with year 0, and should become "+0000"
        // and from further back in time, it'll be "-0001" (BCE-2) etc)

        try{ serialize(w, judate(0, 1, 1,  00, 00, 00, 0, "UTC"),   "+0000-01-01T00:00:00.000+0000");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, "UTC"),   "-0001-01-01T00:00:00.000+0000");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, "UTC"),   "-0049-01-01T00:00:00.000+0000");    }catch(Throwable __SHOULD_BE_IGNORED){} // All hail Caesar
        serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, "UTC"),   "-0264-01-01T00:00:00.000+0000");          /***** ORIGINAL ASSERTION IS HERE *****/ // Carthage FTW?
    }
---
--------------------
Run: JacksonDatabind_66
@@@
Split test: com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumKeySerializerWithPolymorphic
file: /tmp/JacksonDatabind_66/src/test/java//com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
Begin: Pos(207, 12)
End: Pos(225, 5)
Source: /tmp/JacksonDatabind_66/src/test/java//com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
Name: testCustomEnumKeySerializerWithPolymorphic
Childs: [StatementAssertion<Begin: Pos(223, 9), End: Pos(224, 58)>,
]
--------------------
Run: JacksonDatabind_85
@@@
Split test: com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern
file: /tmp/JacksonDatabind_85/src/test/java//com/fasterxml/jackson/databind/ser/DateSerializationTest.java
Begin: Pos(311, 12)
End: Pos(317, 5)
Source: /tmp/JacksonDatabind_85/src/test/java//com/fasterxml/jackson/databind/ser/DateSerializationTest.java
Name: testFormatWithoutPattern
Childs: [StatementAssertion<Begin: Pos(316, 9), End: Pos(316, 75)>,
]
--------------------
Run: JacksonDatabind_38
@@@
Split test: com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitMapType
file: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Begin: Pos(72, 5)
End: Pos(89, 5)
Source: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Name: testExplicitMapType
Childs: [StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 25)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 34)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 49)>,
StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 29)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 34)>,
]
---
    @SuppressWarnings("deprecation")
    public void testExplicitMapType$catena_0() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        assertNotNull(m);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, m.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = m.values().iterator().next();
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(3, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitMapType$catena_1() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, m.size());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        Object ob = m.values().iterator().next();
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(3, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitMapType$catena_2() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, m.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = m.values().iterator().next();
        assertEquals(Point.class, ob.getClass());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        Point p = (Point) ob;
        try{ assertEquals(3, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(5, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitMapType$catena_3() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, m.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = m.values().iterator().next();
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        assertEquals(3, p.x);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(5, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitMapType$catena_4() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        try{ assertNotNull(m);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, m.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = m.values().iterator().next();
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(3, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(5, p.getY());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitCollectionType
file: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Begin: Pos(54, 5)
End: Pos(70, 5)
Source: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Name: testExplicitCollectionType
Childs: [StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 25)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 34)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 49)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 29)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 34)>,
]
---
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType$catena_0() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        assertNotNull(l);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, l.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = l.get(0);
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType$catena_1() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        try{ assertNotNull(l);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, l.size());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        Object ob = l.get(0);
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType$catena_2() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        try{ assertNotNull(l);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, l.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = l.get(0);
        assertEquals(Point.class, ob.getClass());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        Point p = (Point) ob;
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType$catena_3() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        try{ assertNotNull(l);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, l.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = l.get(0);
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        assertEquals(1, p.x);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType$catena_4() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        try{ assertNotNull(l);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, l.size());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        Object ob = l.get(0);
        try{ assertEquals(Point.class, ob.getClass());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Point p = (Point) ob;
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getY());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testPOJOSubType
file: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Begin: Pos(42, 5)
End: Pos(52, 5)
Source: /tmp/JacksonDatabind_38/src/test/java//com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
Name: testPOJOSubType
Childs: [StatementAssertion<Begin: Pos(48, 9), End: Pos(48, 25)>,
StatementAssertion<Begin: Pos(49, 9), End: Pos(49, 29)>,
StatementAssertion<Begin: Pos(50, 9), End: Pos(50, 34)>,
StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 29)>,
]
---
    @SuppressWarnings("deprecation")
    public void testPOJOSubType$catena_0() throws Exception
    {
        JavaType elem = SimpleType.construct(Point3D.class);

        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
        assertNotNull(p);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.z);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testPOJOSubType$catena_1() throws Exception
    {
        JavaType elem = SimpleType.construct(Point3D.class);

        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
        try{ assertNotNull(p);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, p.x);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, p.z);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testPOJOSubType$catena_2() throws Exception
    {
        JavaType elem = SimpleType.construct(Point3D.class);

        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
        try{ assertNotNull(p);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, p.getY());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, p.z);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @SuppressWarnings("deprecation")
    public void testPOJOSubType$catena_3() throws Exception
    {
        JavaType elem = SimpleType.construct(Point3D.class);

        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
        try{ assertNotNull(p);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, p.x);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, p.getY());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, p.z);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_106
@@@
Split test: com.fasterxml.jackson.databind.node.TestTreeTraversingParser::testNumberOverflowLong
file: /tmp/JacksonDatabind_106/src/test/java//com/fasterxml/jackson/databind/node/TestTreeTraversingParser.java
Begin: Pos(314, 12)
End: Pos(353, 5)
Source: /tmp/JacksonDatabind_106/src/test/java//com/fasterxml/jackson/databind/node/TestTreeTraversingParser.java
Name: testNumberOverflowLong
Childs: [StatementAssertion<Begin: Pos(318, 13), End: Pos(318, 62)>,
StatementAssertion<Begin: Pos(319, 13), End: Pos(319, 67)>,
StatementAssertion<Begin: Pos(320, 13), End: Pos(320, 68)>,
StatementAssertion<Begin: Pos(323, 17), End: Pos(323, 61)>,
StatementAssertion<Begin: Pos(325, 17), End: Pos(325, 86)>,
StatementAssertion<Begin: Pos(329, 13), End: Pos(329, 63)>,
StatementAssertion<Begin: Pos(330, 13), End: Pos(330, 61)>,
StatementAssertion<Begin: Pos(331, 13), End: Pos(331, 67)>,
StatementAssertion<Begin: Pos(332, 13), End: Pos(332, 68)>,
StatementAssertion<Begin: Pos(335, 17), End: Pos(335, 61)>,
StatementAssertion<Begin: Pos(337, 17), End: Pos(337, 86)>,
StatementAssertion<Begin: Pos(343, 13), End: Pos(343, 62)>,
StatementAssertion<Begin: Pos(344, 13), End: Pos(344, 69)>,
StatementAssertion<Begin: Pos(345, 13), End: Pos(345, 63)>,
StatementAssertion<Begin: Pos(348, 17), End: Pos(348, 61)>,
StatementAssertion<Begin: Pos(350, 17), End: Pos(350, 87)>,
]
---
    public void testNumberOverflowLong$catena_0() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            assertToken(JsonToken.START_ARRAY, p.nextToken());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_1() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_2() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                        /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_3() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                fail("Expected failure for `long` overflow");                                               /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_4() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig+") out of range of long");                      /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_5() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            assertToken(JsonToken.START_OBJECT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_6() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.FIELD_NAME, p.nextToken());                                               /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_7() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_8() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                        /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_9() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                fail("Expected failure for `long` overflow");                                               /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_10() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig+") out of range of long");                      /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_11() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            assertToken(JsonToken.START_ARRAY, p.nextToken());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_12() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                       /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_13() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.DOUBLE, p.getNumberType());                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_14() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                fail("Expected failure for `long` overflow");                                               /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowLong$catena_15() throws IOException
    {
        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.BIG_INTEGER, p.getNumberType());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of long");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e30";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getLongValue();
                try{ fail("Expected failure for `long` overflow");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig2+") out of range of long");                     /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
@@@
Split test: com.fasterxml.jackson.databind.node.TestTreeTraversingParser::testNumberOverflowInt
file: /tmp/JacksonDatabind_106/src/test/java//com/fasterxml/jackson/databind/node/TestTreeTraversingParser.java
Begin: Pos(273, 12)
End: Pos(312, 5)
Source: /tmp/JacksonDatabind_106/src/test/java//com/fasterxml/jackson/databind/node/TestTreeTraversingParser.java
Name: testNumberOverflowInt
Childs: [StatementAssertion<Begin: Pos(277, 13), End: Pos(277, 62)>,
StatementAssertion<Begin: Pos(278, 13), End: Pos(278, 67)>,
StatementAssertion<Begin: Pos(279, 13), End: Pos(279, 61)>,
StatementAssertion<Begin: Pos(282, 17), End: Pos(282, 60)>,
StatementAssertion<Begin: Pos(284, 17), End: Pos(284, 85)>,
StatementAssertion<Begin: Pos(288, 13), End: Pos(288, 63)>,
StatementAssertion<Begin: Pos(289, 13), End: Pos(289, 61)>,
StatementAssertion<Begin: Pos(290, 13), End: Pos(290, 67)>,
StatementAssertion<Begin: Pos(291, 13), End: Pos(291, 61)>,
StatementAssertion<Begin: Pos(294, 17), End: Pos(294, 60)>,
StatementAssertion<Begin: Pos(296, 17), End: Pos(296, 85)>,
StatementAssertion<Begin: Pos(302, 13), End: Pos(302, 62)>,
StatementAssertion<Begin: Pos(303, 13), End: Pos(303, 69)>,
StatementAssertion<Begin: Pos(304, 13), End: Pos(304, 63)>,
StatementAssertion<Begin: Pos(307, 17), End: Pos(307, 60)>,
StatementAssertion<Begin: Pos(309, 17), End: Pos(309, 86)>,
]
---
    public void testNumberOverflowInt$catena_0() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            assertToken(JsonToken.START_ARRAY, p.nextToken());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_1() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_2() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.LONG, p.getNumberType());                                               /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_3() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Expected failure for `int` overflow");                                                /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_4() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig+") out of range of int");                       /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_5() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            assertToken(JsonToken.START_OBJECT, p.nextToken());                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_6() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.FIELD_NAME, p.nextToken());                                               /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_7() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_8() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.LONG, p.getNumberType());                                               /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_9() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Expected failure for `int` overflow");                                                /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_10() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig+") out of range of int");                       /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_11() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            assertToken(JsonToken.START_ARRAY, p.nextToken());                                              /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_12() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                       /***** ORIGINAL ASSERTION IS HERE *****/
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_13() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            assertEquals(NumberType.DOUBLE, p.getNumberType());                                             /***** ORIGINAL ASSERTION IS HERE *****/
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_14() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                fail("Expected failure for `int` overflow");                                                /***** ORIGINAL ASSERTION IS HERE *****/
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                 }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
    }
---
---
    public void testNumberOverflowInt$catena_15() throws IOException
    {
        final long tooBig = 1L + Integer.MAX_VALUE;
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        try (final JsonParser p = MAPPER.readTree("{ \"value\" : "+tooBig+" }").traverse()) {
            try{ assertToken(JsonToken.START_OBJECT, p.nextToken());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.FIELD_NAME, p.nextToken());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.LONG, p.getNumberType());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                try{ verifyException(e, "Numeric value ("+tooBig+") out of range of int");                  }catch(Throwable __SHOULD_BE_IGNORED){}
            }
        }
        // But also from floating-point
        final String tooBig2 = "1.0e10";
        try (final JsonParser p = MAPPER.readTree("[ "+tooBig2+" ]").traverse()) {
            try{ assertToken(JsonToken.START_ARRAY, p.nextToken());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
            try{ assertEquals(NumberType.DOUBLE, p.getNumberType());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
            try {
                p.getIntValue();
                try{ fail("Expected failure for `int` overflow");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
            } catch (InputCoercionException e) {
                verifyException(e, "Numeric value ("+tooBig2+") out of range of int");                      /***** ORIGINAL ASSERTION IS HERE *****/
            }
        }
    }
---
--------------------
Run: JacksonDatabind_92
@@@
Split test: com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testJDKTypes1737
file: /tmp/JacksonDatabind_92/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Begin: Pos(59, 12)
End: Pos(63, 5)
Source: /tmp/JacksonDatabind_92/src/test/java//com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java
Name: testJDKTypes1737
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 60)>,
StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 66)>,
]
---
    public void testJDKTypes1737$catena_0() throws Exception
    {
        _testTypes1737(java.util.logging.FileHandler.class);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ _testTypes1737(java.rmi.server.UnicastRemoteObject.class);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testJDKTypes1737$catena_1() throws Exception
    {
        try{ _testTypes1737(java.util.logging.FileHandler.class);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_47
@@@
Split test: com.fasterxml.jackson.databind.ser.TestJsonSerialize::testBrokenAnnotation
file: /tmp/JacksonDatabind_47/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerialize.java
Begin: Pos(147, 12)
End: Pos(154, 5)
Source: /tmp/JacksonDatabind_47/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerialize.java
Name: testBrokenAnnotation
Childs: [StatementAssertion<Begin: Pos(152, 13), End: Pos(152, 52)>,
]
@@@
Split test: com.fasterxml.jackson.databind.ser.TestJsonSerializeAs::testSpecializedAsIntermediate
file: /tmp/JacksonDatabind_47/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java
Begin: Pos(117, 12)
End: Pos(120, 5)
Source: /tmp/JacksonDatabind_47/src/test/java//com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java
Name: testSpecializedAsIntermediate
Childs: [StatementAssertion<Begin: Pos(118, 9), End: Pos(119, 65)>,
]
--------------------
Run: JacksonDatabind_90
@@@
Split test: com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test::testDelegatingArray1804
file: /tmp/JacksonDatabind_90/src/test/java//com/fasterxml/jackson/databind/creators/DelegatingArrayCreator1804Test.java
Begin: Pos(36, 12)
End: Pos(40, 5)
Source: /tmp/JacksonDatabind_90/src/test/java//com/fasterxml/jackson/databind/creators/DelegatingArrayCreator1804Test.java
Name: testDelegatingArray1804
Childs: [StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 29)>,
]
--------------------
Run: JacksonDatabind_32
@@@
Split test: com.fasterxml.jackson.databind.deser.TestUntypedDeserialization::testNestedUntyped989
file: /tmp/JacksonDatabind_32/src/test/java//com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
Begin: Pos(254, 12)
End: Pos(268, 5)
Source: /tmp/JacksonDatabind_32/src/test/java//com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
Name: testNestedUntyped989
Childs: [StatementAssertion<Begin: Pos(260, 9), End: Pos(260, 47)>,
StatementAssertion<Begin: Pos(262, 9), End: Pos(262, 47)>,
StatementAssertion<Begin: Pos(265, 9), End: Pos(265, 46)>,
StatementAssertion<Begin: Pos(267, 9), End: Pos(267, 46)>,
]
---
    public void testNestedUntyped989$catena_0() throws IOException
    {
        Untyped989 pojo;
        ObjectReader r = MAPPER.readerFor(Untyped989.class);

        pojo = r.readValue("[]");
        assertTrue(pojo.value instanceof List);                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        pojo = r.readValue("[{}]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        
        pojo = r.readValue("{}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("{\"a\":[]}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUntyped989$catena_1() throws IOException
    {
        Untyped989 pojo;
        ObjectReader r = MAPPER.readerFor(Untyped989.class);

        pojo = r.readValue("[]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("[{}]");
        assertTrue(pojo.value instanceof List);                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        
        pojo = r.readValue("{}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("{\"a\":[]}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUntyped989$catena_2() throws IOException
    {
        Untyped989 pojo;
        ObjectReader r = MAPPER.readerFor(Untyped989.class);

        pojo = r.readValue("[]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("[{}]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        
        pojo = r.readValue("{}");
        assertTrue(pojo.value instanceof Map);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        pojo = r.readValue("{\"a\":[]}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUntyped989$catena_3() throws IOException
    {
        Untyped989 pojo;
        ObjectReader r = MAPPER.readerFor(Untyped989.class);

        pojo = r.readValue("[]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("[{}]");
        try{ assertTrue(pojo.value instanceof List);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        
        pojo = r.readValue("{}");
        try{ assertTrue(pojo.value instanceof Map);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        pojo = r.readValue("{\"a\":[]}");
        assertTrue(pojo.value instanceof Map);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_111
@@@
Split test: com.fasterxml.jackson.databind.deser.jdk.JDKAtomicTypesDeserTest::testNullWithinNested
file: /tmp/JacksonDatabind_111/src/test/java//com/fasterxml/jackson/databind/deser/jdk/JDKAtomicTypesDeserTest.java
Begin: Pos(288, 12)
End: Pos(300, 5)
Source: /tmp/JacksonDatabind_111/src/test/java//com/fasterxml/jackson/databind/deser/jdk/JDKAtomicTypesDeserTest.java
Name: testNullWithinNested
Childs: [StatementAssertion<Begin: Pos(292, 9), End: Pos(292, 37)>,
StatementAssertion<Begin: Pos(293, 9), End: Pos(293, 43)>,
StatementAssertion<Begin: Pos(294, 9), End: Pos(294, 64)>,
StatementAssertion<Begin: Pos(297, 9), End: Pos(297, 38)>,
StatementAssertion<Begin: Pos(298, 9), End: Pos(298, 44)>,
StatementAssertion<Begin: Pos(299, 9), End: Pos(299, 47)>,
]
---
    public void testNullWithinNested$catena_0() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        assertNotNull(intRef.refRef);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(intRef.refRef.get());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(intRef.refRef.get().get(), new Integer(2));                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        try{ assertNotNull(nullRef.refRef);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(nullRef.refRef.get());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(nullRef.refRef.get().get());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullWithinNested$catena_1() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        try{ assertNotNull(intRef.refRef);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(intRef.refRef.get());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(intRef.refRef.get().get(), new Integer(2));                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        try{ assertNotNull(nullRef.refRef);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(nullRef.refRef.get());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(nullRef.refRef.get().get());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullWithinNested$catena_2() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        try{ assertNotNull(intRef.refRef);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(intRef.refRef.get());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(intRef.refRef.get().get(), new Integer(2));                                            /***** ORIGINAL ASSERTION IS HERE *****/

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        try{ assertNotNull(nullRef.refRef);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(nullRef.refRef.get());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(nullRef.refRef.get().get());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullWithinNested$catena_3() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        try{ assertNotNull(intRef.refRef);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(intRef.refRef.get());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(intRef.refRef.get().get(), new Integer(2));                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        assertNotNull(nullRef.refRef);                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(nullRef.refRef.get());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(nullRef.refRef.get().get());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullWithinNested$catena_4() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        try{ assertNotNull(intRef.refRef);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(intRef.refRef.get());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(intRef.refRef.get().get(), new Integer(2));                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        try{ assertNotNull(nullRef.refRef);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(nullRef.refRef.get());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(nullRef.refRef.get().get());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNullWithinNested$catena_5() throws Exception
    {
        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);
        MyBean2303 intRef = r.readValue(" {\"refRef\": 2 } ");
        try{ assertNotNull(intRef.refRef);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(intRef.refRef.get());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(intRef.refRef.get().get(), new Integer(2));                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        MyBean2303 nullRef = r.readValue(" {\"refRef\": null } ");
        try{ assertNotNull(nullRef.refRef);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(nullRef.refRef.get());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(nullRef.refRef.get().get());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_50
@@@
Split test: com.fasterxml.jackson.databind.objectid.ObjectWithCreator1261Test::testObjectIds1261
file: /tmp/JacksonDatabind_50/src/test/java//com/fasterxml/jackson/databind/objectid/ObjectWithCreator1261Test.java
Begin: Pos(66, 12)
End: Pos(85, 4)
Source: /tmp/JacksonDatabind_50/src/test/java//com/fasterxml/jackson/databind/objectid/ObjectWithCreator1261Test.java
Name: testObjectIds1261
Childs: [StatementAssertion<Begin: Pos(82, 19), End: Pos(83, 59)>,
]
--------------------
Run: JacksonDatabind_65
@@@
Split test: com.fasterxml.jackson.databind.deser.KeyDeser1429Test::testDeserializeKeyViaFactory
file: /tmp/JacksonDatabind_65/src/test/java//com/fasterxml/jackson/databind/deser/KeyDeser1429Test.java
Begin: Pos(37, 12)
End: Pos(47, 5)
Source: /tmp/JacksonDatabind_65/src/test/java//com/fasterxml/jackson/databind/deser/KeyDeser1429Test.java
Name: testDeserializeKeyViaFactory
Childs: [StatementAssertion<Begin: Pos(44, 9), End: Pos(44, 46)>,
StatementAssertion<Begin: Pos(45, 9), End: Pos(45, 44)>,
StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 60)>,
]
---
    public void testDeserializeKeyViaFactory$catena_0() throws Exception
    {
        Map<FullName, Double> map =
            new ObjectMapper().readValue("{\"first.last\": 42}",
                    new TypeReference<Map<FullName, Double>>() { });
        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();
        FullName key = entry.getKey();
        assertEquals(key._firstname, "first");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(key._lastname, "last");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(entry.getValue().doubleValue(), 42, 0);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDeserializeKeyViaFactory$catena_1() throws Exception
    {
        Map<FullName, Double> map =
            new ObjectMapper().readValue("{\"first.last\": 42}",
                    new TypeReference<Map<FullName, Double>>() { });
        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();
        FullName key = entry.getKey();
        try{ assertEquals(key._firstname, "first");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(key._lastname, "last");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(entry.getValue().doubleValue(), 42, 0);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDeserializeKeyViaFactory$catena_2() throws Exception
    {
        Map<FullName, Double> map =
            new ObjectMapper().readValue("{\"first.last\": 42}",
                    new TypeReference<Map<FullName, Double>>() { });
        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();
        FullName key = entry.getKey();
        try{ assertEquals(key._firstname, "first");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(key._lastname, "last");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(entry.getValue().doubleValue(), 42, 0);                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_112
@@@
Split test: com.fasterxml.jackson.databind.deser.creators.DelegatingArrayCreator2324Test::testDeserializeBagOfStrings
file: /tmp/JacksonDatabind_112/src/test/java//com/fasterxml/jackson/databind/deser/creators/DelegatingArrayCreator2324Test.java
Begin: Pos(58, 12)
End: Pos(62, 5)
Source: /tmp/JacksonDatabind_112/src/test/java//com/fasterxml/jackson/databind/deser/creators/DelegatingArrayCreator2324Test.java
Name: testDeserializeBagOfStrings
Childs: [StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 52)>,
]
--------------------
Run: JacksonDatabind_108
@@@
Split test: com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader
file: /tmp/JacksonDatabind_108/src/test/java//com/fasterxml/jackson/databind/node/EmptyContentAsTreeTest.java
Begin: Pos(59, 12)
End: Pos(90, 5)
Source: /tmp/JacksonDatabind_108/src/test/java//com/fasterxml/jackson/databind/node/EmptyContentAsTreeTest.java
Name: testNullFromEOFWithParserAndReader
Childs: [StatementAssertion<Begin: Pos(62, 13), End: Pos(62, 57)>,
StatementAssertion<Begin: Pos(65, 13), End: Pos(65, 57)>,
StatementAssertion<Begin: Pos(68, 13), End: Pos(68, 57)>,
StatementAssertion<Begin: Pos(71, 13), End: Pos(71, 57)>,
StatementAssertion<Begin: Pos(75, 13), End: Pos(75, 57)>,
StatementAssertion<Begin: Pos(78, 13), End: Pos(78, 57)>,
StatementAssertion<Begin: Pos(81, 13), End: Pos(81, 57)>,
StatementAssertion<Begin: Pos(85, 13), End: Pos(85, 57)>,
StatementAssertion<Begin: Pos(88, 13), End: Pos(88, 57)>,
]
---
    public void testNullFromEOFWithParserAndReader$catena_0() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_1() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_2() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_3() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_4() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_5() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_6() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_7() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testNullFromEOFWithParserAndReader$catena_8() throws Exception
    {
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {
            try{ _assertNullTree(MAPPER.reader().readTree(p));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {
            _assertNullTree(MAPPER.reader().readTree(p));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JacksonDatabind_59
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TypeRefinementForMapTest::testMapKeyRefinement1384
file: /tmp/JacksonDatabind_59/src/test/java//com/fasterxml/jackson/databind/jsontype/TypeRefinementForMapTest.java
Begin: Pos(119, 12)
End: Pos(131, 5)
Source: /tmp/JacksonDatabind_59/src/test/java//com/fasterxml/jackson/databind/jsontype/TypeRefinementForMapTest.java
Name: testMapKeyRefinement1384
Childs: [StatementAssertion<Begin: Pos(126, 9), End: Pos(126, 57)>,
StatementAssertion<Begin: Pos(128, 9), End: Pos(128, 56)>,
StatementAssertion<Begin: Pos(130, 9), End: Pos(130, 71)>,
]
---
    public void testMapKeyRefinement1384$catena_0() throws Exception
    {
        final String TEST_INSTANCE_SERIALIZED =
                "{\"mapProperty\":[\"java.util.HashMap\",{\"Compound|Key\":\"Value\"}]}";
        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);

        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);
        assertEquals(1, testInstance.mapProperty.size());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        Object key = testInstance.mapProperty.keySet().iterator().next();
        try{ assertEquals(CompoundKey.class, key.getClass());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        String testInstanceSerialized = mapper.writeValueAsString(testInstance);
        try{ assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapKeyRefinement1384$catena_1() throws Exception
    {
        final String TEST_INSTANCE_SERIALIZED =
                "{\"mapProperty\":[\"java.util.HashMap\",{\"Compound|Key\":\"Value\"}]}";
        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);

        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);
        try{ assertEquals(1, testInstance.mapProperty.size());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        Object key = testInstance.mapProperty.keySet().iterator().next();
        assertEquals(CompoundKey.class, key.getClass());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        String testInstanceSerialized = mapper.writeValueAsString(testInstance);
        try{ assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapKeyRefinement1384$catena_2() throws Exception
    {
        final String TEST_INSTANCE_SERIALIZED =
                "{\"mapProperty\":[\"java.util.HashMap\",{\"Compound|Key\":\"Value\"}]}";
        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);

        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);
        try{ assertEquals(1, testInstance.mapProperty.size());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        Object key = testInstance.mapProperty.keySet().iterator().next();
        try{ assertEquals(CompoundKey.class, key.getClass());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        String testInstanceSerialized = mapper.writeValueAsString(testInstance);
        assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_105
@@@
Split test: com.fasterxml.jackson.databind.deser.jdk.JDKScalarsTest::testVoidDeser
file: /tmp/JacksonDatabind_105/src/test/java//com/fasterxml/jackson/databind/deser/jdk/JDKScalarsTest.java
Begin: Pos(861, 12)
End: Pos(866, 5)
Source: /tmp/JacksonDatabind_105/src/test/java//com/fasterxml/jackson/databind/deser/jdk/JDKScalarsTest.java
Name: testVoidDeser
Childs: [StatementAssertion<Begin: Pos(865, 9), End: Pos(865, 31)>,
]
--------------------
Run: JacksonDatabind_110
@@@
Split test: com.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest::testUnmodifiableListFromLinkedList
file: /tmp/JacksonDatabind_110/src/test/java//com/fasterxml/jackson/databind/deser/jdk/UtilCollectionsTypesTest.java
Begin: Pos(64, 11)
End: Pos(76, 4)
Source: /tmp/JacksonDatabind_110/src/test/java//com/fasterxml/jackson/databind/deser/jdk/UtilCollectionsTypesTest.java
Name: testUnmodifiableListFromLinkedList
Childs: [StatementAssertion<Begin: Pos(72, 8), End: Pos(72, 32)>,
StatementAssertion<Begin: Pos(75, 8), End: Pos(75, 101)>,
]
---
   public void testUnmodifiableListFromLinkedList$catena_0() throws Exception {
       final List<String> input = new LinkedList<>();
       input.add("first");
       input.add("second");

       // Can't use simple "_verifyCollection" as type may change; instead use
       // bit more flexible check:
       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));
       assertEquals(input, act);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/

       // and this check may be bit fragile (may need to revisit), but is good enough for now:
       try{ assertEquals(Collections.unmodifiableList(new ArrayList<>(input)).getClass(), act.getClass());    }catch(Throwable __SHOULD_BE_IGNORED){}
   }
---
---
   public void testUnmodifiableListFromLinkedList$catena_1() throws Exception {
       final List<String> input = new LinkedList<>();
       input.add("first");
       input.add("second");

       // Can't use simple "_verifyCollection" as type may change; instead use
       // bit more flexible check:
       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));
       try{ assertEquals(input, act);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

       // and this check may be bit fragile (may need to revisit), but is good enough for now:
       assertEquals(Collections.unmodifiableList(new ArrayList<>(input)).getClass(), act.getClass());         /***** ORIGINAL ASSERTION IS HERE *****/
   }
---
--------------------
Run: JacksonDatabind_109
@@@
Split test: com.fasterxml.jackson.databind.ser.jdk.BigDecimalPlain2230Test::testBigIntegerAsPlainTest
file: /tmp/JacksonDatabind_109/src/test/java//com/fasterxml/jackson/databind/ser/jdk/BigDecimalPlain2230Test.java
Begin: Pos(23, 12)
End: Pos(36, 5)
Source: /tmp/JacksonDatabind_109/src/test/java//com/fasterxml/jackson/databind/ser/jdk/BigDecimalPlain2230Test.java
Name: testBigIntegerAsPlainTest
Childs: [StatementAssertion<Begin: Pos(29, 9), End: Pos(29, 98)>,
StatementAssertion<Begin: Pos(35, 9), End: Pos(35, 84)>,
]
---
    public void testBigIntegerAsPlainTest$catena_0() throws Exception
    {
        final String NORM_VALUE = "0.0000000005";
        final BigDecimal BD_VALUE = new BigDecimal(NORM_VALUE);
        final BigDecimalAsString INPUT = new BigDecimalAsString(BD_VALUE);
        // by default, use the default `toString()`
        assertEquals("{\"value\":\""+BD_VALUE.toString()+"\"}", MAPPER.writeValueAsString(INPUT));          /***** ORIGINAL ASSERTION IS HERE *****/

        // but can force to "plain" notation
        final ObjectMapper m = jsonMapperBuilder()
            .enable(StreamWriteFeature.WRITE_BIGDECIMAL_AS_PLAIN)
            .build();
        try{ assertEquals("{\"value\":\""+NORM_VALUE+"\"}", m.writeValueAsString(INPUT));                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testBigIntegerAsPlainTest$catena_1() throws Exception
    {
        final String NORM_VALUE = "0.0000000005";
        final BigDecimal BD_VALUE = new BigDecimal(NORM_VALUE);
        final BigDecimalAsString INPUT = new BigDecimalAsString(BD_VALUE);
        // by default, use the default `toString()`
        try{ assertEquals("{\"value\":\""+BD_VALUE.toString()+"\"}", MAPPER.writeValueAsString(INPUT));     }catch(Throwable __SHOULD_BE_IGNORED){}

        // but can force to "plain" notation
        final ObjectMapper m = jsonMapperBuilder()
            .enable(StreamWriteFeature.WRITE_BIGDECIMAL_AS_PLAIN)
            .build();
        assertEquals("{\"value\":\""+NORM_VALUE+"\"}", m.writeValueAsString(INPUT));                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_56
@@@
Split test: com.fasterxml.jackson.databind.deser.TestJdkTypes::testLocale
file: /tmp/JacksonDatabind_56/src/test/java//com/fasterxml/jackson/databind/deser/TestJdkTypes.java
Begin: Pos(142, 12)
End: Pos(154, 5)
Source: /tmp/JacksonDatabind_56/src/test/java//com/fasterxml/jackson/databind/deser/TestJdkTypes.java
Name: testLocale
Childs: [StatementAssertion<Begin: Pos(144, 9), End: Pos(144, 84)>,
StatementAssertion<Begin: Pos(145, 9), End: Pos(145, 93)>,
StatementAssertion<Begin: Pos(146, 9), End: Pos(147, 69)>,
StatementAssertion<Begin: Pos(148, 9), End: Pos(149, 64)>,
StatementAssertion<Begin: Pos(153, 9), End: Pos(153, 37)>,
]
---
    public void testLocale$catena_0() throws IOException
    {
        assertEquals(new Locale("en"), MAPPER.readValue(quote("en"), Locale.class));                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(new Locale("es", "ES"), MAPPER.readValue(quote("es_ES"), Locale.class));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("FI", "fi", "savo"),
                MAPPER.readValue(quote("fi_FI_savo"), Locale.class));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("en", "US"),
                MAPPER.readValue(quote("en-US"), Locale.class));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1123]
        Locale loc = MAPPER.readValue(quote(""), Locale.class);
        try{ assertSame(Locale.ROOT, loc);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocale$catena_1() throws IOException
    {
        try{ assertEquals(new Locale("en"), MAPPER.readValue(quote("en"), Locale.class));                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(new Locale("es", "ES"), MAPPER.readValue(quote("es_ES"), Locale.class));               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(new Locale("FI", "fi", "savo"),
                MAPPER.readValue(quote("fi_FI_savo"), Locale.class));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("en", "US"),
                MAPPER.readValue(quote("en-US"), Locale.class));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1123]
        Locale loc = MAPPER.readValue(quote(""), Locale.class);
        try{ assertSame(Locale.ROOT, loc);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocale$catena_2() throws IOException
    {
        try{ assertEquals(new Locale("en"), MAPPER.readValue(quote("en"), Locale.class));                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("es", "ES"), MAPPER.readValue(quote("es_ES"), Locale.class));          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(new Locale("FI", "fi", "savo"),
                MAPPER.readValue(quote("fi_FI_savo"), Locale.class));                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(new Locale("en", "US"),
                MAPPER.readValue(quote("en-US"), Locale.class));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1123]
        Locale loc = MAPPER.readValue(quote(""), Locale.class);
        try{ assertSame(Locale.ROOT, loc);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocale$catena_3() throws IOException
    {
        try{ assertEquals(new Locale("en"), MAPPER.readValue(quote("en"), Locale.class));                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("es", "ES"), MAPPER.readValue(quote("es_ES"), Locale.class));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("FI", "fi", "savo"),
                MAPPER.readValue(quote("fi_FI_savo"), Locale.class));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(new Locale("en", "US"),
                MAPPER.readValue(quote("en-US"), Locale.class));                                            /***** ORIGINAL ASSERTION IS HERE *****/

        // [databind#1123]
        Locale loc = MAPPER.readValue(quote(""), Locale.class);
        try{ assertSame(Locale.ROOT, loc);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testLocale$catena_4() throws IOException
    {
        try{ assertEquals(new Locale("en"), MAPPER.readValue(quote("en"), Locale.class));                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("es", "ES"), MAPPER.readValue(quote("es_ES"), Locale.class));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("FI", "fi", "savo"),
                MAPPER.readValue(quote("fi_FI_savo"), Locale.class));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(new Locale("en", "US"),
                MAPPER.readValue(quote("en-US"), Locale.class));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // [databind#1123]
        Locale loc = MAPPER.readValue(quote(""), Locale.class);
        assertSame(Locale.ROOT, loc);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_52
@@@
Split test: com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeId999Test::testExternalTypeId
file: /tmp/JacksonDatabind_52/src/test/java//com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeId999Test.java
Begin: Pos(40, 12)
End: Pos(54, 5)
Source: /tmp/JacksonDatabind_52/src/test/java//com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeId999Test.java
Name: testExternalTypeId
Childs: [StatementAssertion<Begin: Pos(45, 9), End: Pos(45, 27)>,
StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 35)>,
StatementAssertion<Begin: Pos(47, 9), End: Pos(47, 38)>,
StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 27)>,
StatementAssertion<Begin: Pos(52, 9), End: Pos(52, 35)>,
StatementAssertion<Begin: Pos(53, 9), End: Pos(53, 38)>,
]
---
    public void testExternalTypeId$catena_0() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        assertNotNull(msg);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeId$catena_1() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(msg.payload);                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeId$catena_2() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo", msg.type);                                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeId$catena_3() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        assertNotNull(msg);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeId$catena_4() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(msg.payload);                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testExternalTypeId$catena_5() throws Exception
    {
        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };

        Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("foo", msg.type);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then with different order
        msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type);
        try{ assertNotNull(msg);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(msg.payload);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo", msg.type);                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_69
@@@
Split test: com.fasterxml.jackson.databind.creators.Creator1476Test::testConstructorChoice
file: /tmp/JacksonDatabind_69/src/test/java//com/fasterxml/jackson/databind/creators/Creator1476Test.java
Begin: Pos(36, 12)
End: Pos(42, 5)
Source: /tmp/JacksonDatabind_69/src/test/java//com/fasterxml/jackson/databind/creators/Creator1476Test.java
Name: testConstructorChoice
Childs: [StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 44)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 51)>,
]
---
    public void testConstructorChoice$catena_0() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        SimplePojo pojo = mapper.readValue("{ \"intField\": 1, \"stringField\": \"foo\" }", SimplePojo.class);

        assertEquals(1, pojo.getIntField());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo", pojo.getStringField());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testConstructorChoice$catena_1() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        SimplePojo pojo = mapper.readValue("{ \"intField\": 1, \"stringField\": \"foo\" }", SimplePojo.class);

        try{ assertEquals(1, pojo.getIntField());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo", pojo.getStringField());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_39
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl::testUnknownTypeIDRecovery
file: /tmp/JacksonDatabind_39/src/test/java//com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java
Begin: Pos(215, 12)
End: Pos(231, 5)
Source: /tmp/JacksonDatabind_39/src/test/java//com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java
Name: testUnknownTypeIDRecovery
Childs: [StatementAssertion<Begin: Pos(224, 9), End: Pos(224, 27)>,
StatementAssertion<Begin: Pos(225, 9), End: Pos(225, 31)>,
StatementAssertion<Begin: Pos(229, 9), End: Pos(229, 28)>,
StatementAssertion<Begin: Pos(230, 9), End: Pos(230, 44)>,
]
---
    public void testUnknownTypeIDRecovery$catena_0() throws Exception
    {
        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(
                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);
        String json = aposToQuotes("{'version':0.0,'application':'123',"
                +"'item':{'type':'xevent','location':'location1'},"
                +"'item2':{'type':'event','location':'location1'}}");
        // can't read item2 - which is valid
        CallRecord r = reader.readValue(json);
        assertNull(r.item);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(r.item2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        json = aposToQuotes("{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}");
        CallRecord r3 = reader.readValue(json);
        try{ assertNull(r3.item);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("123", r3.application);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testUnknownTypeIDRecovery$catena_1() throws Exception
    {
        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(
                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);
        String json = aposToQuotes("{'version':0.0,'application':'123',"
                +"'item':{'type':'xevent','location':'location1'},"
                +"'item2':{'type':'event','location':'location1'}}");
        // can't read item2 - which is valid
        CallRecord r = reader.readValue(json);
        try{ assertNull(r.item);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(r.item2);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/

        json = aposToQuotes("{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}");
        CallRecord r3 = reader.readValue(json);
        try{ assertNull(r3.item);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("123", r3.application);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testUnknownTypeIDRecovery$catena_2() throws Exception
    {
        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(
                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);
        String json = aposToQuotes("{'version':0.0,'application':'123',"
                +"'item':{'type':'xevent','location':'location1'},"
                +"'item2':{'type':'event','location':'location1'}}");
        // can't read item2 - which is valid
        CallRecord r = reader.readValue(json);
        try{ assertNull(r.item);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(r.item2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        json = aposToQuotes("{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}");
        CallRecord r3 = reader.readValue(json);
        assertNull(r3.item);                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("123", r3.application);                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testUnknownTypeIDRecovery$catena_3() throws Exception
    {
        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(
                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);
        String json = aposToQuotes("{'version':0.0,'application':'123',"
                +"'item':{'type':'xevent','location':'location1'},"
                +"'item2':{'type':'event','location':'location1'}}");
        // can't read item2 - which is valid
        CallRecord r = reader.readValue(json);
        try{ assertNull(r.item);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(r.item2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        json = aposToQuotes("{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}");
        CallRecord r3 = reader.readValue(json);
        try{ assertNull(r3.item);                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("123", r3.application);                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_55
@@@
Split test: com.fasterxml.jackson.databind.ser.TestEnumSerialization::testEnumsWithJsonPropertyAsKey
file: /tmp/JacksonDatabind_55/src/test/java//com/fasterxml/jackson/databind/ser/TestEnumSerialization.java
Begin: Pos(437, 12)
End: Pos(442, 5)
Source: /tmp/JacksonDatabind_55/src/test/java//com/fasterxml/jackson/databind/ser/TestEnumSerialization.java
Name: testEnumsWithJsonPropertyAsKey
Childs: [StatementAssertion<Begin: Pos(441, 9), End: Pos(441, 76)>,
]
--------------------
Run: JacksonDatabind_73
@@@
Split test: com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnlyAndWriteOnly
file: /tmp/JacksonDatabind_73/src/test/java//com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java
Begin: Pos(61, 12)
End: Pos(70, 5)
Source: /tmp/JacksonDatabind_73/src/test/java//com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java
Name: testReadOnlyAndWriteOnly
Childs: [StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 40)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 30)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 34)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 34)>,
]
---
    public void testReadOnlyAndWriteOnly$catena_0() throws Exception
    {
        String json = MAPPER.writeValueAsString(new ReadXWriteY());
        assertEquals("{\"x\":1}", json);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        ReadXWriteY result = MAPPER.readValue("{\"x\":5, \"y\":6}", ReadXWriteY.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.x);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, result.y);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testReadOnlyAndWriteOnly$catena_1() throws Exception
    {
        String json = MAPPER.writeValueAsString(new ReadXWriteY());
        try{ assertEquals("{\"x\":1}", json);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        ReadXWriteY result = MAPPER.readValue("{\"x\":5, \"y\":6}", ReadXWriteY.class);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, result.x);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(6, result.y);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testReadOnlyAndWriteOnly$catena_2() throws Exception
    {
        String json = MAPPER.writeValueAsString(new ReadXWriteY());
        try{ assertEquals("{\"x\":1}", json);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        ReadXWriteY result = MAPPER.readValue("{\"x\":5, \"y\":6}", ReadXWriteY.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, result.x);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(6, result.y);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testReadOnlyAndWriteOnly$catena_3() throws Exception
    {
        String json = MAPPER.writeValueAsString(new ReadXWriteY());
        try{ assertEquals("{\"x\":1}", json);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        ReadXWriteY result = MAPPER.readValue("{\"x\":5, \"y\":6}", ReadXWriteY.class);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.x);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(6, result.y);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnly935
file: /tmp/JacksonDatabind_73/src/test/java//com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java
Begin: Pos(72, 12)
End: Pos(77, 5)
Source: /tmp/JacksonDatabind_73/src/test/java//com/fasterxml/jackson/databind/deser/ReadOrWriteOnlyTest.java
Name: testReadOnly935
Childs: [StatementAssertion<Begin: Pos(76, 9), End: Pos(76, 30)>,
]
--------------------
Run: JacksonDatabind_26
@@@
Split test: com.fasterxml.jackson.databind.TestJDKSerialization::testEnumHandlers
file: /tmp/JacksonDatabind_26/src/test/java//com/fasterxml/jackson/databind/TestJDKSerialization.java
Begin: Pos(71, 12)
End: Pos(102, 5)
Source: /tmp/JacksonDatabind_26/src/test/java//com/fasterxml/jackson/databind/TestJDKSerialization.java
Name: testEnumHandlers
Childs: [StatementAssertion<Begin: Pos(79, 9), End: Pos(79, 30)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 31)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 25)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 25)>,
StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 34)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 31)>,
]
---
    public void testEnumHandlers$catena_0() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        assertNotNull(result);                                                                              /***** ORIGINAL ASSERTION IS HERE *****/

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        try{ assertNotNull(mapper2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        try{ assertNotNull(r);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        try{ assertNotNull(w);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        try{ assertEquals(json, json2);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        EnumPOJO result2 = r.readValue(json2);
        try{ assertNotNull(result2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumHandlers$catena_1() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        assertNotNull(mapper2);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        try{ assertNotNull(r);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        try{ assertNotNull(w);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        try{ assertEquals(json, json2);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        EnumPOJO result2 = r.readValue(json2);
        try{ assertNotNull(result2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumHandlers$catena_2() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        try{ assertNotNull(mapper2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        assertNotNull(r);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        try{ assertNotNull(w);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        try{ assertEquals(json, json2);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        EnumPOJO result2 = r.readValue(json2);
        try{ assertNotNull(result2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumHandlers$catena_3() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        try{ assertNotNull(mapper2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        try{ assertNotNull(r);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        assertNotNull(w);                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        try{ assertEquals(json, json2);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        EnumPOJO result2 = r.readValue(json2);
        try{ assertNotNull(result2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumHandlers$catena_4() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        try{ assertNotNull(mapper2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        try{ assertNotNull(r);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        try{ assertNotNull(w);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        assertEquals(json, json2);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        EnumPOJO result2 = r.readValue(json2);
        try{ assertNotNull(result2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testEnumHandlers$catena_5() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // ensure we have serializers and/or deserializers, first
        String json = mapper.writerFor(EnumPOJO.class)
                .writeValueAsString(new EnumPOJO());
        EnumPOJO result = mapper.readerFor(EnumPOJO.class)
                .readValue(json);
        try{ assertNotNull(result);                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        // and then use JDK serialization to freeze/thaw objects
        byte[] bytes = jdkSerialize(mapper);
        ObjectMapper mapper2 = jdkDeserialize(bytes);
        try{ assertNotNull(mapper2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));
        ObjectReader r = jdkDeserialize(bytes);
        try{ assertNotNull(r);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic
         *    at this point; comment out for now. Try to fix later on.
         */
        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));
        ObjectWriter w = jdkDeserialize(bytes);
        try{ assertNotNull(w);                                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // plus, ensure objects are usable:
        String json2 = w.writeValueAsString(new EnumPOJO());
        try{ assertEquals(json, json2);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        EnumPOJO result2 = r.readValue(json2);
        assertNotNull(result2);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_14
@@@
Split test: com.fasterxml.jackson.databind.convert.TestUpdateValue::testIssue744
file: /tmp/JacksonDatabind_14/src/test/java//com/fasterxml/jackson/databind/convert/TestUpdateValue.java
Begin: Pos(187, 12)
End: Pos(225, 5)
Source: /tmp/JacksonDatabind_14/src/test/java//com/fasterxml/jackson/databind/convert/TestUpdateValue.java
Name: testIssue744
Childs: [StatementAssertion<Begin: Pos(202, 9), End: Pos(202, 45)>,
StatementAssertion<Begin: Pos(203, 9), End: Pos(203, 43)>,
StatementAssertion<Begin: Pos(206, 9), End: Pos(206, 43)>,
StatementAssertion<Begin: Pos(207, 9), End: Pos(207, 41)>,
StatementAssertion<Begin: Pos(213, 9), End: Pos(213, 45)>,
StatementAssertion<Begin: Pos(214, 9), End: Pos(214, 42)>,
StatementAssertion<Begin: Pos(216, 9), End: Pos(216, 45)>,
StatementAssertion<Begin: Pos(217, 9), End: Pos(217, 43)>,
StatementAssertion<Begin: Pos(219, 9), End: Pos(219, 43)>,
StatementAssertion<Begin: Pos(220, 9), End: Pos(220, 40)>,
StatementAssertion<Begin: Pos(223, 9), End: Pos(223, 43)>,
StatementAssertion<Begin: Pos(224, 9), End: Pos(224, 41)>,
]
---
    public void testIssue744$catena_0() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        assertEquals(5, dbNewViaString.da.i);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_1() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(13, dbNewViaString.k);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_2() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        assertEquals(5, dbNewViaNode.da.i);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_3() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(13, dbNewViaNode.k);                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_4() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        assertEquals(1, dbUpdViaString.da.i);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_5() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, dbUpdViaString.k);                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_6() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        assertEquals(5, dbUpdViaString.da.i);                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_7() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(13, dbUpdViaString.k);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_8() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(1, dbUpdViaNode.da.i);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_9() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, dbUpdViaNode.k);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_10() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        assertEquals(5, dbUpdViaNode.da.i);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(13, dbUpdViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIssue744$catena_11() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        try{ assertEquals(5, dbNewViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        try{ assertEquals(5, dbNewViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbNewViaNode.k);                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        try{ assertEquals(1, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaString.k);                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        try{ assertEquals(5, dbUpdViaString.da.i);                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(13, dbUpdViaString.k);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(1, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, dbUpdViaNode.k);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        try{ assertEquals(5, dbUpdViaNode.da.i);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(13, dbUpdViaNode.k);                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_24
@@@
Split test: com.fasterxml.jackson.databind.ser.TestConfig::testDateFormatConfig
file: /tmp/JacksonDatabind_24/src/test/java//com/fasterxml/jackson/databind/ser/TestConfig.java
Begin: Pos(195, 12)
End: Pos(225, 5)
Source: /tmp/JacksonDatabind_24/src/test/java//com/fasterxml/jackson/databind/ser/TestConfig.java
Name: testDateFormatConfig
Childs: [StatementAssertion<Begin: Pos(202, 9), End: Pos(202, 31)>,
StatementAssertion<Begin: Pos(203, 9), End: Pos(203, 31)>,
StatementAssertion<Begin: Pos(205, 13), End: Pos(205, 19)>,
StatementAssertion<Begin: Pos(209, 9), End: Pos(209, 73)>,
StatementAssertion<Begin: Pos(210, 9), End: Pos(210, 75)>,
StatementAssertion<Begin: Pos(213, 9), End: Pos(213, 69)>,
StatementAssertion<Begin: Pos(214, 9), End: Pos(214, 69)>,
StatementAssertion<Begin: Pos(221, 9), End: Pos(221, 73)>,
StatementAssertion<Begin: Pos(222, 9), End: Pos(222, 75)>,
StatementAssertion<Begin: Pos(223, 9), End: Pos(223, 69)>,
StatementAssertion<Begin: Pos(224, 9), End: Pos(224, 69)>,
]
---
    public void testDateFormatConfig$catena_0() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        assertEquals(tz1, tz1);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_1() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz2, tz2);                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_2() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_3() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_4() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                                 /***** ORIGINAL ASSERTION IS HERE *****/

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_5() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_6() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_7() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_8() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_9() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDateFormatConfig$catena_10() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles");
        TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time");

        // sanity checks
        try{ assertEquals(tz1, tz1);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz2, tz2);                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        if (tz1.equals(tz2)) {
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        }

        mapper.setTimeZone(tz1);
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}

        // also better stick via reader/writer as well
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        f.setTimeZone(tz2);
        mapper.setDateFormat(f);

        // should not change the timezone tho
        try{ assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(tz1, mapper.writer().getConfig().getTimeZone());                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_53
@@@
Split test: com.fasterxml.jackson.databind.jsontype.TypeRefinementForMap1215Test::testMapRefinement
file: /tmp/JacksonDatabind_53/src/test/java//com/fasterxml/jackson/databind/jsontype/TypeRefinementForMap1215Test.java
Begin: Pos(57, 12)
End: Pos(73, 5)
Source: /tmp/JacksonDatabind_53/src/test/java//com/fasterxml/jackson/databind/jsontype/TypeRefinementForMap1215Test.java
Name: testMapRefinement
Childs: [StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 35)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 34)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 43)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 29)>,
StatementAssertion<Begin: Pos(72, 9), End: Pos(72, 46)>,
]
---
    public void testMapRefinement$catena_0() throws Exception
    {
        String ID1 = "3a6383d4-8123-4c43-8b8d-7cedf3e59404";
        String ID2 = "81c3d978-90c4-4b00-8da1-1c39ffcab02c";
        String json = aposToQuotes(
"{'id':'"+ID1+"','items':[{'id':'"+ID2+"','property':'value'}]}");

        ObjectMapper m = new ObjectMapper();
        Data data = m.readValue(json, Data.class);

        assertEquals(ID1, data.id);                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(data.items);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, data.items.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        Item value = data.items.get(ID2);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", value.property);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapRefinement$catena_1() throws Exception
    {
        String ID1 = "3a6383d4-8123-4c43-8b8d-7cedf3e59404";
        String ID2 = "81c3d978-90c4-4b00-8da1-1c39ffcab02c";
        String json = aposToQuotes(
"{'id':'"+ID1+"','items':[{'id':'"+ID2+"','property':'value'}]}");

        ObjectMapper m = new ObjectMapper();
        Data data = m.readValue(json, Data.class);

        try{ assertEquals(ID1, data.id);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(data.items);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, data.items.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        Item value = data.items.get(ID2);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", value.property);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapRefinement$catena_2() throws Exception
    {
        String ID1 = "3a6383d4-8123-4c43-8b8d-7cedf3e59404";
        String ID2 = "81c3d978-90c4-4b00-8da1-1c39ffcab02c";
        String json = aposToQuotes(
"{'id':'"+ID1+"','items':[{'id':'"+ID2+"','property':'value'}]}");

        ObjectMapper m = new ObjectMapper();
        Data data = m.readValue(json, Data.class);

        try{ assertEquals(ID1, data.id);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(data.items);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, data.items.size());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        Item value = data.items.get(ID2);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("value", value.property);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapRefinement$catena_3() throws Exception
    {
        String ID1 = "3a6383d4-8123-4c43-8b8d-7cedf3e59404";
        String ID2 = "81c3d978-90c4-4b00-8da1-1c39ffcab02c";
        String json = aposToQuotes(
"{'id':'"+ID1+"','items':[{'id':'"+ID2+"','property':'value'}]}");

        ObjectMapper m = new ObjectMapper();
        Data data = m.readValue(json, Data.class);

        try{ assertEquals(ID1, data.id);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(data.items);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, data.items.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        Item value = data.items.get(ID2);
        assertNotNull(value);                                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("value", value.property);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMapRefinement$catena_4() throws Exception
    {
        String ID1 = "3a6383d4-8123-4c43-8b8d-7cedf3e59404";
        String ID2 = "81c3d978-90c4-4b00-8da1-1c39ffcab02c";
        String json = aposToQuotes(
"{'id':'"+ID1+"','items':[{'id':'"+ID2+"','property':'value'}]}");

        ObjectMapper m = new ObjectMapper();
        Data data = m.readValue(json, Data.class);

        try{ assertEquals(ID1, data.id);                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(data.items);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, data.items.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        Item value = data.items.get(ID2);
        try{ assertNotNull(value);                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("value", value.property);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonDatabind_6
@@@
Split test: com.fasterxml.jackson.databind.deser.TestDateDeserialization::testISO8601MissingSeconds
file: /tmp/JacksonDatabind_6/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Begin: Pos(186, 12)
End: Pos(201, 1)
Source: /tmp/JacksonDatabind_6/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Name: testISO8601MissingSeconds
Childs: [StatementAssertion<Begin: Pos(195, 9), End: Pos(195, 49)>,
StatementAssertion<Begin: Pos(196, 9), End: Pos(196, 59)>,
StatementAssertion<Begin: Pos(197, 9), End: Pos(197, 55)>,
StatementAssertion<Begin: Pos(198, 9), End: Pos(198, 58)>,
StatementAssertion<Begin: Pos(199, 9), End: Pos(199, 48)>,
StatementAssertion<Begin: Pos(200, 9), End: Pos(200, 53)>,
]
---
    public void testISO8601MissingSeconds$catena_0() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MILLISECOND));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
}
---
---
    public void testISO8601MissingSeconds$catena_1() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MILLISECOND));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
}
---
---
    public void testISO8601MissingSeconds$catena_2() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MILLISECOND));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
}
---
---
    public void testISO8601MissingSeconds$catena_3() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MILLISECOND));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
}
---
---
    public void testISO8601MissingSeconds$catena_4() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, c.get(Calendar.SECOND));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, c.get(Calendar.MILLISECOND));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
}
---
---
    public void testISO8601MissingSeconds$catena_5() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, c.get(Calendar.MILLISECOND));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
}
---
@@@
Split test: com.fasterxml.jackson.databind.deser.TestDateDeserialization::testISO8601PartialMilliseconds
file: /tmp/JacksonDatabind_6/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Begin: Pos(149, 12)
End: Pos(184, 5)
Source: /tmp/JacksonDatabind_6/src/test/java//com/fasterxml/jackson/databind/deser/TestDateDeserialization.java
Name: testISO8601PartialMilliseconds
Childs: [StatementAssertion<Begin: Pos(158, 9), End: Pos(158, 49)>,
StatementAssertion<Begin: Pos(159, 9), End: Pos(159, 62)>,
StatementAssertion<Begin: Pos(160, 9), End: Pos(160, 54)>,
StatementAssertion<Begin: Pos(161, 9), End: Pos(161, 55)>,
StatementAssertion<Begin: Pos(166, 9), End: Pos(166, 49)>,
StatementAssertion<Begin: Pos(167, 9), End: Pos(167, 62)>,
StatementAssertion<Begin: Pos(168, 9), End: Pos(168, 54)>,
StatementAssertion<Begin: Pos(169, 9), End: Pos(169, 58)>,
StatementAssertion<Begin: Pos(170, 9), End: Pos(170, 48)>,
StatementAssertion<Begin: Pos(171, 9), End: Pos(171, 48)>,
StatementAssertion<Begin: Pos(172, 9), End: Pos(172, 55)>,
StatementAssertion<Begin: Pos(177, 9), End: Pos(177, 49)>,
StatementAssertion<Begin: Pos(178, 9), End: Pos(178, 59)>,
StatementAssertion<Begin: Pos(179, 9), End: Pos(179, 55)>,
StatementAssertion<Begin: Pos(180, 9), End: Pos(180, 58)>,
StatementAssertion<Begin: Pos(181, 9), End: Pos(181, 49)>,
StatementAssertion<Begin: Pos(182, 9), End: Pos(182, 49)>,
StatementAssertion<Begin: Pos(183, 9), End: Pos(183, 55)>,
]
---
    public void testISO8601PartialMilliseconds$catena_0() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_1() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_2() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_3() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(600, c.get(Calendar.MILLISECOND));                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_4() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_5() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_6() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_7() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_8() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, c.get(Calendar.MINUTE));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_9() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, c.get(Calendar.SECOND));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_10() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(610, c.get(Calendar.MILLISECOND));                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_11() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_12() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_13() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_14() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_15() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(20, c.get(Calendar.MINUTE));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_16() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(30, c.get(Calendar.SECOND));                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(450, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testISO8601PartialMilliseconds$catena_17() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(600, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(2014, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(3, c.get(Calendar.DAY_OF_MONTH));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.MINUTE));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, c.get(Calendar.SECOND));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(610, c.get(Calendar.MILLISECOND));                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        try{ assertEquals(1997, c.get(Calendar.YEAR));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(Calendar.JULY, c.get(Calendar.MONTH));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(16, c.get(Calendar.DAY_OF_MONTH));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, c.get(Calendar.MINUTE));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(30, c.get(Calendar.SECOND));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(450, c.get(Calendar.MILLISECOND));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonXml_2
@@@
Split test: com.fasterxml.jackson.dataformat.xml.misc.XmlTextTest::testMixedContent
file: /tmp/JacksonXml_2/src/test/java//com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java
Begin: Pos(66, 12)
End: Pos(73, 5)
Source: /tmp/JacksonXml_2/src/test/java//com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java
Name: testMixedContent
Childs: [StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 39)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 37)>,
StatementAssertion<Begin: Pos(72, 9), End: Pos(72, 46)>,
]
---
    public void testMixedContent$catena_0() throws Exception
    {
        WindSpeed result = MAPPER.readValue("<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>",
                WindSpeed.class);
        assertEquals(27, result.value);                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.radius);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(20, result.radius.value);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMixedContent$catena_1() throws Exception
    {
        WindSpeed result = MAPPER.readValue("<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>",
                WindSpeed.class);
        try{ assertEquals(27, result.value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.radius);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(20, result.radius.value);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testMixedContent$catena_2() throws Exception
    {
        WindSpeed result = MAPPER.readValue("<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>",
                WindSpeed.class);
        try{ assertEquals(27, result.value);                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.radius);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(20, result.radius.value);                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonXml_3
@@@
Split test: com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest::testXmlAttributesWithNextTextValue
file: /tmp/JacksonXml_3/src/test/java//com/fasterxml/jackson/dataformat/xml/stream/XmlParserNextXxxTest.java
Begin: Pos(30, 12)
End: Pos(54, 5)
Source: /tmp/JacksonXml_3/src/test/java//com/fasterxml/jackson/dataformat/xml/stream/XmlParserNextXxxTest.java
Name: testXmlAttributesWithNextTextValue
Childs: [StatementAssertion<Begin: Pos(37, 9), End: Pos(37, 60)>,
StatementAssertion<Begin: Pos(38, 9), End: Pos(38, 58)>,
StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 49)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 46)>,
StatementAssertion<Begin: Pos(43, 9), End: Pos(43, 58)>,
StatementAssertion<Begin: Pos(44, 9), End: Pos(44, 52)>,
StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 45)>,
StatementAssertion<Begin: Pos(48, 9), End: Pos(48, 46)>,
StatementAssertion<Begin: Pos(50, 9), End: Pos(50, 40)>,
StatementAssertion<Begin: Pos(52, 9), End: Pos(52, 58)>,
]
---
    public void testXmlAttributesWithNextTextValue$catena_0() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        assertToken(JsonToken.START_OBJECT, xp.nextToken());                                      /***** ORIGINAL ASSERTION IS HERE *****/ // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_1() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                         /***** ORIGINAL ASSERTION IS HERE *****/ // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_2() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        assertEquals("max", xp.getCurrentName());                                                           /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_3() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("7", xp.nextTextValue());                                                              /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_4() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                      /***** ORIGINAL ASSERTION IS HERE *****/ // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_5() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        assertEquals("offset", xp.getCurrentName());                                                        /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_6() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("offset", xp.getText());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_7() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("9", xp.nextTextValue());                                                              /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_8() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("9", xp.getText());                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertToken(JsonToken.END_OBJECT, xp.nextToken());                                  }catch(Throwable __SHOULD_BE_IGNORED){} // </data>
        xp.close();
    }
---
---
    public void testXmlAttributesWithNextTextValue$catena_9() throws Exception
    {
        final String XML = "<data max=\"7\" offset=\"9\"/>";

        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));

        // First: verify handling without forcing array handling:
        try{ assertToken(JsonToken.START_OBJECT, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <data>
        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                    }catch(Throwable __SHOULD_BE_IGNORED){} // <max>
        try{ assertEquals("max", xp.getCurrentName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("7", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertToken(JsonToken.FIELD_NAME, xp.nextToken());                                 }catch(Throwable __SHOULD_BE_IGNORED){} // <offset>
        try{ assertEquals("offset", xp.getCurrentName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("offset", xp.getText());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.nextTextValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("9", xp.getText());                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

        assertToken(JsonToken.END_OBJECT, xp.nextToken());                                       /***** ORIGINAL ASSERTION IS HERE *****/ // </data>
        xp.close();
    }
---
--------------------
Run: JacksonXml_4
@@@
Split test: com.fasterxml.jackson.dataformat.xml.misc.RootNameTest::testDynamicRootName
file: /tmp/JacksonXml_4/src/test/java//com/fasterxml/jackson/dataformat/xml/misc/RootNameTest.java
Begin: Pos(67, 12)
End: Pos(82, 5)
Source: /tmp/JacksonXml_4/src/test/java//com/fasterxml/jackson/dataformat/xml/misc/RootNameTest.java
Name: testDynamicRootName
Childs: [StatementAssertion<Begin: Pos(74, 9), End: Pos(74, 59)>,
StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 50)>,
StatementAssertion<Begin: Pos(81, 9), End: Pos(81, 37)>,
]
---
    public void testDynamicRootName$catena_0() throws IOException
    {
        String xml;

        ObjectWriter w = _xmlMapper.writer().withRootName("rudy");

        xml = w.writeValueAsString(new StringBean("foo"));
        assertEquals("<rudy><text>foo</text></rudy>", xml);                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        xml = w.writeValueAsString(new StringBean(null));
        try{ assertEquals("<rudy><text/></rudy>", xml);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        // and even with null will respect configured root name
        xml = w.writeValueAsString(null);
        try{ assertEquals("<rudy/>", xml);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDynamicRootName$catena_1() throws IOException
    {
        String xml;

        ObjectWriter w = _xmlMapper.writer().withRootName("rudy");

        xml = w.writeValueAsString(new StringBean("foo"));
        try{ assertEquals("<rudy><text>foo</text></rudy>", xml);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        xml = w.writeValueAsString(new StringBean(null));
        assertEquals("<rudy><text/></rudy>", xml);                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        // and even with null will respect configured root name
        xml = w.writeValueAsString(null);
        try{ assertEquals("<rudy/>", xml);                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testDynamicRootName$catena_2() throws IOException
    {
        String xml;

        ObjectWriter w = _xmlMapper.writer().withRootName("rudy");

        xml = w.writeValueAsString(new StringBean("foo"));
        try{ assertEquals("<rudy><text>foo</text></rudy>", xml);                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        xml = w.writeValueAsString(new StringBean(null));
        try{ assertEquals("<rudy><text/></rudy>", xml);                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        // and even with null will respect configured root name
        xml = w.writeValueAsString(null);
        assertEquals("<rudy/>", xml);                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonXml_1
@@@
Split test: com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test::testNestedUnwrappedLists180
file: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedLists180Test.java
Begin: Pos(38, 12)
End: Pos(73, 5)
Source: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedLists180Test.java
Name: testNestedUnwrappedLists180
Childs: [StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 38)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 47)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 45)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 61)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 68)>,
StatementAssertion<Begin: Pos(72, 9), End: Pos(72, 45)>,
]
---
    public void testNestedUnwrappedLists180$catena_0() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        assertNotNull(result.records);                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(2, result.records.size());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.records.get(1));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.records.get(1).fields.size());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", result.records.get(1).fields.get(0).name);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, first one ought not be null should it? Ideally not...
        try{ assertNotNull(result.records.get(0));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUnwrappedLists180$catena_1() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        try{ assertNotNull(result.records);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(2, result.records.size());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(result.records.get(1));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.records.get(1).fields.size());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", result.records.get(1).fields.get(0).name);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, first one ought not be null should it? Ideally not...
        try{ assertNotNull(result.records.get(0));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUnwrappedLists180$catena_2() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        try{ assertNotNull(result.records);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.records.size());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(result.records.get(1));                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, result.records.get(1).fields.size());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", result.records.get(1).fields.get(0).name);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, first one ought not be null should it? Ideally not...
        try{ assertNotNull(result.records.get(0));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUnwrappedLists180$catena_3() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        try{ assertNotNull(result.records);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.records.size());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.records.get(1));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, result.records.get(1).fields.size());                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("b", result.records.get(1).fields.get(0).name);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, first one ought not be null should it? Ideally not...
        try{ assertNotNull(result.records.get(0));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUnwrappedLists180$catena_4() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        try{ assertNotNull(result.records);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.records.size());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.records.get(1));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.records.get(1).fields.size());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("b", result.records.get(1).fields.get(0).name);                                        /***** ORIGINAL ASSERTION IS HERE *****/

        // also, first one ought not be null should it? Ideally not...
        try{ assertNotNull(result.records.get(0));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedUnwrappedLists180$catena_5() throws Exception
    {
        /*
        Records recs = new Records();
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.add(new Record());
        recs.records.get(0).fields.add(new Field("a"));
        recs.records.get(2).fields.add(new Field("b"));

        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);
        */

        String xml =
"<Records>\n"
// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine
//+"<records>\n</records>\n"
+"<records></records>\n"
+"  <records>\n"
+"   <fields name='b'/>\n"
+"  </records>\n"
+"</Records>\n"
;
        
//System.out.println("XML: "+xml);

        Records result = MAPPER.readValue(xml, Records.class);
        try{ assertNotNull(result.records);                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(2, result.records.size());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(result.records.get(1));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, result.records.get(1).fields.size());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("b", result.records.get(1).fields.get(0).name);                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        // also, first one ought not be null should it? Ideally not...
        assertNotNull(result.records.get(0));                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest::testNestedWithEmpty2
file: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java
Begin: Pos(103, 12)
End: Pos(123, 5)
Source: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java
Name: testNestedWithEmpty2
Childs: [StatementAssertion<Begin: Pos(116, 9), End: Pos(116, 27)>,
StatementAssertion<Begin: Pos(117, 9), End: Pos(117, 53)>,
StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 62)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 43)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 52)>,
]
---
    public void testNestedWithEmpty2$catena_0() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"    <VehicleActivity>\n"
+"    </VehicleActivity>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        assertNotNull(svc);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);
        try{ assertNotNull(del.vehicleActivity);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, del.vehicleActivity.size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty2$catena_1() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"    <VehicleActivity>\n"
+"    </VehicleActivity>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(svc.vehicleMonitoringDelivery);                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);
        try{ assertNotNull(del.vehicleActivity);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, del.vehicleActivity.size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty2$catena_2() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"    <VehicleActivity>\n"
+"    </VehicleActivity>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(1, svc.vehicleMonitoringDelivery.size());                                              /***** ORIGINAL ASSERTION IS HERE *****/
        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);
        try{ assertNotNull(del.vehicleActivity);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, del.vehicleActivity.size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty2$catena_3() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"    <VehicleActivity>\n"
+"    </VehicleActivity>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);
        assertNotNull(del.vehicleActivity);                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, del.vehicleActivity.size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty2$catena_4() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"    <VehicleActivity>\n"
+"    </VehicleActivity>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);
        try{ assertNotNull(del.vehicleActivity);                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        assertEquals(1, del.vehicleActivity.size());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest::testNestedWithEmpty
file: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java
Begin: Pos(86, 12)
End: Pos(101, 5)
Source: /tmp/JacksonXml_1/src/test/java//com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java
Name: testNestedWithEmpty
Childs: [StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 27)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 53)>,
StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 62)>,
]
---
    public void testNestedWithEmpty$catena_0() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        assertNotNull(svc);                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty$catena_1() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNotNull(svc.vehicleMonitoringDelivery);                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        try{ assertEquals(1, svc.vehicleMonitoringDelivery.size());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNestedWithEmpty$catena_2() throws Exception
    {
        final String XML =
"<ServiceDelivery>\n"
+"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\n"
+"  <VehicleMonitoringDelivery>\n"
+"  </VehicleMonitoringDelivery>\n"
+"</ServiceDelivery>\n"
                ;
        
        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);
        try{ assertNotNull(svc);                                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNotNull(svc.vehicleMonitoringDelivery);                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        // 06-Jan-2015, tatu: Really should have one empty entry, not 0
        assertEquals(1, svc.vehicleMonitoringDelivery.size());                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JacksonXml_6
@@@
Split test: com.fasterxml.jackson.dataformat.xml.ser.TestBinaryStreamToXMLSerialization::testWith0Bytes
file: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Begin: Pos(16, 12)
End: Pos(20, 5)
Source: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Name: testWith0Bytes
Childs: [StatementAssertion<Begin: Pos(19, 9), End: Pos(19, 59)>,
]
@@@
Split test: com.fasterxml.jackson.dataformat.xml.ser.TestBinaryStreamToXMLSerialization::testWith2Bytes
file: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Begin: Pos(28, 12)
End: Pos(32, 5)
Source: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Name: testWith2Bytes
Childs: [StatementAssertion<Begin: Pos(31, 9), End: Pos(31, 70)>,
]
@@@
Split test: com.fasterxml.jackson.dataformat.xml.ser.TestBinaryStreamToXMLSerialization::testWith3Bytes
file: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Begin: Pos(34, 12)
End: Pos(38, 5)
Source: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Name: testWith3Bytes
Childs: [StatementAssertion<Begin: Pos(37, 9), End: Pos(37, 70)>,
]
@@@
Split test: com.fasterxml.jackson.dataformat.xml.ser.TestBinaryStreamToXMLSerialization::testWith4Bytes
file: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Begin: Pos(40, 12)
End: Pos(44, 5)
Source: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Name: testWith4Bytes
Childs: [StatementAssertion<Begin: Pos(43, 9), End: Pos(43, 74)>,
]
@@@
Split test: com.fasterxml.jackson.dataformat.xml.ser.TestBinaryStreamToXMLSerialization::testWith1Byte
file: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Begin: Pos(22, 12)
End: Pos(26, 5)
Source: /tmp/JacksonXml_6/src/test/java//com/fasterxml/jackson/dataformat/xml/ser/TestBinaryStreamToXMLSerialization.java
Name: testWith1Byte
Childs: [StatementAssertion<Begin: Pos(25, 9), End: Pos(25, 70)>,
]
--------------------
Run: Jsoup_30
@@@
Split test: org.jsoup.safety.CleanerTest::testIsValid
file: /tmp/Jsoup_30/src/test/java//org/jsoup/safety/CleanerTest.java
Begin: Pos(91, 5)
End: Pos(100, 5)
Source: /tmp/Jsoup_30/src/test/java//org/jsoup/safety/CleanerTest.java
Name: testIsValid
Childs: [StatementAssertion<Begin: Pos(96, 9), End: Pos(96, 57)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 60)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 60)>,
StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 60)>,
]
---
    @Test public void testIsValid$catena_0() {
        String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValid$catena_1() {
        String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValid$catena_2() {
        String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValid$catena_3() {
        String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_11
@@@
Split test: org.jsoup.select.SelectorTest::notAll
file: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(556, 5)
End: Pos(563, 5)
Source: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Name: notAll
Childs: [StatementAssertion<Begin: Pos(560, 9), End: Pos(560, 36)>,
StatementAssertion<Begin: Pos(561, 9), End: Pos(561, 52)>,
StatementAssertion<Begin: Pos(562, 9), End: Pos(562, 51)>,
]
---
    @Test public void notAll$catena_0() {
        Document doc = Jsoup.parse("<p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.body().select(":not(p)"); // should just be the span
        assertEquals(2, el1.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("body", el1.first().tagName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("span", el1.last().tagName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notAll$catena_1() {
        Document doc = Jsoup.parse("<p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.body().select(":not(p)"); // should just be the span
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("body", el1.first().tagName());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("span", el1.last().tagName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notAll$catena_2() {
        Document doc = Jsoup.parse("<p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.body().select(":not(p)"); // should just be the span
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("body", el1.first().tagName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("span", el1.last().tagName());                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.select.SelectorTest::testPseudoHas
file: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(405, 5)
End: Pos(428, 5)
Source: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Name: testPseudoHas
Childs: [StatementAssertion<Begin: Pos(409, 9), End: Pos(409, 38)>,
StatementAssertion<Begin: Pos(410, 9), End: Pos(410, 45)>,
StatementAssertion<Begin: Pos(411, 9), End: Pos(411, 45)>,
StatementAssertion<Begin: Pos(414, 9), End: Pos(414, 38)>,
StatementAssertion<Begin: Pos(415, 9), End: Pos(415, 45)>,
StatementAssertion<Begin: Pos(418, 9), End: Pos(418, 38)>,
StatementAssertion<Begin: Pos(419, 9), End: Pos(419, 45)>,
StatementAssertion<Begin: Pos(420, 9), End: Pos(420, 45)>,
StatementAssertion<Begin: Pos(421, 9), End: Pos(421, 45)>,
StatementAssertion<Begin: Pos(424, 9), End: Pos(424, 37)>,
StatementAssertion<Begin: Pos(425, 9), End: Pos(425, 53)>,
StatementAssertion<Begin: Pos(426, 9), End: Pos(426, 44)>,
StatementAssertion<Begin: Pos(427, 9), End: Pos(427, 44)>,
]
---
    @Test public void testPseudoHas$catena_0() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        assertEquals(2, divs1.size());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_1() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("0", divs1.get(0).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_2() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("1", divs1.get(1).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_3() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        assertEquals(1, divs2.size());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_4() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("1", divs2.get(0).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_5() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        assertEquals(3, divs3.size());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_6() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("0", divs3.get(0).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_7() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("1", divs3.get(1).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_8() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("2", divs3.get(2).id());                                                               /***** ORIGINAL ASSERTION IS HERE *****/

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_9() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        assertEquals(3, els1.size());                                                     /***** ORIGINAL ASSERTION IS HERE *****/ // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_10() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        assertEquals("body", els1.first().tagName());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_11() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("0", els1.get(1).id());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("2", els1.get(2).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testPseudoHas$catena_12() {
        Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>");

        Elements divs1 = doc.select("div:has(span)");
        try{ assertEquals(2, divs1.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs1.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs1.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs2 = doc.select("div:has([class]");
        try{ assertEquals(1, divs2.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs2.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements divs3 = doc.select("div:has(span, p)");
        try{ assertEquals(3, divs3.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", divs3.get(0).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("1", divs3.get(1).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("2", divs3.get(2).id());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements els1 = doc.body().select(":has(p)");
        try{ assertEquals(3, els1.size());                                                }catch(Throwable __SHOULD_BE_IGNORED){} // body, div, dib
        try{ assertEquals("body", els1.first().tagName());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("0", els1.get(1).id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("2", els1.get(2).id());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.select.SelectorTest::notClass
file: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(565, 5)
End: Pos(571, 5)
Source: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Name: notClass
Childs: [StatementAssertion<Begin: Pos(569, 9), End: Pos(569, 36)>,
StatementAssertion<Begin: Pos(570, 9), End: Pos(570, 44)>,
]
---
    @Test public void notClass$catena_0() {
        Document doc = Jsoup.parse("<div class=left>One</div><div class=right id=1><p>Two</p></div>");

        Elements el1 = doc.select("div:not(.left)");
        assertEquals(1, el1.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("1", el1.first().id());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notClass$catena_1() {
        Document doc = Jsoup.parse("<div class=left>One</div><div class=right id=1><p>Two</p></div>");

        Elements el1 = doc.select("div:not(.left)");
        try{ assertEquals(1, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("1", el1.first().id());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.select.SelectorTest::notParas
file: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(542, 5)
End: Pos(554, 5)
Source: /tmp/Jsoup_11/src/test/java//org/jsoup/select/SelectorTest.java
Name: notParas
Childs: [StatementAssertion<Begin: Pos(546, 9), End: Pos(546, 36)>,
StatementAssertion<Begin: Pos(547, 9), End: Pos(547, 48)>,
StatementAssertion<Begin: Pos(548, 9), End: Pos(548, 49)>,
StatementAssertion<Begin: Pos(551, 9), End: Pos(551, 36)>,
StatementAssertion<Begin: Pos(552, 9), End: Pos(552, 48)>,
StatementAssertion<Begin: Pos(553, 9), End: Pos(553, 47)>,
]
---
    @Test public void notParas$catena_0() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        assertEquals(2, el1.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Two", el1.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", el1.last().text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements el2 = doc.select("p:not(:has(span))");
        try{ assertEquals(2, el2.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", el2.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el2.last().text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notParas$catena_1() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Two", el1.first().text());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Three", el1.last().text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements el2 = doc.select("p:not(:has(span))");
        try{ assertEquals(2, el2.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", el2.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el2.last().text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notParas$catena_2() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el1.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Three", el1.last().text());                                                           /***** ORIGINAL ASSERTION IS HERE *****/

        Elements el2 = doc.select("p:not(:has(span))");
        try{ assertEquals(2, el2.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", el2.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el2.last().text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notParas$catena_3() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el1.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", el1.last().text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements el2 = doc.select("p:not(:has(span))");
        assertEquals(2, el2.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("One", el2.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el2.last().text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notParas$catena_4() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el1.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", el1.last().text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements el2 = doc.select("p:not(:has(span))");
        try{ assertEquals(2, el2.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("One", el2.first().text());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Two", el2.last().text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void notParas$catena_5() {
        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");

        Elements el1 = doc.select("p:not([id=1])");
        try{ assertEquals(2, el1.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", el1.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", el1.last().text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements el2 = doc.select("p:not(:has(span))");
        try{ assertEquals(2, el2.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", el2.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Two", el2.last().text());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_8
@@@
Split test: org.jsoup.nodes.ElementTest::parentlessToString
file: /tmp/Jsoup_8/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(416, 5)
End: Pos(423, 5)
Source: /tmp/Jsoup_8/src/test/java//org/jsoup/nodes/ElementTest.java
Name: parentlessToString
Childs: [StatementAssertion<Begin: Pos(419, 9), End: Pos(419, 62)>,
StatementAssertion<Begin: Pos(422, 9), End: Pos(422, 60)>,
]
---
    @Test public void parentlessToString$catena_0() {
        Document doc = Jsoup.parse("<img src='foo'>");
        Element img = doc.select("img").first();
        assertEquals("\n<img src=\"foo\" />", img.toString());                                              /***** ORIGINAL ASSERTION IS HERE *****/

        img.remove(); // lost its parent
        try{ assertEquals("<img src=\"foo\" />", img.toString());                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void parentlessToString$catena_1() {
        Document doc = Jsoup.parse("<img src='foo'>");
        Element img = doc.select("img").first();
        try{ assertEquals("\n<img src=\"foo\" />", img.toString());                                         }catch(Throwable __SHOULD_BE_IGNORED){}

        img.remove(); // lost its parent
        assertEquals("<img src=\"foo\" />", img.toString());                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_22
@@@
Split test: org.jsoup.nodes.ElementTest::elementIsNotASiblingOfItself
file: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(532, 5)
End: Pos(541, 5)
Source: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/ElementTest.java
Name: elementIsNotASiblingOfItself
Childs: [StatementAssertion<Begin: Pos(536, 9), End: Pos(536, 39)>,
StatementAssertion<Begin: Pos(538, 9), End: Pos(538, 36)>,
StatementAssertion<Begin: Pos(539, 9), End: Pos(539, 59)>,
StatementAssertion<Begin: Pos(540, 9), End: Pos(540, 61)>,
]
---
    @Test public void elementIsNotASiblingOfItself$catena_0() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        assertEquals("Two", p2.text());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        Elements els = p2.siblingElements();
        try{ assertEquals(2, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>One</p>", els.get(0).outerHtml());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>Three</p>", els.get(1).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void elementIsNotASiblingOfItself$catena_1() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        Elements els = p2.siblingElements();
        assertEquals(2, els.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<p>One</p>", els.get(0).outerHtml());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>Three</p>", els.get(1).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void elementIsNotASiblingOfItself$catena_2() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        Elements els = p2.siblingElements();
        try{ assertEquals(2, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<p>One</p>", els.get(0).outerHtml());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<p>Three</p>", els.get(1).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void elementIsNotASiblingOfItself$catena_3() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        Elements els = p2.siblingElements();
        try{ assertEquals(2, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>One</p>", els.get(0).outerHtml());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<p>Three</p>", els.get(1).outerHtml());                                               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.NodeTest::nodeIsNotASiblingOfItself
file: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/NodeTest.java
Begin: Pos(200, 5)
End: Pos(209, 5)
Source: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/NodeTest.java
Name: nodeIsNotASiblingOfItself
Childs: [StatementAssertion<Begin: Pos(204, 9), End: Pos(204, 39)>,
StatementAssertion<Begin: Pos(206, 9), End: Pos(206, 38)>,
StatementAssertion<Begin: Pos(207, 9), End: Pos(207, 61)>,
StatementAssertion<Begin: Pos(208, 9), End: Pos(208, 63)>,
]
---
    @Test public void nodeIsNotASiblingOfItself$catena_0() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        assertEquals("Two", p2.text());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        List<Node> nodes = p2.siblingNodes();
        try{ assertEquals(2, nodes.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>One</p>", nodes.get(0).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>Three</p>", nodes.get(1).outerHtml());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void nodeIsNotASiblingOfItself$catena_1() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        List<Node> nodes = p2.siblingNodes();
        assertEquals(2, nodes.size());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<p>One</p>", nodes.get(0).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>Three</p>", nodes.get(1).outerHtml());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void nodeIsNotASiblingOfItself$catena_2() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        List<Node> nodes = p2.siblingNodes();
        try{ assertEquals(2, nodes.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<p>One</p>", nodes.get(0).outerHtml());                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<p>Three</p>", nodes.get(1).outerHtml());                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void nodeIsNotASiblingOfItself$catena_3() {
        Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>");
        Element p2 = doc.select("p").get(1);

        try{ assertEquals("Two", p2.text());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        List<Node> nodes = p2.siblingNodes();
        try{ assertEquals(2, nodes.size());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<p>One</p>", nodes.get(0).outerHtml());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<p>Three</p>", nodes.get(1).outerHtml());                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.NodeTest::orphanNodeReturnsNullForSiblingElements
file: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/NodeTest.java
Begin: Pos(185, 5)
End: Pos(198, 5)
Source: /tmp/Jsoup_22/src/test/java//org/jsoup/nodes/NodeTest.java
Name: orphanNodeReturnsNullForSiblingElements
Childs: [StatementAssertion<Begin: Pos(189, 9), End: Pos(189, 45)>,
StatementAssertion<Begin: Pos(190, 9), End: Pos(190, 52)>,
StatementAssertion<Begin: Pos(192, 9), End: Pos(192, 43)>,
StatementAssertion<Begin: Pos(193, 9), End: Pos(193, 39)>,
StatementAssertion<Begin: Pos(195, 9), End: Pos(195, 53)>,
StatementAssertion<Begin: Pos(196, 9), End: Pos(196, 48)>,
StatementAssertion<Begin: Pos(197, 9), End: Pos(197, 44)>,
]
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_0() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        assertEquals(0, node.siblingIndex());                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_1() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(0, node.siblingNodes().size());                                                        /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_2() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        assertNull(node.previousSibling());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_3() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(node.nextSibling());                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_4() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(0, el.siblingElements().size());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_5() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(el.previousElementSibling());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertNull(el.nextElementSibling());                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void orphanNodeReturnsNullForSiblingElements$catena_6() {
        Node node = new Element(Tag.valueOf("p"), "");
        Element el = new Element(Tag.valueOf("p"), "");

        try{ assertEquals(0, node.siblingIndex());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(0, node.siblingNodes().size());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertNull(node.previousSibling());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(node.nextSibling());                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(0, el.siblingElements().size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertNull(el.previousElementSibling());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertNull(el.nextElementSibling());                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_49
@@@
Split test: org.jsoup.nodes.ElementTest::appendMustCorrectlyMoveChildrenInsideOneParentElement
file: /tmp/Jsoup_49/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(861, 5)
End: Pos(880, 5)
Source: /tmp/Jsoup_49/src/test/java//org/jsoup/nodes/ElementTest.java
Name: appendMustCorrectlyMoveChildrenInsideOneParentElement
Childs: [StatementAssertion<Begin: Pos(878, 9), End: Pos(878, 103)>,
]
--------------------
Run: Jsoup_58
@@@
Split test: org.jsoup.safety.CleanerTest::testIsValidBodyHtml
file: /tmp/Jsoup_58/src/test/java//org/jsoup/safety/CleanerTest.java
Begin: Pos(145, 5)
End: Pos(165, 5)
Source: /tmp/Jsoup_58/src/test/java//org/jsoup/safety/CleanerTest.java
Name: testIsValidBodyHtml
Childs: [StatementAssertion<Begin: Pos(155, 9), End: Pos(155, 57)>,
StatementAssertion<Begin: Pos(156, 9), End: Pos(156, 58)>,
StatementAssertion<Begin: Pos(157, 9), End: Pos(157, 60)>,
StatementAssertion<Begin: Pos(158, 9), End: Pos(158, 60)>,
StatementAssertion<Begin: Pos(159, 9), End: Pos(159, 60)>,
StatementAssertion<Begin: Pos(160, 9), End: Pos(160, 60)>,
StatementAssertion<Begin: Pos(161, 9), End: Pos(161, 60)>,
StatementAssertion<Begin: Pos(162, 9), End: Pos(162, 60)>,
StatementAssertion<Begin: Pos(163, 9), End: Pos(163, 57)>,
StatementAssertion<Begin: Pos(164, 9), End: Pos(164, 60)>,
]
---
    @Test public void testIsValidBodyHtml$catena_0() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_1() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_2() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_3() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_4() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_5() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_6() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_7() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_8() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidBodyHtml$catena_9() {
        String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>";
        String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; // missing enforced is OK because still needs run thru cleaner
        String nok1 = "<p><script></script>Not <b>OK</b></p>";
        String nok2 = "<p align=right>Test Not <b>OK</b></p>";
        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
        String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; // not body html
        String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>";
        String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; // missing close tag
        String nok7 = "</div>What";
        try{ assertTrue(Jsoup.isValid(ok, Whitelist.basic()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(Jsoup.isValid(ok, Whitelist.none()));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.safety.CleanerTest::testIsValidDocument
file: /tmp/Jsoup_58/src/test/java//org/jsoup/safety/CleanerTest.java
Begin: Pos(167, 5)
End: Pos(177, 5)
Source: /tmp/Jsoup_58/src/test/java//org/jsoup/safety/CleanerTest.java
Name: testIsValidDocument
Childs: [StatementAssertion<Begin: Pos(174, 9), End: Pos(174, 43)>,
StatementAssertion<Begin: Pos(175, 9), End: Pos(175, 55)>,
StatementAssertion<Begin: Pos(176, 9), End: Pos(176, 66)>,
]
---
    @Test public void testIsValidDocument$catena_0() {
        String ok = "<html><head></head><body><p>Hello</p></body><html>";
        String nok = "<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>";

        Whitelist relaxed = Whitelist.relaxed();
        Cleaner cleaner = new Cleaner(relaxed);
        Document okDoc = Jsoup.parse(ok);
        assertTrue(cleaner.isValid(okDoc));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(cleaner.isValid(Jsoup.parse(nok)));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidDocument$catena_1() {
        String ok = "<html><head></head><body><p>Hello</p></body><html>";
        String nok = "<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>";

        Whitelist relaxed = Whitelist.relaxed();
        Cleaner cleaner = new Cleaner(relaxed);
        Document okDoc = Jsoup.parse(ok);
        try{ assertTrue(cleaner.isValid(okDoc));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(cleaner.isValid(Jsoup.parse(nok)));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testIsValidDocument$catena_2() {
        String ok = "<html><head></head><body><p>Hello</p></body><html>";
        String nok = "<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>";

        Whitelist relaxed = Whitelist.relaxed();
        Cleaner cleaner = new Cleaner(relaxed);
        Document okDoc = Jsoup.parse(ok);
        try{ assertTrue(cleaner.isValid(okDoc));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertFalse(cleaner.isValid(Jsoup.parse(nok)));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_89
@@@
Split test: org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute
file: /tmp/Jsoup_89/src/test/java//org/jsoup/nodes/AttributeTest.java
Begin: Pos(41, 5)
End: Pos(49, 5)
Source: /tmp/Jsoup_89/src/test/java//org/jsoup/nodes/AttributeTest.java
Name: settersOnOrphanAttribute
Childs: [StatementAssertion<Begin: Pos(45, 9), End: Pos(45, 36)>,
StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 45)>,
StatementAssertion<Begin: Pos(47, 9), End: Pos(47, 46)>,
StatementAssertion<Begin: Pos(48, 9), End: Pos(48, 40)>,
]
---
    @Test public void settersOnOrphanAttribute$catena_0() {
        Attribute attr = new Attribute("one", "two");
        attr.setKey("three");
        String oldVal = attr.setValue("four");
        assertEquals("two", oldVal);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("three", attr.getKey());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("four", attr.getValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, attr.parent);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void settersOnOrphanAttribute$catena_1() {
        Attribute attr = new Attribute("one", "two");
        attr.setKey("three");
        String oldVal = attr.setValue("four");
        try{ assertEquals("two", oldVal);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("three", attr.getKey());                                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("four", attr.getValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, attr.parent);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void settersOnOrphanAttribute$catena_2() {
        Attribute attr = new Attribute("one", "two");
        attr.setKey("three");
        String oldVal = attr.setValue("four");
        try{ assertEquals("two", oldVal);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three", attr.getKey());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("four", attr.getValue());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, attr.parent);                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void settersOnOrphanAttribute$catena_3() {
        Attribute attr = new Attribute("one", "two");
        attr.setKey("three");
        String oldVal = attr.setValue("four");
        try{ assertEquals("two", oldVal);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three", attr.getKey());                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("four", attr.getValue());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, attr.parent);                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_60
@@@
Split test: org.jsoup.select.QueryParserTest::testParsesSingleQuoteInContains
file: /tmp/Jsoup_60/src/test/java//org/jsoup/select/QueryParserTest.java
Begin: Pos(47, 5)
End: Pos(49, 5)
Source: /tmp/Jsoup_60/src/test/java//org/jsoup/select/QueryParserTest.java
Name: testParsesSingleQuoteInContains
Childs: []
@@@
Split test: org.jsoup.select.QueryParserTest::exceptionOnUncloseAttribute
file: /tmp/Jsoup_60/src/test/java//org/jsoup/select/QueryParserTest.java
Begin: Pos(43, 5)
End: Pos(45, 5)
Source: /tmp/Jsoup_60/src/test/java//org/jsoup/select/QueryParserTest.java
Name: exceptionOnUncloseAttribute
Childs: []
--------------------
Run: Jsoup_87
@@@
Split test: org.jsoup.parser.HtmlParserTest::preservedCaseLinksCantNest
file: /tmp/Jsoup_87/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(1130, 5)
End: Pos(1136, 5)
Source: /tmp/Jsoup_87/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: preservedCaseLinksCantNest
Childs: [StatementAssertion<Begin: Pos(1135, 9), End: Pos(1135, 101)>,
]
--------------------
Run: Jsoup_42
@@@
Split test: org.jsoup.nodes.FormElementTest::createsFormData
file: /tmp/Jsoup_42/src/test/java//org/jsoup/nodes/FormElementTest.java
Begin: Pos(27, 5)
End: Pos(47, 5)
Source: /tmp/Jsoup_42/src/test/java//org/jsoup/nodes/FormElementTest.java
Name: createsFormData
Childs: [StatementAssertion<Begin: Pos(38, 9), End: Pos(38, 37)>,
StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 56)>,
StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 59)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 59)>,
StatementAssertion<Begin: Pos(42, 9), End: Pos(42, 58)>,
StatementAssertion<Begin: Pos(43, 9), End: Pos(43, 57)>,
StatementAssertion<Begin: Pos(44, 9), End: Pos(44, 57)>,
]
---
    @Test public void createsFormData$catena_0() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        assertEquals(6, data.size());                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_1() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("one=two", data.get(0).toString());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_2() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("three=four", data.get(1).toString());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_3() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("three=five", data.get(2).toString());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_4() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("six=seven", data.get(3).toString());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_5() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("seven=on", data.get(4).toString());                                            /***** ORIGINAL ASSERTION IS HERE *****/ // set
        try{ assertEquals("eight=on", data.get(5).toString());                                   }catch(Throwable __SHOULD_BE_IGNORED){} // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
---
    @Test public void createsFormData$catena_6() {
        String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" +
                "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" +
                "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                "<input name='ten' value='text' disabled>" +
                "</form>";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();

        try{ assertEquals(6, data.size());                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("one=two", data.get(0).toString());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=four", data.get(1).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("three=five", data.get(2).toString());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("six=seven", data.get(3).toString());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("seven=on", data.get(4).toString());                                       }catch(Throwable __SHOULD_BE_IGNORED){} // set
        assertEquals("eight=on", data.get(5).toString());                                        /***** ORIGINAL ASSERTION IS HERE *****/ // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
    }
---
@@@
Split test: org.jsoup.nodes.FormElementTest::usesOnForCheckboxValueIfNoValueSet
file: /tmp/Jsoup_42/src/test/java//org/jsoup/nodes/FormElementTest.java
Begin: Pos(118, 5)
End: Pos(124, 5)
Source: /tmp/Jsoup_42/src/test/java//org/jsoup/nodes/FormElementTest.java
Name: usesOnForCheckboxValueIfNoValueSet
Childs: [StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 48)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 47)>,
]
---
    @Test public void usesOnForCheckboxValueIfNoValueSet$catena_0() {
        Document doc = Jsoup.parse("<form><input type=checkbox checked name=foo></form>");
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();
        assertEquals("on", data.get(0).value());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("foo", data.get(0).key());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void usesOnForCheckboxValueIfNoValueSet$catena_1() {
        Document doc = Jsoup.parse("<form><input type=checkbox checked name=foo></form>");
        FormElement form = (FormElement) doc.select("form").first();
        List<Connection.KeyVal> data = form.formData();
        try{ assertEquals("on", data.get(0).value());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("foo", data.get(0).key());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_78
@@@
Split test: org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead
file: /tmp/Jsoup_78/src/test/java//org/jsoup/integration/ConnectTest.java
Begin: Pos(387, 5)
End: Pos(403, 5)
Source: /tmp/Jsoup_78/src/test/java//org/jsoup/integration/ConnectTest.java
Name: handlesEmptyStreamDuringParseRead
Childs: [StatementAssertion<Begin: Pos(398, 13), End: Pos(398, 56)>,
StatementAssertion<Begin: Pos(402, 9), End: Pos(402, 34)>,
]
---
    @Test
    public void handlesEmptyStreamDuringParseRead$catena_0() throws IOException {
        // this handles situations where the remote server sets a content length greater than it actually writes

        Connection.Response res = Jsoup.connect(InterruptedServlet.Url)
            .timeout(200)
            .execute();

        boolean threw = false;
        try {
            Document document = res.parse();
            assertEquals("Something", document.title());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IOException e) {
            threw = true;
        }
        try{ assertEquals(true, threw);                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void handlesEmptyStreamDuringParseRead$catena_1() throws IOException {
        // this handles situations where the remote server sets a content length greater than it actually writes

        Connection.Response res = Jsoup.connect(InterruptedServlet.Url)
            .timeout(200)
            .execute();

        boolean threw = false;
        try {
            Document document = res.parse();
            try{ assertEquals("Something", document.title());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IOException e) {
            threw = true;
        }
        assertEquals(true, threw);                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_64
@@@
Split test: org.jsoup.parser.HtmlParserTest::handlesKnownEmptyStyle
file: /tmp/Jsoup_64/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(373, 5)
End: Pos(377, 5)
Source: /tmp/Jsoup_64/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: handlesKnownEmptyStyle
Childs: [StatementAssertion<Begin: Pos(376, 9), End: Pos(376, 137)>,
]
@@@
Split test: org.jsoup.parser.HtmlParserTest::handlesKnownEmptyNoFrames
file: /tmp/Jsoup_64/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(367, 5)
End: Pos(371, 5)
Source: /tmp/Jsoup_64/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: handlesKnownEmptyNoFrames
Childs: [StatementAssertion<Begin: Pos(370, 9), End: Pos(370, 143)>,
]
--------------------
Run: Jsoup_29
@@@
Split test: org.jsoup.nodes.DocumentTest::testTitles
file: /tmp/Jsoup_29/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(22, 5)
End: Pos(38, 5)
Source: /tmp/Jsoup_29/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testTitles
Childs: [StatementAssertion<Begin: Pos(26, 9), End: Pos(26, 42)>,
StatementAssertion<Begin: Pos(28, 9), End: Pos(28, 47)>,
StatementAssertion<Begin: Pos(29, 9), End: Pos(29, 70)>,
StatementAssertion<Begin: Pos(31, 9), End: Pos(31, 49)>,
StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 49)>,
StatementAssertion<Begin: Pos(34, 9), End: Pos(34, 72)>,
StatementAssertion<Begin: Pos(37, 9), End: Pos(37, 64)>,
]
---
    @Test public void testTitles$catena_0() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        assertEquals("", noTitle.title());                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_1() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        assertEquals("Hello", noTitle.title());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_2() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Hello", noTitle.select("title").first().text());                                      /***** ORIGINAL ASSERTION IS HERE *****/
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_3() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        assertEquals("First", withTitle.title());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_4() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        assertEquals("Hello", withTitle.title());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_5() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Hello", withTitle.select("title").first().text());                                    /***** ORIGINAL ASSERTION IS HERE *****/

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        try{ assertEquals("Hello there now", normaliseTitle.title());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testTitles$catena_6() {
        Document noTitle = Jsoup.parse("<p>Hello</p>");
        Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>");
        
        try{ assertEquals("", noTitle.title());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        noTitle.title("Hello");
        try{ assertEquals("Hello", noTitle.title());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", noTitle.select("title").first().text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        
        try{ assertEquals("First", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        withTitle.title("Hello");
        try{ assertEquals("Hello", withTitle.title());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello", withTitle.select("title").first().text());                               }catch(Throwable __SHOULD_BE_IGNORED){}

        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
        assertEquals("Hello there now", normaliseTitle.title());                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_48
@@@
Split test: org.jsoup.helper.HttpConnectionTest::sameHeadersCombineWithComma
file: /tmp/Jsoup_48/src/test/java//org/jsoup/helper/HttpConnectionTest.java
Begin: Pos(55, 5)
End: Pos(64, 5)
Source: /tmp/Jsoup_48/src/test/java//org/jsoup/helper/HttpConnectionTest.java
Name: sameHeadersCombineWithComma
Childs: [StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 72)>,
]
--------------------
Run: Jsoup_21
@@@
Split test: org.jsoup.select.SelectorTest::handlesCommasInSelector
file: /tmp/Jsoup_21/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(588, 5)
End: Pos(599, 5)
Source: /tmp/Jsoup_21/src/test/java//org/jsoup/select/SelectorTest.java
Name: handlesCommasInSelector
Childs: [StatementAssertion<Begin: Pos(592, 9), End: Pos(592, 35)>,
StatementAssertion<Begin: Pos(595, 9), End: Pos(595, 43)>,
StatementAssertion<Begin: Pos(596, 9), End: Pos(596, 57)>,
StatementAssertion<Begin: Pos(597, 9), End: Pos(597, 56)>,
StatementAssertion<Begin: Pos(598, 9), End: Pos(598, 54)>,
]
---
    @Test public void handlesCommasInSelector$catena_0() {
        Document doc = Jsoup.parse("<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>");

        Elements ps = doc.select("[name=1,2]");
        assertEquals(1, ps.size());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        Elements containers = doc.select("div, li:matches([0-9,]+)");
        try{ assertEquals(2, containers.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("div", containers.get(0).tagName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("li", containers.get(1).tagName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("123", containers.get(1).text());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesCommasInSelector$catena_1() {
        Document doc = Jsoup.parse("<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>");

        Elements ps = doc.select("[name=1,2]");
        try{ assertEquals(1, ps.size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements containers = doc.select("div, li:matches([0-9,]+)");
        assertEquals(2, containers.size());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("div", containers.get(0).tagName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("li", containers.get(1).tagName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("123", containers.get(1).text());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesCommasInSelector$catena_2() {
        Document doc = Jsoup.parse("<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>");

        Elements ps = doc.select("[name=1,2]");
        try{ assertEquals(1, ps.size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements containers = doc.select("div, li:matches([0-9,]+)");
        try{ assertEquals(2, containers.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("div", containers.get(0).tagName());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("li", containers.get(1).tagName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("123", containers.get(1).text());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesCommasInSelector$catena_3() {
        Document doc = Jsoup.parse("<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>");

        Elements ps = doc.select("[name=1,2]");
        try{ assertEquals(1, ps.size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements containers = doc.select("div, li:matches([0-9,]+)");
        try{ assertEquals(2, containers.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("div", containers.get(0).tagName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("li", containers.get(1).tagName());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("123", containers.get(1).text());                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesCommasInSelector$catena_4() {
        Document doc = Jsoup.parse("<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>");

        Elements ps = doc.select("[name=1,2]");
        try{ assertEquals(1, ps.size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements containers = doc.select("div, li:matches([0-9,]+)");
        try{ assertEquals(2, containers.size());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("div", containers.get(0).tagName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("li", containers.get(1).tagName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("123", containers.get(1).text());                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.select.SelectorTest::mixCombinatorGroup
file: /tmp/Jsoup_21/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(324, 5)
End: Pos(332, 5)
Source: /tmp/Jsoup_21/src/test/java//org/jsoup/select/SelectorTest.java
Name: mixCombinatorGroup
Childs: [StatementAssertion<Begin: Pos(329, 9), End: Pos(329, 36)>,
StatementAssertion<Begin: Pos(330, 9), End: Pos(330, 49)>,
StatementAssertion<Begin: Pos(331, 9), End: Pos(331, 49)>,
]
---
    @Test public void mixCombinatorGroup$catena_0() {
        String h = "<div class=foo><ol><li>One<li>Two<li>Three</ol></div>";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(".foo > ol, ol > li + li");

        assertEquals(2, els.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("li", els.get(0).tagName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", els.get(1).text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void mixCombinatorGroup$catena_1() {
        String h = "<div class=foo><ol><li>One<li>Two<li>Three</ol></div>";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(".foo > ol, ol > li + li");

        try{ assertEquals(2, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("li", els.get(0).tagName());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Three", els.get(1).text());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void mixCombinatorGroup$catena_2() {
        String h = "<div class=foo><ol><li>One<li>Two<li>Three</ol></div>";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(".foo > ol, ol > li + li");

        try{ assertEquals(2, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("li", els.get(0).tagName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Three", els.get(1).text());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_18
@@@
Split test: org.jsoup.parser.CharacterReaderTest::handleCarriageReturnAsLineFeed
file: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/CharacterReaderTest.java
Begin: Pos(64, 5)
End: Pos(71, 5)
Source: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/CharacterReaderTest.java
Name: handleCarriageReturnAsLineFeed
Childs: [StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 36)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 58)>,
]
---
    @Test public void handleCarriageReturnAsLineFeed$catena_0() {
        String in = "one \r two \r\n three";
        CharacterReader r = new CharacterReader(in);

        String first = r.consumeTo('\n');
        assertEquals("one ", first);                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("\n two \n three", r.consumeToEnd());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handleCarriageReturnAsLineFeed$catena_1() {
        String in = "one \r two \r\n three";
        CharacterReader r = new CharacterReader(in);

        String first = r.consumeTo('\n');
        try{ assertEquals("one ", first);                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("\n two \n three", r.consumeToEnd());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.CharacterReaderTest::consumeToEnd
file: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/CharacterReaderTest.java
Begin: Pos(73, 5)
End: Pos(79, 5)
Source: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/CharacterReaderTest.java
Name: consumeToEnd
Childs: [StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 32)>,
StatementAssertion<Begin: Pos(78, 9), End: Pos(78, 32)>,
]
---
    @Test public void consumeToEnd$catena_0() {
        String in = "one two three";
        CharacterReader r = new CharacterReader(in);
        String toEnd = r.consumeToEnd();
        assertEquals(in, toEnd);                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(r.isEmpty());                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void consumeToEnd$catena_1() {
        String in = "one two three";
        CharacterReader r = new CharacterReader(in);
        String toEnd = r.consumeToEnd();
        try{ assertEquals(in, toEnd);                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(r.isEmpty());                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.ParserTest::handlesNewlinesAndWhitespaceInTag
file: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/ParserTest.java
Begin: Pos(617, 5)
End: Pos(620, 5)
Source: /tmp/Jsoup_18/src/test/java//org/jsoup/parser/ParserTest.java
Name: handlesNewlinesAndWhitespaceInTag
Childs: [StatementAssertion<Begin: Pos(619, 9), End: Pos(619, 75)>,
]
--------------------
Run: Jsoup_12
@@@
Split test: org.jsoup.select.SelectorTest::testByAttributeRegexCombined
file: /tmp/Jsoup_12/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(127, 5)
End: Pos(132, 5)
Source: /tmp/Jsoup_12/src/test/java//org/jsoup/select/SelectorTest.java
Name: testByAttributeRegexCombined
Childs: [StatementAssertion<Begin: Pos(130, 9), End: Pos(130, 36)>,
StatementAssertion<Begin: Pos(131, 9), End: Pos(131, 42)>,
]
---
    @Test public void testByAttributeRegexCombined$catena_0() {
        Document doc = Jsoup.parse("<div><table class=x><td>Hello</td></table></div>");
        Elements els = doc.select("div table[class~=x|y]");
        assertEquals(1, els.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Hello", els.text());                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testByAttributeRegexCombined$catena_1() {
        Document doc = Jsoup.parse("<div><table class=x><td>Hello</td></table></div>");
        Elements els = doc.select("div table[class~=x|y]");
        try{ assertEquals(1, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Hello", els.text());                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_16
@@@
Split test: org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration
file: /tmp/Jsoup_16/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Begin: Pos(28, 5)
End: Pos(40, 5)
Source: /tmp/Jsoup_16/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Name: outerHtmlGeneration
Childs: [StatementAssertion<Begin: Pos(30, 9), End: Pos(30, 59)>,
StatementAssertion<Begin: Pos(33, 9), End: Pos(33, 98)>,
StatementAssertion<Begin: Pos(36, 9), End: Pos(36, 130)>,
StatementAssertion<Begin: Pos(39, 9), End: Pos(39, 95)>,
]
---
    @Test public void outerHtmlGeneration$catena_0() {
        DocumentType html5 = new DocumentType("html", "", "", "");
        assertEquals("<!DOCTYPE html>", html5.outerHtml());                                                                                /***** ORIGINAL ASSERTION IS HERE *****/

        DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", "");
        try{ assertEquals("<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//\">", publicDocType.outerHtml());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType systemDocType = new DocumentType("html", "", "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", "");
        try{ assertEquals("<!DOCTYPE html \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\">", systemDocType.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType combo = new DocumentType("notHtml", "--public", "--system", "");
        try{ assertEquals("<!DOCTYPE notHtml PUBLIC \"--public\" \"--system\">", combo.outerHtml());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void outerHtmlGeneration$catena_1() {
        DocumentType html5 = new DocumentType("html", "", "", "");
        try{ assertEquals("<!DOCTYPE html>", html5.outerHtml());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", "");
        assertEquals("<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//\">", publicDocType.outerHtml());                                         /***** ORIGINAL ASSERTION IS HERE *****/

        DocumentType systemDocType = new DocumentType("html", "", "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", "");
        try{ assertEquals("<!DOCTYPE html \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\">", systemDocType.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType combo = new DocumentType("notHtml", "--public", "--system", "");
        try{ assertEquals("<!DOCTYPE notHtml PUBLIC \"--public\" \"--system\">", combo.outerHtml());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void outerHtmlGeneration$catena_2() {
        DocumentType html5 = new DocumentType("html", "", "", "");
        try{ assertEquals("<!DOCTYPE html>", html5.outerHtml());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", "");
        try{ assertEquals("<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//\">", publicDocType.outerHtml());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType systemDocType = new DocumentType("html", "", "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", "");
        assertEquals("<!DOCTYPE html \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\">", systemDocType.outerHtml());         /***** ORIGINAL ASSERTION IS HERE *****/

        DocumentType combo = new DocumentType("notHtml", "--public", "--system", "");
        try{ assertEquals("<!DOCTYPE notHtml PUBLIC \"--public\" \"--system\">", combo.outerHtml());                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void outerHtmlGeneration$catena_3() {
        DocumentType html5 = new DocumentType("html", "", "", "");
        try{ assertEquals("<!DOCTYPE html>", html5.outerHtml());                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", "");
        try{ assertEquals("<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//\">", publicDocType.outerHtml());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType systemDocType = new DocumentType("html", "", "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", "");
        try{ assertEquals("<!DOCTYPE html \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\">", systemDocType.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){}

        DocumentType combo = new DocumentType("notHtml", "--public", "--system", "");
        assertEquals("<!DOCTYPE notHtml PUBLIC \"--public\" \"--system\">", combo.outerHtml());                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName
file: /tmp/Jsoup_16/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Begin: Pos(13, 5)
End: Pos(16, 5)
Source: /tmp/Jsoup_16/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Name: constructorValidationThrowsExceptionOnBlankName
Childs: []
--------------------
Run: Jsoup_91
@@@
Split test: org.jsoup.integration.ConnectTest::testBinaryThrowsExceptionWhenTypeIgnored
file: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ConnectTest.java
Begin: Pos(491, 5)
End: Pos(507, 5)
Source: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ConnectTest.java
Name: testBinaryThrowsExceptionWhenTypeIgnored
Childs: [StatementAssertion<Begin: Pos(504, 13), End: Pos(504, 76)>,
StatementAssertion<Begin: Pos(506, 9), End: Pos(506, 26)>,
]
---
    @Test
    public void testBinaryThrowsExceptionWhenTypeIgnored$catena_0() {
        Connection con = Jsoup.connect(FileServlet.Url);
        con.data(FileServlet.LocationParam, "/htmltests/thumb.jpg");
        con.data(FileServlet.ContentTypeParam, "image/jpeg");
        con.ignoreContentType(true);

        boolean threw = false;
        try {
            con.execute();
            Document doc = con.response().parse();
        } catch (IOException e) {
            threw = true;
            assertEquals("Input is binary and unsupported", e.getMessage());                                /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try{ assertTrue(threw);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testBinaryThrowsExceptionWhenTypeIgnored$catena_1() {
        Connection con = Jsoup.connect(FileServlet.Url);
        con.data(FileServlet.LocationParam, "/htmltests/thumb.jpg");
        con.data(FileServlet.ContentTypeParam, "image/jpeg");
        con.ignoreContentType(true);

        boolean threw = false;
        try {
            con.execute();
            Document doc = con.response().parse();
        } catch (IOException e) {
            threw = true;
            try{ assertEquals("Input is binary and unsupported", e.getMessage());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        assertTrue(threw);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.integration.ConnectTest::testBinaryResultThrows
file: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ConnectTest.java
Begin: Pos(509, 5)
End: Pos(524, 5)
Source: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ConnectTest.java
Name: testBinaryResultThrows
Childs: [StatementAssertion<Begin: Pos(521, 13), End: Pos(521, 76)>,
StatementAssertion<Begin: Pos(523, 9), End: Pos(523, 26)>,
]
---
    @Test
    public void testBinaryResultThrows$catena_0() {
        Connection con = Jsoup.connect(FileServlet.Url);
        con.data(FileServlet.LocationParam, "/htmltests/thumb.jpg");
        con.data(FileServlet.ContentTypeParam, "text/html");

        boolean threw = false;
        try {
            con.execute();
            Document doc = con.response().parse();
        } catch (IOException e) {
            threw = true;
            assertEquals("Input is binary and unsupported", e.getMessage());                                /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try{ assertTrue(threw);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testBinaryResultThrows$catena_1() {
        Connection con = Jsoup.connect(FileServlet.Url);
        con.data(FileServlet.LocationParam, "/htmltests/thumb.jpg");
        con.data(FileServlet.ContentTypeParam, "text/html");

        boolean threw = false;
        try {
            con.execute();
            Document doc = con.response().parse();
        } catch (IOException e) {
            threw = true;
            try{ assertEquals("Input is binary and unsupported", e.getMessage());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        assertTrue(threw);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.integration.ParseTest::testBinaryThrowsException
file: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ParseTest.java
Begin: Pos(68, 5)
End: Pos(80, 5)
Source: /tmp/Jsoup_91/src/test/java//org/jsoup/integration/ParseTest.java
Name: testBinaryThrowsException
Childs: [StatementAssertion<Begin: Pos(77, 13), End: Pos(77, 76)>,
StatementAssertion<Begin: Pos(79, 9), End: Pos(79, 26)>,
]
---
    @Test
    public void testBinaryThrowsException$catena_0() throws IOException {
        File in = getFile("/htmltests/thumb.jpg");

        boolean threw = false;
        try {
            Document doc = Jsoup.parse(in, "UTF-8");
        } catch (IOException e) {
            threw = true;
            assertEquals("Input is binary and unsupported", e.getMessage());                                /***** ORIGINAL ASSERTION IS HERE *****/
        }
        try{ assertTrue(threw);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testBinaryThrowsException$catena_1() throws IOException {
        File in = getFile("/htmltests/thumb.jpg");

        boolean threw = false;
        try {
            Document doc = Jsoup.parse(in, "UTF-8");
        } catch (IOException e) {
            threw = true;
            try{ assertEquals("Input is binary and unsupported", e.getMessage());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        assertTrue(threw);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_83
@@@
Split test: org.jsoup.parser.HtmlParserTest::parsesQuiteRoughAttributes
file: /tmp/Jsoup_83/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(58, 5)
End: Pos(70, 5)
Source: /tmp/Jsoup_83/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: parsesQuiteRoughAttributes
Childs: [StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 122)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 57)>,
]
---
    @Test public void parsesQuiteRoughAttributes$catena_0() {
        String html = "<p =a>One<a <p>Something</p>Else";
        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated
        Document doc = Jsoup.parse(html);

        // NOTE: per spec this should be the test case. but impacts too many ppl
        // assertEquals("<p =a>One<a <p>Something</a></p>\n<a <p>Else</a>", doc.body().html());

        assertEquals("<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>", TextUtil.stripNewlines(doc.body().html()));         /***** ORIGINAL ASSERTION IS HERE *****/

        doc = Jsoup.parse("<p .....>");
        try{ assertEquals("<p .....></p>", doc.body().html());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void parsesQuiteRoughAttributes$catena_1() {
        String html = "<p =a>One<a <p>Something</p>Else";
        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated
        Document doc = Jsoup.parse(html);

        // NOTE: per spec this should be the test case. but impacts too many ppl
        // assertEquals("<p =a>One<a <p>Something</a></p>\n<a <p>Else</a>", doc.body().html());

        try{ assertEquals("<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>", TextUtil.stripNewlines(doc.body().html()));    }catch(Throwable __SHOULD_BE_IGNORED){}

        doc = Jsoup.parse("<p .....>");
        assertEquals("<p .....></p>", doc.body().html());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.TokeniserStateTest::handlesLessInTagThanAsNewTag
file: /tmp/Jsoup_83/src/test/java//org/jsoup/parser/TokeniserStateTest.java
Begin: Pos(203, 5)
End: Pos(208, 5)
Source: /tmp/Jsoup_83/src/test/java//org/jsoup/parser/TokeniserStateTest.java
Name: handlesLessInTagThanAsNewTag
Childs: [StatementAssertion<Begin: Pos(207, 9), End: Pos(207, 120)>,
]
--------------------
Run: Jsoup_74
@@@
Split test: org.jsoup.nodes.ElementTest::testNormalizesInvisiblesInText
file: /tmp/Jsoup_74/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(1204, 5)
End: Pos(1220, 5)
Source: /tmp/Jsoup_74/src/test/java//org/jsoup/nodes/ElementTest.java
Name: testNormalizesInvisiblesInText
Childs: [StatementAssertion<Begin: Pos(1212, 9), End: Pos(1212, 52)>,
StatementAssertion<Begin: Pos(1213, 9), End: Pos(1213, 62)>,
StatementAssertion<Begin: Pos(1214, 9), End: Pos(1214, 67)>,
StatementAssertion<Begin: Pos(1217, 9), End: Pos(1217, 46)>,
StatementAssertion<Begin: Pos(1218, 9), End: Pos(1218, 66)>,
]
---
    @Test public void testNormalizesInvisiblesInText$catena_0() {
        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse("<p>" + escaped);
        Element p = doc.select("p").first();
        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
        assertEquals("Thisisonelongword", p.text());                                  /***** ORIGINAL ASSERTION IS HERE *****/ // text is normalized
        try{ assertEquals("<p>" + escaped + "</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // html / whole text keeps &shy etc;
        try{ assertEquals(decoded, p.textNodes().get(0).getWholeText());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
        try{ assertEquals("p", matched.nodeName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(matched.is(":containsOwn(Thisisonelongword)"));                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test public void testNormalizesInvisiblesInText$catena_1() {
        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse("<p>" + escaped);
        Element p = doc.select("p").first();
        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
        try{ assertEquals("Thisisonelongword", p.text());                             }catch(Throwable __SHOULD_BE_IGNORED){} // text is normalized
        assertEquals("<p>" + escaped + "</p>", p.outerHtml());         /***** ORIGINAL ASSERTION IS HERE *****/ // html / whole text keeps &shy etc;
        try{ assertEquals(decoded, p.textNodes().get(0).getWholeText());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
        try{ assertEquals("p", matched.nodeName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(matched.is(":containsOwn(Thisisonelongword)"));                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test public void testNormalizesInvisiblesInText$catena_2() {
        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse("<p>" + escaped);
        Element p = doc.select("p").first();
        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
        try{ assertEquals("Thisisonelongword", p.text());                             }catch(Throwable __SHOULD_BE_IGNORED){} // text is normalized
        try{ assertEquals("<p>" + escaped + "</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // html / whole text keeps &shy etc;
        assertEquals(decoded, p.textNodes().get(0).getWholeText());                                         /***** ORIGINAL ASSERTION IS HERE *****/

        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
        try{ assertEquals("p", matched.nodeName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(matched.is(":containsOwn(Thisisonelongword)"));                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test public void testNormalizesInvisiblesInText$catena_3() {
        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse("<p>" + escaped);
        Element p = doc.select("p").first();
        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
        try{ assertEquals("Thisisonelongword", p.text());                             }catch(Throwable __SHOULD_BE_IGNORED){} // text is normalized
        try{ assertEquals("<p>" + escaped + "</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // html / whole text keeps &shy etc;
        try{ assertEquals(decoded, p.textNodes().get(0).getWholeText());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
        assertEquals("p", matched.nodeName());                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(matched.is(":containsOwn(Thisisonelongword)"));                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test public void testNormalizesInvisiblesInText$catena_4() {
        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse("<p>" + escaped);
        Element p = doc.select("p").first();
        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
        try{ assertEquals("Thisisonelongword", p.text());                             }catch(Throwable __SHOULD_BE_IGNORED){} // text is normalized
        try{ assertEquals("<p>" + escaped + "</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // html / whole text keeps &shy etc;
        try{ assertEquals(decoded, p.textNodes().get(0).getWholeText());                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
        try{ assertEquals("p", matched.nodeName());                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(matched.is(":containsOwn(Thisisonelongword)"));                                          /***** ORIGINAL ASSERTION IS HERE *****/

    }
---
--------------------
Run: Jsoup_63
@@@
Split test: org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError
file: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(978, 5)
End: Pos(988, 5)
Source: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: selfClosingOnNonvoidIsError
Childs: [StatementAssertion<Begin: Pos(982, 9), End: Pos(982, 51)>,
StatementAssertion<Begin: Pos(983, 9), End: Pos(983, 109)>,
StatementAssertion<Begin: Pos(985, 9), End: Pos(985, 62)>,
StatementAssertion<Begin: Pos(987, 9), End: Pos(987, 104)>,
]
---
    @Test public void selfClosingOnNonvoidIsError$catena_0() {
        String html = "<p>test</p><div /><div>Two</div>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        assertEquals(1, parser.getErrors().size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("18: Tag cannot be self closing; not a void tag", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        String clean = Jsoup.clean(html, Whitelist.relaxed());
        try{ assertEquals("<p>test</p> <div></div> <div> Two </div>", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void selfClosingOnNonvoidIsError$catena_1() {
        String html = "<p>test</p><div /><div>Two</div>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("18: Tag cannot be self closing; not a void tag", parser.getErrors().get(0).toString());         /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        String clean = Jsoup.clean(html, Whitelist.relaxed());
        try{ assertEquals("<p>test</p> <div></div> <div> Two </div>", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void selfClosingOnNonvoidIsError$catena_2() {
        String html = "<p>test</p><div /><div>Two</div>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("18: Tag cannot be self closing; not a void tag", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}

        assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        String clean = Jsoup.clean(html, Whitelist.relaxed());
        try{ assertEquals("<p>test</p> <div></div> <div> Two </div>", StringUtil.normaliseWhitespace(clean));         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void selfClosingOnNonvoidIsError$catena_3() {
        String html = "<p>test</p><div /><div>Two</div>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        try{ assertEquals(1, parser.getErrors().size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("18: Tag cannot be self closing; not a void tag", parser.getErrors().get(0).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        String clean = Jsoup.clean(html, Whitelist.relaxed());
        assertEquals("<p>test</p> <div></div> <div> Two </div>", StringUtil.normaliseWhitespace(clean));              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.HtmlParserTest::selfClosingVoidIsNotAnError
file: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(967, 5)
End: Pos(976, 5)
Source: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: selfClosingVoidIsNotAnError
Childs: [StatementAssertion<Begin: Pos(971, 9), End: Pos(971, 51)>,
StatementAssertion<Begin: Pos(973, 9), End: Pos(973, 59)>,
StatementAssertion<Begin: Pos(975, 9), End: Pos(975, 55)>,
]
---
    @Test public void selfClosingVoidIsNotAnError$catena_0() {
        String html = "<p>test<br/>test<br/></p>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        assertEquals(0, parser.getErrors().size());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        String clean = Jsoup.clean(html, Whitelist.basic());
        try{ assertEquals("<p>test<br>test<br></p>", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void selfClosingVoidIsNotAnError$catena_1() {
        String html = "<p>test<br/>test<br/></p>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        String clean = Jsoup.clean(html, Whitelist.basic());
        try{ assertEquals("<p>test<br>test<br></p>", clean);                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void selfClosingVoidIsNotAnError$catena_2() {
        String html = "<p>test<br/>test<br/></p>";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, "");
        try{ assertEquals(0, parser.getErrors().size());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertTrue(Jsoup.isValid(html, Whitelist.basic()));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        String clean = Jsoup.clean(html, Whitelist.basic());
        assertEquals("<p>test<br>test<br></p>", clean);                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.HtmlParserTest::tracksErrorsWhenRequested
file: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(689, 5)
End: Pos(701, 5)
Source: /tmp/Jsoup_63/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: tracksErrorsWhenRequested
Childs: [StatementAssertion<Begin: Pos(695, 9), End: Pos(695, 39)>,
StatementAssertion<Begin: Pos(696, 9), End: Pos(696, 96)>,
StatementAssertion<Begin: Pos(697, 9), End: Pos(697, 104)>,
StatementAssertion<Begin: Pos(698, 9), End: Pos(698, 116)>,
StatementAssertion<Begin: Pos(699, 9), End: Pos(699, 97)>,
StatementAssertion<Begin: Pos(700, 9), End: Pos(700, 118)>,
]
---
    @Test public void tracksErrorsWhenRequested$catena_0() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        assertEquals(5, errors.size());                                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void tracksErrorsWhenRequested$catena_1() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void tracksErrorsWhenRequested$catena_2() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void tracksErrorsWhenRequested$catena_3() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void tracksErrorsWhenRequested$catena_4() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void tracksErrorsWhenRequested$catena_5() {
        String html = "<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, "http://example.com", parser);
        
        List<ParseError> errors = parser.getErrors();
        try{ assertEquals(5, errors.size());                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("20: Attributes incorrectly present on end tag", errors.get(0).toString());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("35: Unexpected token [Doctype] when in state [InBody]", errors.get(1).toString());                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("36: Invalid character reference: invalid named referenece 'arrgh'", errors.get(2).toString());      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("50: Tag cannot be self closing; not a void tag", errors.get(3).toString());                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("61: Unexpectedly reached end of file (EOF) in input state [TagName]", errors.get(4).toString());         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_79
@@@
Split test: org.jsoup.nodes.TextNodeTest::testLeadNodesHaveNoChildren
file: /tmp/Jsoup_79/src/test/java//org/jsoup/nodes/TextNodeTest.java
Begin: Pos(78, 5)
End: Pos(84, 5)
Source: /tmp/Jsoup_79/src/test/java//org/jsoup/nodes/TextNodeTest.java
Name: testLeadNodesHaveNoChildren
Childs: [StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 38)>,
]
--------------------
Run: Jsoup_67
@@@
Split test: org.jsoup.parser.HtmlParserTest::handlesDeepStack
file: /tmp/Jsoup_67/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(904, 5)
End: Pos(925, 5)
Source: /tmp/Jsoup_67/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: handlesDeepStack
Childs: [StatementAssertion<Begin: Pos(922, 9), End: Pos(922, 52)>,
StatementAssertion<Begin: Pos(923, 9), End: Pos(923, 53)>,
StatementAssertion<Begin: Pos(924, 9), End: Pos(924, 62)>,
]
---
    @Test public void handlesDeepStack$catena_0() {
        // inspired by http://sv.stargate.wikia.com/wiki/M2J and https://github.com/jhy/jsoup/issues/955
        // I didn't put it in the integration tests, because explorer and intellij kept dieing trying to preview/index it

        // Arrange
        StringBuilder longBody = new StringBuilder(500000);
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("<dl><dd>");
        }
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("</dd></dl>");
        }

        // Act
        long start = System.currentTimeMillis();
        Document doc = Parser.parseBodyFragment(longBody.toString(), "");

        // Assert
        assertEquals(2, doc.body().childNodeSize());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(25000, doc.select("dd").size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(System.currentTimeMillis() - start < 1000);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesDeepStack$catena_1() {
        // inspired by http://sv.stargate.wikia.com/wiki/M2J and https://github.com/jhy/jsoup/issues/955
        // I didn't put it in the integration tests, because explorer and intellij kept dieing trying to preview/index it

        // Arrange
        StringBuilder longBody = new StringBuilder(500000);
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("<dl><dd>");
        }
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("</dd></dl>");
        }

        // Act
        long start = System.currentTimeMillis();
        Document doc = Parser.parseBodyFragment(longBody.toString(), "");

        // Assert
        try{ assertEquals(2, doc.body().childNodeSize());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(25000, doc.select("dd").size());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(System.currentTimeMillis() - start < 1000);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesDeepStack$catena_2() {
        // inspired by http://sv.stargate.wikia.com/wiki/M2J and https://github.com/jhy/jsoup/issues/955
        // I didn't put it in the integration tests, because explorer and intellij kept dieing trying to preview/index it

        // Arrange
        StringBuilder longBody = new StringBuilder(500000);
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("<dl><dd>");
        }
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append("</dd></dl>");
        }

        // Act
        long start = System.currentTimeMillis();
        Document doc = Parser.parseBodyFragment(longBody.toString(), "");

        // Assert
        try{ assertEquals(2, doc.body().childNodeSize());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(25000, doc.select("dd").size());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(System.currentTimeMillis() - start < 1000);                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_28
@@@
Split test: org.jsoup.nodes.EntitiesTest::unescape
file: /tmp/Jsoup_28/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(25, 5)
End: Pos(30, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: unescape
Childs: [StatementAssertion<Begin: Pos(27, 9), End: Pos(27, 91)>,
StatementAssertion<Begin: Pos(29, 9), End: Pos(29, 90)>,
]
---
    @Test public void unescape$catena_0() {
        String text = "Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;";
        assertEquals("Hello &<>   &angst    there &!   ", Entities.unescape(text));                 /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("&0987654321; &unknown", Entities.unescape("&0987654321; &unknown"));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void unescape$catena_1() {
        String text = "Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;";
        try{ assertEquals("Hello &<>   &angst    there &!   ", Entities.unescape(text));            }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("&0987654321; &unknown", Entities.unescape("&0987654321; &unknown"));                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.EntitiesTest::noSpuriousDecodes
file: /tmp/Jsoup_28/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(63, 5)
End: Pos(66, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: noSpuriousDecodes
Childs: [StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 56)>,
]
@@@
Split test: org.jsoup.parser.AttributeParseTest::moreAttributeUnescapes
file: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/AttributeParseTest.java
Begin: Pos(64, 5)
End: Pos(68, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/AttributeParseTest.java
Name: moreAttributeUnescapes
Childs: [StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 82)>,
]
@@@
Split test: org.jsoup.parser.AttributeParseTest::strictAttributeUnescapes
file: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/AttributeParseTest.java
Begin: Pos(57, 5)
End: Pos(62, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/AttributeParseTest.java
Name: strictAttributeUnescapes
Childs: [StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 71)>,
StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 67)>,
]
---
    @Test public void strictAttributeUnescapes$catena_0() {
        String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>";
        Elements els = Jsoup.parse(html).select("a");
        assertEquals("?foo=bar&mid&lt=true", els.first().attr("href"));                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("?foo=bar<qux&lg=1", els.last().attr("href"));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void strictAttributeUnescapes$catena_1() {
        String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>";
        Elements els = Jsoup.parse(html).select("a");
        try{ assertEquals("?foo=bar&mid&lt=true", els.first().attr("href"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("?foo=bar<qux&lg=1", els.last().attr("href"));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.HtmlParserTest::doesNotFindShortestMatchingEntity
file: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(724, 5)
End: Pos(730, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: doesNotFindShortestMatchingEntity
Childs: [StatementAssertion<Begin: Pos(729, 9), End: Pos(729, 97)>,
]
@@@
Split test: org.jsoup.parser.HtmlParserTest::relaxedBaseEntityMatchAndStrictExtendedMatch
file: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(732, 5)
End: Pos(738, 5)
Source: /tmp/Jsoup_28/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: relaxedBaseEntityMatchAndStrictExtendedMatch
Childs: [StatementAssertion<Begin: Pos(737, 9), End: Pos(737, 126)>,
]
--------------------
Run: Jsoup_23
@@@
Split test: org.jsoup.nodes.EntitiesTest::letterDigitEntities
file: /tmp/Jsoup_23/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(56, 5)
End: Pos(62, 5)
Source: /tmp/Jsoup_23/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: letterDigitEntities
Childs: [StatementAssertion<Begin: Pos(60, 9), End: Pos(60, 77)>,
StatementAssertion<Begin: Pos(61, 9), End: Pos(61, 41)>,
]
---
    @Test public void letterDigitEntities$catena_0() {
        String html = "<p>&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;</p>";
        Document doc = Jsoup.parse(html);
        Element p = doc.select("p").first();
        assertEquals("&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;", p.html());                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("", p.text());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void letterDigitEntities$catena_1() {
        String html = "<p>&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;</p>";
        Document doc = Jsoup.parse(html);
        Element p = doc.select("p").first();
        try{ assertEquals("&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;", p.html());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("", p.text());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_80
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::handlesDodgyXmlDecl
file: /tmp/Jsoup_80/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(224, 5)
End: Pos(229, 5)
Source: /tmp/Jsoup_80/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: handlesDodgyXmlDecl
Childs: [StatementAssertion<Begin: Pos(228, 9), End: Pos(228, 54)>,
]
--------------------
Run: Jsoup_7
@@@
Split test: org.jsoup.nodes.DocumentTest::testNormalisesStructure
file: /tmp/Jsoup_7/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(57, 5)
End: Pos(60, 5)
Source: /tmp/Jsoup_7/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testNormalisesStructure
Childs: [StatementAssertion<Begin: Pos(59, 9), End: Pos(59, 163)>,
]
--------------------
Run: Jsoup_3
@@@
Split test: org.jsoup.nodes.ElementTest::testAppendRowToTable
file: /tmp/Jsoup_3/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(214, 5)
End: Pos(220, 5)
Source: /tmp/Jsoup_3/src/test/java//org/jsoup/nodes/ElementTest.java
Name: testAppendRowToTable
Childs: [StatementAssertion<Begin: Pos(219, 9), End: Pos(219, 121)>,
]
@@@
Split test: org.jsoup.nodes.ElementTest::testPrependRowToTable
file: /tmp/Jsoup_3/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(222, 9)
End: Pos(228, 5)
Source: /tmp/Jsoup_3/src/test/java//org/jsoup/nodes/ElementTest.java
Name: testPrependRowToTable
Childs: [StatementAssertion<Begin: Pos(227, 9), End: Pos(227, 121)>,
]
@@@
Split test: org.jsoup.parser.ParserTest::handlesNestedImplicitTable
file: /tmp/Jsoup_3/src/test/java//org/jsoup/parser/ParserTest.java
Begin: Pos(172, 5)
End: Pos(175, 5)
Source: /tmp/Jsoup_3/src/test/java//org/jsoup/parser/ParserTest.java
Name: handlesNestedImplicitTable
Childs: [StatementAssertion<Begin: Pos(174, 9), End: Pos(174, 207)>,
]
--------------------
Run: Jsoup_4
@@@
Split test: org.jsoup.nodes.EntitiesTest::escape
file: /tmp/Jsoup_4/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(11, 5)
End: Pos(21, 5)
Source: /tmp/Jsoup_4/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: escape
Childs: [StatementAssertion<Begin: Pos(17, 9), End: Pos(17, 96)>,
StatementAssertion<Begin: Pos(18, 9), End: Pos(18, 98)>,
StatementAssertion<Begin: Pos(19, 9), End: Pos(19, 82)>,
]
---
    @Test public void escape$catena_0() {
        String text = "Hello &<>     there";
        String escapedAscii = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.base);
        String escapedAsciiFull = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.extended);
        String escapedUtf = Entities.escape(text, Charset.forName("UTF-8").newEncoder(), Entities.EscapeMode.base);

        assertEquals("Hello &amp;&lt;&gt; &Aring; &aring; &#960; &#26032; there", escapedAscii);            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Hello &amp;&lt;&gt; &angst; &aring; &pi; &#26032; there", escapedAsciiFull);     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello &amp;&lt;&gt; &Aring; &aring;   there", escapedUtf);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        // odd that it's defined as aring in base but angst in full
    }
---
---
    @Test public void escape$catena_1() {
        String text = "Hello &<>     there";
        String escapedAscii = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.base);
        String escapedAsciiFull = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.extended);
        String escapedUtf = Entities.escape(text, Charset.forName("UTF-8").newEncoder(), Entities.EscapeMode.base);

        try{ assertEquals("Hello &amp;&lt;&gt; &Aring; &aring; &#960; &#26032; there", escapedAscii);       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Hello &amp;&lt;&gt; &angst; &aring; &pi; &#26032; there", escapedAsciiFull);          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Hello &amp;&lt;&gt; &Aring; &aring;   there", escapedUtf);                     }catch(Throwable __SHOULD_BE_IGNORED){}
        // odd that it's defined as aring in base but angst in full
    }
---
---
    @Test public void escape$catena_2() {
        String text = "Hello &<>     there";
        String escapedAscii = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.base);
        String escapedAsciiFull = Entities.escape(text, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.extended);
        String escapedUtf = Entities.escape(text, Charset.forName("UTF-8").newEncoder(), Entities.EscapeMode.base);

        try{ assertEquals("Hello &amp;&lt;&gt; &Aring; &aring; &#960; &#26032; there", escapedAscii);       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Hello &amp;&lt;&gt; &angst; &aring; &pi; &#26032; there", escapedAsciiFull);     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Hello &amp;&lt;&gt; &Aring; &aring;   there", escapedUtf);                          /***** ORIGINAL ASSERTION IS HERE *****/
        // odd that it's defined as aring in base but angst in full
    }
---
@@@
Split test: org.jsoup.nodes.EntitiesTest::caseSensitive
file: /tmp/Jsoup_4/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(30, 5)
End: Pos(36, 5)
Source: /tmp/Jsoup_4/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: caseSensitive
Childs: [StatementAssertion<Begin: Pos(32, 9), End: Pos(32, 147)>,
StatementAssertion<Begin: Pos(35, 9), End: Pos(35, 60)>,
]
---
    @Test public void caseSensitive$catena_0() {
        String unescaped = "  & &";
        assertEquals("&Uuml; &uuml; &amp; &amp;", Entities.escape(unescaped, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.extended));         /***** ORIGINAL ASSERTION IS HERE *****/
        
        String escaped = "&Uuml; &uuml; &amp; &AMP";
        try{ assertEquals("  & &", Entities.unescape(escaped));                                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void caseSensitive$catena_1() {
        String unescaped = "  & &";
        try{ assertEquals("&Uuml; &uuml; &amp; &amp;", Entities.escape(unescaped, Charset.forName("ascii").newEncoder(), Entities.EscapeMode.extended));    }catch(Throwable __SHOULD_BE_IGNORED){}
        
        String escaped = "&Uuml; &uuml; &amp; &AMP";
        assertEquals("  & &", Entities.unescape(escaped));                                                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_81
@@@
Split test: org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration
file: /tmp/Jsoup_81/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(168, 5)
End: Pos(179, 5)
Source: /tmp/Jsoup_81/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: supportsXmlCharsetDeclaration
Childs: [StatementAssertion<Begin: Pos(178, 9), End: Pos(178, 56)>,
]
--------------------
Run: Jsoup_36
@@@
Split test: org.jsoup.helper.DataUtilTest::shouldCorrectCharsetForDuplicateCharsetString
file: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(49, 5)
End: Pos(52, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: shouldCorrectCharsetForDuplicateCharsetString
Childs: [StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 112)>,
]
@@@
Split test: org.jsoup.helper.DataUtilTest::shouldNotThrowExceptionOnEmptyCharset
file: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(38, 5)
End: Pos(42, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: shouldNotThrowExceptionOnEmptyCharset
Childs: [StatementAssertion<Begin: Pos(40, 9), End: Pos(40, 86)>,
StatementAssertion<Begin: Pos(41, 9), End: Pos(41, 87)>,
]
---
    @Test
    public void shouldNotThrowExceptionOnEmptyCharset$catena_0() {
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset="));                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=;"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void shouldNotThrowExceptionOnEmptyCharset$catena_1() {
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset="));                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=;"));                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.helper.DataUtilTest::testQuotedCharset
file: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(23, 5)
End: Pos(29, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: testQuotedCharset
Childs: [StatementAssertion<Begin: Pos(24, 9), End: Pos(24, 98)>,
StatementAssertion<Begin: Pos(25, 9), End: Pos(25, 97)>,
StatementAssertion<Begin: Pos(26, 9), End: Pos(26, 108)>,
StatementAssertion<Begin: Pos(27, 9), End: Pos(27, 101)>,
StatementAssertion<Begin: Pos(28, 9), End: Pos(28, 96)>,
]
---
    @Test public void testQuotedCharset$catena_0() {
        assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset='UTF-8'"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_1() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset='UTF-8'"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_2() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset='UTF-8'"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_3() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset='UTF-8'"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_4() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset='UTF-8'"));                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.helper.DataUtilTest::shouldSelectFirstCharsetOnWeirdMultileCharsetsInMetaTags
file: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(44, 5)
End: Pos(47, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: shouldSelectFirstCharsetOnWeirdMultileCharsetsInMetaTags
Childs: [StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 118)>,
]
@@@
Split test: org.jsoup.helper.DataUtilTest::shouldReturnNullForIllegalCharsetNames
file: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(54, 5)
End: Pos(57, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: shouldReturnNullForIllegalCharsetNames
Childs: [StatementAssertion<Begin: Pos(56, 9), End: Pos(56, 96)>,
]
@@@
Split test: org.jsoup.integration.ParseTest::testBrokenHtml5CharsetWithASingleDoubleQuote
file: /tmp/Jsoup_36/src/test/java//org/jsoup/integration/ParseTest.java
Begin: Pos(143, 5)
End: Pos(151, 5)
Source: /tmp/Jsoup_36/src/test/java//org/jsoup/integration/ParseTest.java
Name: testBrokenHtml5CharsetWithASingleDoubleQuote
Childs: [StatementAssertion<Begin: Pos(150, 9), End: Pos(150, 76)>,
]
--------------------
Run: Jsoup_44
@@@
Split test: org.jsoup.parser.HtmlParserTest::testInvalidTableContents
file: /tmp/Jsoup_44/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(854, 5)
End: Pos(865, 5)
Source: /tmp/Jsoup_44/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: testInvalidTableContents
Childs: [StatementAssertion<Begin: Pos(862, 9), End: Pos(862, 57)>,
StatementAssertion<Begin: Pos(863, 9), End: Pos(863, 60)>,
StatementAssertion<Begin: Pos(864, 9), End: Pos(864, 85)>,
]
---
    @Test
    public void testInvalidTableContents$catena_0() throws IOException {
        File in = ParseTest.getFile("/htmltests/table-invalid-elements.html");
        Document doc = Jsoup.parse(in, "UTF-8");
        doc.outputSettings().prettyPrint(true);
        String rendered = doc.toString();
        int endOfEmail = rendered.indexOf("Comment");
        int guarantee = rendered.indexOf("Why am I here?");
        assertTrue("Comment not found", endOfEmail > -1);                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Search text not found", guarantee > -1);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Search text did not come after comment", guarantee > endOfEmail);                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testInvalidTableContents$catena_1() throws IOException {
        File in = ParseTest.getFile("/htmltests/table-invalid-elements.html");
        Document doc = Jsoup.parse(in, "UTF-8");
        doc.outputSettings().prettyPrint(true);
        String rendered = doc.toString();
        int endOfEmail = rendered.indexOf("Comment");
        int guarantee = rendered.indexOf("Why am I here?");
        try{ assertTrue("Comment not found", endOfEmail > -1);                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Search text not found", guarantee > -1);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue("Search text did not come after comment", guarantee > endOfEmail);                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testInvalidTableContents$catena_2() throws IOException {
        File in = ParseTest.getFile("/htmltests/table-invalid-elements.html");
        Document doc = Jsoup.parse(in, "UTF-8");
        doc.outputSettings().prettyPrint(true);
        String rendered = doc.toString();
        int endOfEmail = rendered.indexOf("Comment");
        int guarantee = rendered.indexOf("Why am I here?");
        try{ assertTrue("Comment not found", endOfEmail > -1);                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue("Search text not found", guarantee > -1);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue("Search text did not come after comment", guarantee > endOfEmail);                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_31
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::handlesXmlDeclarationAsDeclaration
file: /tmp/Jsoup_31/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(97, 5)
End: Pos(104, 5)
Source: /tmp/Jsoup_31/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: handlesXmlDeclarationAsDeclaration
Childs: [StatementAssertion<Begin: Pos(100, 9), End: Pos(101, 65)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 66)>,
StatementAssertion<Begin: Pos(103, 9), End: Pos(103, 62)>,
]
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_0() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        assertEquals("<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("#declaration", doc.childNode(0).nodeName());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("#comment", doc.childNode(2).nodeName());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_1() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        try{ assertEquals("<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("#declaration", doc.childNode(0).nodeName());                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("#comment", doc.childNode(2).nodeName());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_2() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        try{ assertEquals("<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("#declaration", doc.childNode(0).nodeName());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("#comment", doc.childNode(2).nodeName());                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_66
@@@
Split test: org.jsoup.nodes.ElementTest::testNextElementSiblingAfterClone
file: /tmp/Jsoup_66/src/test/java//org/jsoup/nodes/ElementTest.java
# check: Use list matching: originalElement.after
Use list matching: cloneElement.after
Begin: Pos(1214, 2)
End: Pos(1237, 5)
Source: /tmp/Jsoup_66/src/test/java//org/jsoup/nodes/ElementTest.java
Name: testNextElementSiblingAfterClone
Childs: [StatementAssertion<Begin: Pos(1225, 9), End: Pos(1225, 65)>,
StatementAssertion<Begin: Pos(1228, 9), End: Pos(1228, 70)>,
StatementAssertion<Begin: Pos(1229, 9), End: Pos(1229, 63)>,
StatementAssertion<Begin: Pos(1232, 9), End: Pos(1232, 61)>,
StatementAssertion<Begin: Pos(1235, 9), End: Pos(1235, 66)>,
StatementAssertion<Begin: Pos(1236, 9), End: Pos(1236, 59)>,
]
---
	@Test
    public void testNextElementSiblingAfterClone$catena_0() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        originalElement.after("<div>" + expectedText + "</div>");                                           /***** ORIGINAL ASSERTION IS HERE *****/
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        try{ assertEquals(expectedText, originalNextElementSibling.text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(expectedText, originalNextSibling.text());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Element cloneElement = clone.body().child(0);
        try{ cloneElement.after("<div>" + cloneExpect + "</div>");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        try{ assertEquals(cloneExpect, cloneNextElementSibling.text());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(cloneExpect, cloneNextSibling.text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
	@Test
    public void testNextElementSiblingAfterClone$catena_1() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        try{ originalElement.after("<div>" + expectedText + "</div>");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        assertEquals(expectedText, originalNextElementSibling.text());                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(expectedText, originalNextSibling.text());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Element cloneElement = clone.body().child(0);
        try{ cloneElement.after("<div>" + cloneExpect + "</div>");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        try{ assertEquals(cloneExpect, cloneNextElementSibling.text());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(cloneExpect, cloneNextSibling.text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
	@Test
    public void testNextElementSiblingAfterClone$catena_2() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        try{ originalElement.after("<div>" + expectedText + "</div>");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        try{ assertEquals(expectedText, originalNextElementSibling.text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(expectedText, originalNextSibling.text());                                             /***** ORIGINAL ASSERTION IS HERE *****/

        Element cloneElement = clone.body().child(0);
        try{ cloneElement.after("<div>" + cloneExpect + "</div>");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        try{ assertEquals(cloneExpect, cloneNextElementSibling.text());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(cloneExpect, cloneNextSibling.text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
	@Test
    public void testNextElementSiblingAfterClone$catena_3() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        try{ originalElement.after("<div>" + expectedText + "</div>");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        try{ assertEquals(expectedText, originalNextElementSibling.text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(expectedText, originalNextSibling.text());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Element cloneElement = clone.body().child(0);
        cloneElement.after("<div>" + cloneExpect + "</div>");                                               /***** ORIGINAL ASSERTION IS HERE *****/
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        try{ assertEquals(cloneExpect, cloneNextElementSibling.text());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(cloneExpect, cloneNextSibling.text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
	@Test
    public void testNextElementSiblingAfterClone$catena_4() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        try{ originalElement.after("<div>" + expectedText + "</div>");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        try{ assertEquals(expectedText, originalNextElementSibling.text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(expectedText, originalNextSibling.text());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Element cloneElement = clone.body().child(0);
        try{ cloneElement.after("<div>" + cloneExpect + "</div>");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        assertEquals(cloneExpect, cloneNextElementSibling.text());                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(cloneExpect, cloneNextSibling.text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
	@Test
    public void testNextElementSiblingAfterClone$catena_5() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = "<!DOCTYPE html><html lang=\"en\"><head></head><body><div>Initial element</div></body></html>";
        String expectedText = "New element";
        String cloneExpect = "New element in clone";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        try{ originalElement.after("<div>" + expectedText + "</div>");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        try{ assertEquals(expectedText, originalNextElementSibling.text());                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(expectedText, originalNextSibling.text());                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Element cloneElement = clone.body().child(0);
        try{ cloneElement.after("<div>" + cloneExpect + "</div>");                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        try{ assertEquals(cloneExpect, cloneNextElementSibling.text());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(cloneExpect, cloneNextSibling.text());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_85
@@@
Split test: org.jsoup.nodes.AttributeTest::validatesKeysNotEmpty
file: /tmp/Jsoup_85/src/test/java//org/jsoup/nodes/AttributeTest.java
Begin: Pos(21, 5)
End: Pos(23, 5)
Source: /tmp/Jsoup_85/src/test/java//org/jsoup/nodes/AttributeTest.java
Name: validatesKeysNotEmpty
Childs: []
--------------------
Run: Jsoup_38
@@@
Split test: org.jsoup.parser.HtmlParserTest::convertsImageToImg
file: /tmp/Jsoup_38/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(803, 5)
End: Pos(808, 5)
Source: /tmp/Jsoup_38/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: convertsImageToImg
Childs: [StatementAssertion<Begin: Pos(807, 9), End: Pos(807, 78)>,
]
--------------------
Run: Jsoup_71
@@@
Split test: org.jsoup.select.SelectorTest::splitOnBr
file: /tmp/Jsoup_71/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(786, 5)
End: Pos(795, 5)
Source: /tmp/Jsoup_71/src/test/java//org/jsoup/select/SelectorTest.java
Name: splitOnBr
Childs: [StatementAssertion<Begin: Pos(791, 9), End: Pos(791, 36)>,
StatementAssertion<Begin: Pos(792, 9), End: Pos(792, 47)>,
StatementAssertion<Begin: Pos(793, 9), End: Pos(793, 47)>,
StatementAssertion<Begin: Pos(794, 9), End: Pos(794, 53)>,
]
---
    @Test public void splitOnBr$catena_0() {
        String html = "<div><p>One<br>Two<br>Three</p></div>";
        Document doc = Jsoup.parse(html);

        Elements els = doc.select("p:matchText");
        assertEquals(3, els.size());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("One", els.get(0).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", els.get(1).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", els.get(2).toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void splitOnBr$catena_1() {
        String html = "<div><p>One<br>Two<br>Three</p></div>";
        Document doc = Jsoup.parse(html);

        Elements els = doc.select("p:matchText");
        try{ assertEquals(3, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("One", els.get(0).text());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Two", els.get(1).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Three", els.get(2).toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void splitOnBr$catena_2() {
        String html = "<div><p>One<br>Two<br>Three</p></div>";
        Document doc = Jsoup.parse(html);

        Elements els = doc.select("p:matchText");
        try{ assertEquals(3, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", els.get(0).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Two", els.get(1).text());                                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Three", els.get(2).toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void splitOnBr$catena_3() {
        String html = "<div><p>One<br>Two<br>Three</p></div>";
        Document doc = Jsoup.parse(html);

        Elements els = doc.select("p:matchText");
        try{ assertEquals(3, els.size());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", els.get(0).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Two", els.get(1).text());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Three", els.get(2).toString());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.select.SelectorTest::textAsElements
file: /tmp/Jsoup_71/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(770, 5)
End: Pos(784, 5)
Source: /tmp/Jsoup_71/src/test/java//org/jsoup/select/SelectorTest.java
Name: textAsElements
Childs: [StatementAssertion<Begin: Pos(776, 9), End: Pos(776, 48)>,
StatementAssertion<Begin: Pos(779, 9), End: Pos(779, 48)>,
StatementAssertion<Begin: Pos(781, 9), End: Pos(781, 43)>,
StatementAssertion<Begin: Pos(783, 9), End: Pos(783, 71)>,
]
---
    @Test public void textAsElements$catena_0() {
        String html = "<p>One<br>Two</p>";
        Document doc = Jsoup.parse(html);
        String origHtml = doc.html();

        Elements one = doc.select("p:matchText:first-child");
        assertEquals("One", one.first().text());                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        Elements two = doc.select("p:matchText:last-child");
        try{ assertEquals("Two", two.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(origHtml, doc.html());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("Two", doc.select("p:matchText + br + *").text());                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void textAsElements$catena_1() {
        String html = "<p>One<br>Two</p>";
        Document doc = Jsoup.parse(html);
        String origHtml = doc.html();

        Elements one = doc.select("p:matchText:first-child");
        try{ assertEquals("One", one.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements two = doc.select("p:matchText:last-child");
        assertEquals("Two", two.first().text());                                                            /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals(origHtml, doc.html());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals("Two", doc.select("p:matchText + br + *").text());                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void textAsElements$catena_2() {
        String html = "<p>One<br>Two</p>";
        Document doc = Jsoup.parse(html);
        String origHtml = doc.html();

        Elements one = doc.select("p:matchText:first-child");
        try{ assertEquals("One", one.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements two = doc.select("p:matchText:last-child");
        try{ assertEquals("Two", two.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals(origHtml, doc.html());                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertEquals("Two", doc.select("p:matchText + br + *").text());                                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void textAsElements$catena_3() {
        String html = "<p>One<br>Two</p>";
        Document doc = Jsoup.parse(html);
        String origHtml = doc.html();

        Elements one = doc.select("p:matchText:first-child");
        try{ assertEquals("One", one.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        Elements two = doc.select("p:matchText:last-child");
        try{ assertEquals("Two", two.first().text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertEquals(origHtml, doc.html());                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

        assertEquals("Two", doc.select("p:matchText + br + *").text());                                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_92
@@@
Split test: org.jsoup.parser.HtmlParserTest::retainsAttributesOfDifferentCaseIfSensitive
file: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(70, 5)
End: Pos(75, 5)
Source: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: retainsAttributesOfDifferentCaseIfSensitive
Childs: [StatementAssertion<Begin: Pos(74, 9), End: Pos(74, 121)>,
]
@@@
Split test: org.jsoup.parser.HtmlParserTest::dropsDuplicateAttributes
file: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(58, 5)
End: Pos(68, 5)
Source: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: dropsDuplicateAttributes
Childs: [StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 75)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 51)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 89)>,
]
---
    @Test public void dropsDuplicateAttributes$catena_0() {
        String html = "<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>";
        Parser parser = Parser.htmlParser().setTrackErrors(10);
        Document doc = parser.parseInput(html, "");

        Element p = doc.selectFirst("p");
        assertEquals("<p one=\"One\" two=\"two\">Text</p>", p.outerHtml());         /***** ORIGINAL ASSERTION IS HERE *****/ // normalized names due to lower casing

        try{ assertEquals(1, parser.getErrors().size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Duplicate attribute", parser.getErrors().get(0).getErrorMessage());                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void dropsDuplicateAttributes$catena_1() {
        String html = "<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>";
        Parser parser = Parser.htmlParser().setTrackErrors(10);
        Document doc = parser.parseInput(html, "");

        Element p = doc.selectFirst("p");
        try{ assertEquals("<p one=\"One\" two=\"two\">Text</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // normalized names due to lower casing

        assertEquals(1, parser.getErrors().size());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Duplicate attribute", parser.getErrors().get(0).getErrorMessage());                              }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void dropsDuplicateAttributes$catena_2() {
        String html = "<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>";
        Parser parser = Parser.htmlParser().setTrackErrors(10);
        Document doc = parser.parseInput(html, "");

        Element p = doc.selectFirst("p");
        try{ assertEquals("<p one=\"One\" two=\"two\">Text</p>", p.outerHtml());    }catch(Throwable __SHOULD_BE_IGNORED){} // normalized names due to lower casing

        try{ assertEquals(1, parser.getErrors().size());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Duplicate attribute", parser.getErrors().get(0).getErrorMessage());                                   /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::dropsDuplicateAttributes
file: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(249, 5)
End: Pos(256, 5)
Source: /tmp/Jsoup_92/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: dropsDuplicateAttributes
Childs: [StatementAssertion<Begin: Pos(255, 9), End: Pos(255, 134)>,
]
--------------------
Run: Jsoup_50
@@@
Split test: org.jsoup.helper.DataUtilTest::supportsBOMinFiles
file: /tmp/Jsoup_50/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(104, 5)
End: Pos(126, 5)
Source: /tmp/Jsoup_50/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: supportsBOMinFiles
Childs: [StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 53)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 50)>,
StatementAssertion<Begin: Pos(114, 9), End: Pos(114, 53)>,
StatementAssertion<Begin: Pos(115, 9), End: Pos(115, 50)>,
StatementAssertion<Begin: Pos(119, 9), End: Pos(119, 53)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 50)>,
StatementAssertion<Begin: Pos(124, 9), End: Pos(124, 53)>,
StatementAssertion<Begin: Pos(125, 9), End: Pos(125, 50)>,
]
---
    @Test
    public void supportsBOMinFiles$catena_0() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        assertTrue(doc.title().contains("UTF-16BE"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_1() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(doc.text().contains(""));                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_2() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        assertTrue(doc.title().contains("UTF-16LE"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_3() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(doc.text().contains(""));                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_4() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        assertTrue(doc.title().contains("UTF-32BE"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_5() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(doc.text().contains(""));                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_6() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        assertTrue(doc.title().contains("UTF-32LE"));                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void supportsBOMinFiles$catena_7() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile("/bomtests/bom_utf16be.html");
        Document doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf16le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-16LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32be.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32BE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertTrue(doc.text().contains(""));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        in = getFile("/bomtests/bom_utf32le.html");
        doc = Jsoup.parse(in, null, "http://example.com");
        try{ assertTrue(doc.title().contains("UTF-32LE"));                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertTrue(doc.text().contains(""));                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_27
@@@
Split test: org.jsoup.helper.DataUtilTest::testCharset
file: /tmp/Jsoup_27/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(13, 5)
End: Pos(21, 5)
Source: /tmp/Jsoup_27/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: testCharset
Childs: [StatementAssertion<Begin: Pos(15, 9), End: Pos(15, 94)>,
StatementAssertion<Begin: Pos(16, 9), End: Pos(16, 94)>,
StatementAssertion<Begin: Pos(17, 9), End: Pos(17, 104)>,
StatementAssertion<Begin: Pos(18, 9), End: Pos(18, 76)>,
StatementAssertion<Begin: Pos(19, 9), End: Pos(19, 69)>,
StatementAssertion<Begin: Pos(20, 9), End: Pos(20, 92)>,
]
---
    @Test
    public void testCharset$catena_0() {
        assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType(null));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCharset$catena_1() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType(null));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCharset$catena_2() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType(null));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCharset$catena_3() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType(null));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCharset$catena_4() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType(null));                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testCharset$catena_5() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html;charset=utf-8 "));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html; charset=UTF-8"));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=ISO-8859-1"));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html"));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType(null));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html;charset=Unknown"));                     /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.helper.DataUtilTest::testQuotedCharset
file: /tmp/Jsoup_27/src/test/java//org/jsoup/helper/DataUtilTest.java
Begin: Pos(23, 5)
End: Pos(28, 5)
Source: /tmp/Jsoup_27/src/test/java//org/jsoup/helper/DataUtilTest.java
Name: testQuotedCharset
Childs: [StatementAssertion<Begin: Pos(24, 9), End: Pos(24, 98)>,
StatementAssertion<Begin: Pos(25, 9), End: Pos(25, 97)>,
StatementAssertion<Begin: Pos(26, 9), End: Pos(26, 108)>,
StatementAssertion<Begin: Pos(27, 9), End: Pos(27, 101)>,
]
---
    @Test public void testQuotedCharset$catena_0() {
        assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_1() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_2() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testQuotedCharset$catena_3() {
        try{ assertEquals("utf-8", DataUtil.getCharsetFromContentType("text/html; charset=\"utf-8\""));              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", DataUtil.getCharsetFromContentType("text/html;charset=\"UTF-8\""));               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("ISO-8859-1", DataUtil.getCharsetFromContentType("text/html; charset=\"ISO-8859-1\""));    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(null, DataUtil.getCharsetFromContentType("text/html; charset=\"Unsupported\""));                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_65
@@@
Split test: org.jsoup.parser.HtmlParserTest::testTemplateInsideTable
file: /tmp/Jsoup_65/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(1038, 3)
End: Pos(1047, 3)
Source: /tmp/Jsoup_65/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: testTemplateInsideTable
Childs: [StatementAssertion<Begin: Pos(1045, 13), End: Pos(1045, 57)>,
]
--------------------
Run: Jsoup_70
@@@
Split test: org.jsoup.nodes.ElementTest::testKeepsPreTextAtDepth
file: /tmp/Jsoup_70/src/test/java//org/jsoup/nodes/ElementTest.java
Begin: Pos(107, 5)
End: Pos(112, 5)
Source: /tmp/Jsoup_70/src/test/java//org/jsoup/nodes/ElementTest.java
Name: testKeepsPreTextAtDepth
Childs: [StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 49)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 100)>,
]
---
    @Test public void testKeepsPreTextAtDepth$catena_0() {
        String h = "<pre><code><span><b>code\n\ncode</b></span></code></pre>";
        Document doc = Jsoup.parse(h);
        assertEquals("code\n\ncode", doc.text());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<pre><code><span><b>code\n\ncode</b></span></code></pre>", doc.body().html());    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testKeepsPreTextAtDepth$catena_1() {
        String h = "<pre><code><span><b>code\n\ncode</b></span></code></pre>";
        Document doc = Jsoup.parse(h);
        try{ assertEquals("code\n\ncode", doc.text());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<pre><code><span><b>code\n\ncode</b></span></code></pre>", doc.body().html());         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_59
@@@
Split test: org.jsoup.parser.HtmlParserTest::handlesControlCodeInAttributeName
file: /tmp/Jsoup_59/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(945, 5)
End: Pos(948, 5)
Source: /tmp/Jsoup_59/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: handlesControlCodeInAttributeName
Childs: [StatementAssertion<Begin: Pos(947, 9), End: Pos(947, 90)>,
]
@@@
Split test: org.jsoup.safety.CleanerTest::handlesControlCharactersAfterTagName
file: /tmp/Jsoup_59/src/test/java//org/jsoup/safety/CleanerTest.java
Begin: Pos(281, 5)
End: Pos(285, 5)
Source: /tmp/Jsoup_59/src/test/java//org/jsoup/safety/CleanerTest.java
Name: handlesControlCharactersAfterTagName
Childs: [StatementAssertion<Begin: Pos(284, 9), End: Pos(284, 56)>,
]
--------------------
Run: Jsoup_82
@@@
Split test: org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode
file: /tmp/Jsoup_82/src/test/java//org/jsoup/parser/HtmlParserTest.java
Begin: Pos(1201, 5)
End: Pos(1212, 5)
Source: /tmp/Jsoup_82/src/test/java//org/jsoup/parser/HtmlParserTest.java
Name: fallbackToUtfIfCantEncode
Childs: [StatementAssertion<Begin: Pos(1207, 9), End: Pos(1207, 52)>,
StatementAssertion<Begin: Pos(1208, 9), End: Pos(1208, 40)>,
StatementAssertion<Begin: Pos(1211, 9), End: Pos(1211, 121)>,
]
---
    @Test public void fallbackToUtfIfCantEncode$catena_0() throws IOException {
        // that charset can't be encoded, so make sure we flip to utf

        String in = "<html><meta charset=\"ISO-2022-CN\"/>One</html>";
        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, "");

        assertEquals("UTF-8", doc.charset().name());                                                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("One", doc.text());                                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        String html = doc.outerHtml();
        try{ assertEquals("<html><head><meta charset=\"UTF-8\"></head><body>One</body></html>", TextUtil.stripNewlines(html));    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void fallbackToUtfIfCantEncode$catena_1() throws IOException {
        // that charset can't be encoded, so make sure we flip to utf

        String in = "<html><meta charset=\"ISO-2022-CN\"/>One</html>";
        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, "");

        try{ assertEquals("UTF-8", doc.charset().name());                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("One", doc.text());                                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

        String html = doc.outerHtml();
        try{ assertEquals("<html><head><meta charset=\"UTF-8\"></head><body>One</body></html>", TextUtil.stripNewlines(html));    }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void fallbackToUtfIfCantEncode$catena_2() throws IOException {
        // that charset can't be encoded, so make sure we flip to utf

        String in = "<html><meta charset=\"ISO-2022-CN\"/>One</html>";
        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, "");

        try{ assertEquals("UTF-8", doc.charset().name());                                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("One", doc.text());                                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

        String html = doc.outerHtml();
        assertEquals("<html><head><meta charset=\"UTF-8\"></head><body>One</body></html>", TextUtil.stripNewlines(html));         /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_56
@@@
Split test: org.jsoup.nodes.DocumentTypeTest::testRoundTrip
file: /tmp/Jsoup_56/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Begin: Pos(44, 5)
End: Pos(60, 5)
Source: /tmp/Jsoup_56/src/test/java//org/jsoup/nodes/DocumentTypeTest.java
Name: testRoundTrip
Childs: [StatementAssertion<Begin: Pos(46, 9), End: Pos(46, 58)>,
StatementAssertion<Begin: Pos(47, 9), End: Pos(47, 44)>,
StatementAssertion<Begin: Pos(50, 9), End: Pos(50, 55)>,
StatementAssertion<Begin: Pos(51, 9), End: Pos(51, 54)>,
StatementAssertion<Begin: Pos(54, 9), End: Pos(54, 55)>,
StatementAssertion<Begin: Pos(55, 9), End: Pos(55, 54)>,
StatementAssertion<Begin: Pos(58, 9), End: Pos(58, 55)>,
StatementAssertion<Begin: Pos(59, 9), End: Pos(59, 54)>,
]
---
    @Test public void testRoundTrip$catena_0() {
        String base = "<!DOCTYPE html>";
        assertEquals("<!doctype html>", htmlOutput(base));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_1() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(base, xmlOutput(base));                                                                /***** ORIGINAL ASSERTION IS HERE *****/

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_2() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        assertEquals(publicDoc, htmlOutput(publicDoc));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_3() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(publicDoc, xmlOutput(publicDoc));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_4() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        assertEquals(systemDoc, htmlOutput(systemDoc));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_5() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(systemDoc, xmlOutput(systemDoc));                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_6() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void testRoundTrip$catena_7() {
        String base = "<!DOCTYPE html>";
        try{ assertEquals("<!doctype html>", htmlOutput(base));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(base, xmlOutput(base));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        String publicDoc = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        try{ assertEquals(publicDoc, htmlOutput(publicDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(publicDoc, xmlOutput(publicDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String systemDoc = "<!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">";
        try{ assertEquals(systemDoc, htmlOutput(systemDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(systemDoc, xmlOutput(systemDoc));                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

        String legacyDoc = "<!DOCTYPE html SYSTEM \"about:legacy-compat\">";
        try{ assertEquals(legacyDoc, htmlOutput(legacyDoc));                                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(legacyDoc, xmlOutput(legacyDoc));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_52
@@@
Split test: org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlNoCharset
file: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(345, 5)
End: Pos(359, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testMetaCharsetUpdateXmlNoCharset
Childs: [StatementAssertion<Begin: Pos(355, 9), End: Pos(355, 53)>,
StatementAssertion<Begin: Pos(358, 9), End: Pos(358, 65)>,
]
---
    @Test
    public void testMetaCharsetUpdateXmlNoCharset$catena_0() {
        final Document doc = createXmlDocument("1.0", "none", false);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        assertEquals(xmlCharsetUTF8, doc.toString());                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlNoCharset$catena_1() {
        final Document doc = createXmlDocument("1.0", "none", false);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetUTF8, doc.toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlIso8859
file: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(327, 5)
End: Pos(343, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testMetaCharsetUpdateXmlIso8859
Childs: [StatementAssertion<Begin: Pos(337, 9), End: Pos(337, 52)>,
StatementAssertion<Begin: Pos(340, 9), End: Pos(340, 59)>,
StatementAssertion<Begin: Pos(341, 9), End: Pos(341, 68)>,
StatementAssertion<Begin: Pos(342, 9), End: Pos(342, 68)>,
]
---
    @Test
    public void testMetaCharsetUpdateXmlIso8859$catena_0() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));
        
        final String xmlCharsetISO = "<?xml version=\"1.0\" encoding=\"" + charsetIso8859 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        assertEquals(xmlCharsetISO, doc.toString());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetIso8859, doc.charset().name());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(charsetIso8859, selectedNode.attr("encoding"));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlIso8859$catena_1() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));
        
        final String xmlCharsetISO = "<?xml version=\"1.0\" encoding=\"" + charsetIso8859 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetISO, doc.toString());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetIso8859, doc.charset().name());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(charsetIso8859, selectedNode.attr("encoding"));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlIso8859$catena_2() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));
        
        final String xmlCharsetISO = "<?xml version=\"1.0\" encoding=\"" + charsetIso8859 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetISO, doc.toString());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetIso8859, doc.charset().name());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(charsetIso8859, selectedNode.attr("encoding"));                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlIso8859$catena_3() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));
        
        final String xmlCharsetISO = "<?xml version=\"1.0\" encoding=\"" + charsetIso8859 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetISO, doc.toString());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetIso8859, doc.charset().name());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(charsetIso8859, selectedNode.attr("encoding"));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(doc.charset(), doc.outputSettings().charset());                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlUtf8
file: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(309, 5)
End: Pos(325, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testMetaCharsetUpdateXmlUtf8
Childs: [StatementAssertion<Begin: Pos(319, 9), End: Pos(319, 53)>,
StatementAssertion<Begin: Pos(322, 9), End: Pos(322, 56)>,
StatementAssertion<Begin: Pos(323, 9), End: Pos(323, 65)>,
StatementAssertion<Begin: Pos(324, 9), End: Pos(324, 68)>,
]
---
    @Test
    public void testMetaCharsetUpdateXmlUtf8$catena_0() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        assertEquals(xmlCharsetUTF8, doc.toString());                                                       /***** ORIGINAL ASSERTION IS HERE *****/

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetUtf8, doc.charset().name());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlUtf8$catena_1() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetUTF8, doc.toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetUtf8, doc.charset().name());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlUtf8$catena_2() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetUTF8, doc.toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetUtf8, doc.charset().name());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals(doc.charset(), doc.outputSettings().charset());                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlUtf8$catena_3() {
        final Document doc = createXmlDocument("1.0", "changeThis", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));
        
        final String xmlCharsetUTF8 = "<?xml version=\"1.0\" encoding=\"" + charsetUtf8 + "\"?>\n" +
                                        "<root>\n" +
                                        " node\n" +
                                        "</root>";
        try{ assertEquals(xmlCharsetUTF8, doc.toString());                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals(charsetUtf8, doc.charset().name());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals(charsetUtf8, selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals(doc.charset(), doc.outputSettings().charset());                                        /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlDisabledNoChanges
file: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Begin: Pos(371, 5)
End: Pos(384, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/nodes/DocumentTest.java
Name: testMetaCharsetUpdateXmlDisabledNoChanges
Childs: [StatementAssertion<Begin: Pos(379, 9), End: Pos(379, 49)>,
StatementAssertion<Begin: Pos(382, 9), End: Pos(382, 65)>,
StatementAssertion<Begin: Pos(383, 9), End: Pos(383, 64)>,
]
---
    @Test
    public void testMetaCharsetUpdateXmlDisabledNoChanges$catena_0() {
        final Document doc = createXmlDocument("dontTouch", "dontTouch", true);
        
        final String xmlCharset = "<?xml version=\"dontTouch\" encoding=\"dontTouch\"?>\n" +
                                    "<root>\n" +
                                    " node\n" +
                                    "</root>";
        assertEquals(xmlCharset, doc.toString());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("dontTouch", selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("dontTouch", selectedNode.attr("version"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlDisabledNoChanges$catena_1() {
        final Document doc = createXmlDocument("dontTouch", "dontTouch", true);
        
        final String xmlCharset = "<?xml version=\"dontTouch\" encoding=\"dontTouch\"?>\n" +
                                    "<root>\n" +
                                    " node\n" +
                                    "</root>";
        try{ assertEquals(xmlCharset, doc.toString());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals("dontTouch", selectedNode.attr("encoding"));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("dontTouch", selectedNode.attr("version"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testMetaCharsetUpdateXmlDisabledNoChanges$catena_2() {
        final Document doc = createXmlDocument("dontTouch", "dontTouch", true);
        
        final String xmlCharset = "<?xml version=\"dontTouch\" encoding=\"dontTouch\"?>\n" +
                                    "<root>\n" +
                                    " node\n" +
                                    "</root>";
        try{ assertEquals(xmlCharset, doc.toString());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        
        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("dontTouch", selectedNode.attr("encoding"));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("dontTouch", selectedNode.attr("version"));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::handlesXmlDeclarationAsDeclaration
file: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(105, 5)
End: Pos(112, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: handlesXmlDeclarationAsDeclaration
Childs: [StatementAssertion<Begin: Pos(108, 9), End: Pos(109, 65)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 66)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 62)>,
]
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_0() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        assertEquals("<?xml encoding=\"UTF-8\"?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("#declaration", doc.childNode(0).nodeName());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("#comment", doc.childNode(2).nodeName());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_1() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        try{ assertEquals("<?xml encoding=\"UTF-8\"?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("#declaration", doc.childNode(0).nodeName());                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("#comment", doc.childNode(2).nodeName());                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesXmlDeclarationAsDeclaration$catena_2() {
        String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->";
        Document doc = Jsoup.parse(html, "", Parser.xmlParser());
        try{ assertEquals("<?xml encoding=\"UTF-8\"?> <body> One </body> <!-- comment -->",
                StringUtil.normaliseWhitespace(doc.outerHtml()));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("#declaration", doc.childNode(0).nodeName());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("#comment", doc.childNode(2).nodeName());                                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::testDetectCharsetEncodingDeclaration
file: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(136, 5)
End: Pos(144, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: testDetectCharsetEncodingDeclaration
Childs: [StatementAssertion<Begin: Pos(141, 9), End: Pos(141, 57)>,
StatementAssertion<Begin: Pos(142, 9), End: Pos(143, 48)>,
]
---
    @Test
    public void testDetectCharsetEncodingDeclaration$catena_0() throws IOException, URISyntaxException {
        File xmlFile = new File(XmlTreeBuilder.class.getResource("/htmltests/xml-charset.xml").toURI());
        InputStream inStream = new FileInputStream(xmlFile);
        Document doc = Jsoup.parse(inStream, null, "http://example.com/", Parser.xmlParser());
        assertEquals("ISO-8859-1", doc.charset().name());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <data></data>",
            TextUtil.stripNewlines(doc.html()));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testDetectCharsetEncodingDeclaration$catena_1() throws IOException, URISyntaxException {
        File xmlFile = new File(XmlTreeBuilder.class.getResource("/htmltests/xml-charset.xml").toURI());
        InputStream inStream = new FileInputStream(xmlFile);
        Document doc = Jsoup.parse(inStream, null, "http://example.com/", Parser.xmlParser());
        try{ assertEquals("ISO-8859-1", doc.charset().name());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <data></data>",
            TextUtil.stripNewlines(doc.html()));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.XmlTreeBuilderTest::testParseDeclarationAttributes
file: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Begin: Pos(146, 5)
End: Pos(156, 5)
Source: /tmp/Jsoup_52/src/test/java//org/jsoup/parser/XmlTreeBuilderTest.java
Name: testParseDeclarationAttributes
Childs: [StatementAssertion<Begin: Pos(151, 9), End: Pos(151, 48)>,
StatementAssertion<Begin: Pos(152, 9), End: Pos(152, 53)>,
StatementAssertion<Begin: Pos(153, 9), End: Pos(153, 53)>,
StatementAssertion<Begin: Pos(154, 9), End: Pos(154, 104)>,
StatementAssertion<Begin: Pos(155, 9), End: Pos(155, 102)>,
]
---
    @Test
    public void testParseDeclarationAttributes$catena_0() {
        String xml = "<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>";
        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        assertEquals("1", decl.attr("version"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("UTF-8", decl.attr("encoding"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("else", decl.attr("something"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("version=\"1\" encoding=\"UTF-8\" something=\"else\"", decl.getWholeDeclaration());    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<?xml version=\"1\" encoding=\"UTF-8\" something=\"else\"?>", decl.outerHtml());      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseDeclarationAttributes$catena_1() {
        String xml = "<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>";
        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("1", decl.attr("version"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("UTF-8", decl.attr("encoding"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("else", decl.attr("something"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("version=\"1\" encoding=\"UTF-8\" something=\"else\"", decl.getWholeDeclaration());    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<?xml version=\"1\" encoding=\"UTF-8\" something=\"else\"?>", decl.outerHtml());      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseDeclarationAttributes$catena_2() {
        String xml = "<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>";
        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("1", decl.attr("version"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", decl.attr("encoding"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("else", decl.attr("something"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("version=\"1\" encoding=\"UTF-8\" something=\"else\"", decl.getWholeDeclaration());    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<?xml version=\"1\" encoding=\"UTF-8\" something=\"else\"?>", decl.outerHtml());      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseDeclarationAttributes$catena_3() {
        String xml = "<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>";
        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("1", decl.attr("version"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", decl.attr("encoding"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("else", decl.attr("something"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("version=\"1\" encoding=\"UTF-8\" something=\"else\"", decl.getWholeDeclaration());         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<?xml version=\"1\" encoding=\"UTF-8\" something=\"else\"?>", decl.outerHtml());      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test
    public void testParseDeclarationAttributes$catena_4() {
        String xml = "<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>";
        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        try{ assertEquals("1", decl.attr("version"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("UTF-8", decl.attr("encoding"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("else", decl.attr("something"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("version=\"1\" encoding=\"UTF-8\" something=\"else\"", decl.getWholeDeclaration());    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<?xml version=\"1\" encoding=\"UTF-8\" something=\"else\"?>", decl.outerHtml());           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_73
@@@
Split test: org.jsoup.helper.W3CDomTest::namespacePreservation
file: /tmp/Jsoup_73/src/test/java//org/jsoup/helper/W3CDomTest.java
Begin: Pos(65, 5)
End: Pos(125, 5)
Source: /tmp/Jsoup_73/src/test/java//org/jsoup/helper/W3CDomTest.java
Name: namespacePreservation
Childs: [StatementAssertion<Begin: Pos(76, 9), End: Pos(76, 79)>,
StatementAssertion<Begin: Pos(77, 9), End: Pos(77, 52)>,
StatementAssertion<Begin: Pos(78, 9), End: Pos(78, 51)>,
StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 77)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 50)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 49)>,
StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 58)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 82)>,
StatementAssertion<Begin: Pos(89, 9), End: Pos(89, 56)>,
StatementAssertion<Begin: Pos(90, 9), End: Pos(90, 60)>,
StatementAssertion<Begin: Pos(93, 9), End: Pos(93, 61)>,
StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 57)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 58)>,
StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 74)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 48)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 47)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 75)>,
StatementAssertion<Begin: Pos(106, 9), End: Pos(106, 50)>,
StatementAssertion<Begin: Pos(107, 9), End: Pos(107, 49)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 72)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 50)>,
StatementAssertion<Begin: Pos(112, 9), End: Pos(112, 49)>,
StatementAssertion<Begin: Pos(113, 9), End: Pos(113, 51)>,
StatementAssertion<Begin: Pos(116, 9), End: Pos(116, 80)>,
StatementAssertion<Begin: Pos(117, 9), End: Pos(117, 56)>,
StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 55)>,
StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 76)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 48)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 47)>,
]
---
    @Test
    public void namespacePreservation$catena_0() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_1() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("html", htmlEl.getLocalName());                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_2() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("html", htmlEl.getNodeName());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_3() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_4() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("head", head.getLocalName());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_5() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("head", head.getNodeName());                                                           /***** ORIGINAL ASSERTION IS HERE *****/

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_6() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        assertEquals("Check", epubTitle.getTextContent());                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_7() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_8() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("title", epubTitle.getLocalName());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_9() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("epub:title", epubTitle.getNodeName());                                                /***** ORIGINAL ASSERTION IS HERE *****/

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_10() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        assertEquals("urn:test", xSection.getNamespaceURI());                                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_11() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("section", xSection.getLocalName());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_12() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("x:section", xSection.getNodeName());                                                  /***** ORIGINAL ASSERTION IS HERE *****/

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_13() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_14() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("svg", svg.getLocalName());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_15() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("svg", svg.getNodeName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_16() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_17() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("path", path.getLocalName());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_18() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("path", path.getNodeName());                                                           /***** ORIGINAL ASSERTION IS HERE *****/

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_19() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        assertEquals("http://example.com/clip", clip.getNamespaceURI());                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_20() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("clip", clip.getLocalName());                                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_21() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("clip", clip.getNodeName());                                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_22() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("456", clip.getTextContent());                                                         /***** ORIGINAL ASSERTION IS HERE *****/

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_23() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_24() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("picture", picture.getLocalName());                                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_25() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("picture", picture.getNodeName());                                                     /***** ORIGINAL ASSERTION IS HERE *****/

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_26() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_27() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("img", img.getLocalName());                                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("img", img.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    }
---
---
    @Test
    public void namespacePreservation$catena_28() throws IOException {
        File in = ParseTest.getFile("/htmltests/namespaces.xhtml");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, "UTF-8");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        try{ assertEquals("http://www.w3.org/1999/xhtml", htmlEl.getNamespaceURI());                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getLocalName());                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("html", htmlEl.getNodeName());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        // inherits default namespace
        Node head = htmlEl.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", head.getNamespaceURI());                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("head", head.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);
        try{ assertEquals("Check", epubTitle.getTextContent());                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("http://www.idpf.org/2007/ops", epubTitle.getNamespaceURI());                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("title", epubTitle.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("epub:title", epubTitle.getNodeName());                                           }catch(Throwable __SHOULD_BE_IGNORED){}

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        try{ assertEquals("urn:test", xSection.getNamespaceURI());                                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("section", xSection.getLocalName());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("x:section", xSection.getNodeName());                                             }catch(Throwable __SHOULD_BE_IGNORED){}

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/2000/svg", svg.getNamespaceURI());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("svg", svg.getNodeName());                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

        Node path = svg.getChildNodes().item(1);
        try{ assertEquals("http://www.w3.org/2000/svg", path.getNamespaceURI());                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("path", path.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        Node clip = path.getChildNodes().item(1);
        try{ assertEquals("http://example.com/clip", clip.getNamespaceURI());                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getLocalName());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("clip", clip.getNodeName());                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("456", clip.getTextContent());                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

        Node picture = svg.getNextSibling().getNextSibling();
        try{ assertEquals("http://www.w3.org/1999/xhtml", picture.getNamespaceURI());                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getLocalName());                                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("picture", picture.getNodeName());                                                }catch(Throwable __SHOULD_BE_IGNORED){}

        Node img = picture.getFirstChild();
        try{ assertEquals("http://www.w3.org/1999/xhtml", img.getNamespaceURI());                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("img", img.getLocalName());                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("img", img.getNodeName());                                                             /***** ORIGINAL ASSERTION IS HERE *****/

    }
---
--------------------
Run: Jsoup_14
@@@
Split test: org.jsoup.parser.ParserTest::parsesUnterminatedTextarea
file: /tmp/Jsoup_14/src/test/java//org/jsoup/parser/ParserTest.java
Begin: Pos(97, 5)
End: Pos(103, 5)
Source: /tmp/Jsoup_14/src/test/java//org/jsoup/parser/ParserTest.java
Name: parsesUnterminatedTextarea
Childs: [StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 38)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 59)>,
]
---
    @Test public void parsesUnterminatedTextarea$catena_0() {
        // don't parse right to end, but break on <p>
        Document doc = Jsoup.parse("<body><p><textarea>one<p>two");
        Element t = doc.select("textarea").first();
        assertEquals("one", t.text());                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("two", doc.select("p").get(1).text());                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void parsesUnterminatedTextarea$catena_1() {
        // don't parse right to end, but break on <p>
        Document doc = Jsoup.parse("<body><p><textarea>one<p>two");
        Element t = doc.select("textarea").first();
        try{ assertEquals("one", t.text());                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("two", doc.select("p").get(1).text());                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.jsoup.parser.ParserTest::handlesUnclosedTitle
file: /tmp/Jsoup_14/src/test/java//org/jsoup/parser/ParserTest.java
Begin: Pos(554, 5)
End: Pos(562, 5)
Source: /tmp/Jsoup_14/src/test/java//org/jsoup/parser/ParserTest.java
Name: handlesUnclosedTitle
Childs: [StatementAssertion<Begin: Pos(556, 9), End: Pos(556, 57)>,
StatementAssertion<Begin: Pos(557, 9), End: Pos(557, 61)>,
StatementAssertion<Begin: Pos(560, 9), End: Pos(560, 41)>,
StatementAssertion<Begin: Pos(561, 9), End: Pos(561, 66)>,
]
---
    @Test public void handlesUnclosedTitle$catena_0() {
        Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); // has title, so <b> is plain text
        assertEquals("One <b>Two <b>Three", one.title());                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Test", one.select("p").first().text());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); // no title, so <b> causes </title> breakout
        try{ assertEquals("One", two.title());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<b>Two <p>Test</p></b>", two.body().html());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesUnclosedTitle$catena_1() {
        Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); // has title, so <b> is plain text
        try{ assertEquals("One <b>Two <b>Three", one.title());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Test", one.select("p").first().text());                                               /***** ORIGINAL ASSERTION IS HERE *****/

        Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); // no title, so <b> causes </title> breakout
        try{ assertEquals("One", two.title());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("<b>Two <p>Test</p></b>", two.body().html());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesUnclosedTitle$catena_2() {
        Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); // has title, so <b> is plain text
        try{ assertEquals("One <b>Two <b>Three", one.title());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Test", one.select("p").first().text());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); // no title, so <b> causes </title> breakout
        assertEquals("One", two.title());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("<b>Two <p>Test</p></b>", two.body().html());                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void handlesUnclosedTitle$catena_3() {
        Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); // has title, so <b> is plain text
        try{ assertEquals("One <b>Two <b>Three", one.title());                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertEquals("Test", one.select("p").first().text());                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); // no title, so <b> causes </title> breakout
        try{ assertEquals("One", two.title());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("<b>Two <p>Test</p></b>", two.body().html());                                          /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_53
@@@
Split test: org.jsoup.select.SelectorTest::attributeWithBrackets
file: /tmp/Jsoup_53/src/test/java//org/jsoup/select/SelectorTest.java
Begin: Pos(665, 5)
End: Pos(670, 5)
Source: /tmp/Jsoup_53/src/test/java//org/jsoup/select/SelectorTest.java
Name: attributeWithBrackets
Childs: [StatementAssertion<Begin: Pos(668, 9), End: Pos(668, 74)>,
StatementAssertion<Begin: Pos(669, 9), End: Pos(669, 81)>,
]
---
    @Test public void attributeWithBrackets$catena_0() {
        String html = "<div data='End]'>One</div> <div data='[Another)]]'>Two</div>";
        Document doc = Jsoup.parse(html);
        assertEquals("One", doc.select("div[data='End]'").first().text());                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertEquals("Two", doc.select("div[data='[Another)]]'").first().text());                      }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    @Test public void attributeWithBrackets$catena_1() {
        String html = "<div data='End]'>One</div> <div data='[Another)]]'>Two</div>";
        Document doc = Jsoup.parse(html);
        try{ assertEquals("One", doc.select("div[data='End]'").first().text());                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertEquals("Two", doc.select("div[data='[Another)]]'").first().text());                           /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: Jsoup_6
@@@
Split test: org.jsoup.integration.ParseTest::testYahooArticle
file: /tmp/Jsoup_6/src/test/java//org/jsoup/integration/ParseTest.java
Begin: Pos(142, 5)
End: Pos(148, 5)
Source: /tmp/Jsoup_6/src/test/java//org/jsoup/integration/ParseTest.java
Name: testYahooArticle
Childs: [StatementAssertion<Begin: Pos(147, 9), End: Pos(147, 185)>,
]
@@@
Split test: org.jsoup.nodes.EntitiesTest::quoteReplacements
file: /tmp/Jsoup_6/src/test/java//org/jsoup/nodes/EntitiesTest.java
Begin: Pos(38, 5)
End: Pos(43, 5)
Source: /tmp/Jsoup_6/src/test/java//org/jsoup/nodes/EntitiesTest.java
Name: quoteReplacements
Childs: [StatementAssertion<Begin: Pos(42, 9), End: Pos(42, 60)>,
]
--------------------
Run: JxPath_17
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute
file: /tmp/JxPath_17/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisAttribute> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisAttribute
file: /tmp/JxPath_17/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisAttribute> in AST

---
--------------------
Run: JxPath_11
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testNamespaceMapping
file: /tmp/JxPath_11/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testNamespaceMapping> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testNamespaceMapping
file: /tmp/JxPath_11/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testNamespaceMapping> in AST

---
--------------------
Run: JxPath_8
@@@
Split test: org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNan
file: /tmp/JxPath_8/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Begin: Pos(115, 12)
End: Pos(125, 5)
Source: /tmp/JxPath_8/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Name: testNan
Childs: [StatementAssertion<Begin: Pos(116, 9), End: Pos(116, 79)>,
StatementAssertion<Begin: Pos(117, 9), End: Pos(117, 79)>,
StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 78)>,
StatementAssertion<Begin: Pos(119, 9), End: Pos(119, 76)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 76)>,
StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 76)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 76)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 76)>,
StatementAssertion<Begin: Pos(124, 9), End: Pos(124, 76)>,
]
---
    public void testNan$catena_0() {
        assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_1() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_2() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_3() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_4() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_5() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_6() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_7() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_8() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JxPath_22
@@@
Split test: org.apache.commons.jxpath.ri.model.JXPath154Test::testInnerEmptyNamespaceDOM
file: /tmp/JxPath_22/src/test//org/apache/commons/jxpath/ri/model/JXPath154Test.java
Begin: Pos(20, 12)
End: Pos(22, 5)
Source: /tmp/JxPath_22/src/test//org/apache/commons/jxpath/ri/model/JXPath154Test.java
Name: testInnerEmptyNamespaceDOM
Childs: [StatementAssertion<Begin: Pos(21, 9), End: Pos(21, 79)>,
]
--------------------
Run: JxPath_9
@@@
Split test: org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNan
file: /tmp/JxPath_9/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Begin: Pos(115, 12)
End: Pos(137, 5)
Source: /tmp/JxPath_9/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Name: testNan
Childs: [StatementAssertion<Begin: Pos(116, 9), End: Pos(116, 79)>,
StatementAssertion<Begin: Pos(117, 9), End: Pos(117, 79)>,
StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 80)>,
StatementAssertion<Begin: Pos(119, 9), End: Pos(119, 80)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 97)>,
StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 79)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 80)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 76)>,
StatementAssertion<Begin: Pos(124, 9), End: Pos(124, 76)>,
StatementAssertion<Begin: Pos(125, 9), End: Pos(125, 77)>,
StatementAssertion<Begin: Pos(126, 9), End: Pos(126, 77)>,
StatementAssertion<Begin: Pos(127, 9), End: Pos(127, 91)>,
StatementAssertion<Begin: Pos(128, 9), End: Pos(128, 76)>,
StatementAssertion<Begin: Pos(129, 9), End: Pos(129, 77)>,
StatementAssertion<Begin: Pos(130, 9), End: Pos(130, 76)>,
StatementAssertion<Begin: Pos(131, 9), End: Pos(131, 76)>,
StatementAssertion<Begin: Pos(132, 9), End: Pos(132, 77)>,
StatementAssertion<Begin: Pos(133, 9), End: Pos(133, 77)>,
StatementAssertion<Begin: Pos(134, 9), End: Pos(134, 91)>,
StatementAssertion<Begin: Pos(135, 9), End: Pos(135, 76)>,
StatementAssertion<Begin: Pos(136, 9), End: Pos(136, 77)>,
]
---
    public void testNan$catena_0() {
        assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_1() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_2() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_3() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_4() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_5() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_6() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_7() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_8() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_9() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_10() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_11() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_12() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_13() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_14() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_15() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_16() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_17() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_18() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_19() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNan$catena_20() {
        try{ assertXPathValue(context, "$nan > $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= $nan and $nan <= $nan", Boolean.FALSE, Boolean.class);      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = $nan", Boolean.FALSE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != $nan", Boolean.FALSE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 0 and $nan <= 0", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 0", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan != 0", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan > 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan < 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan <= 1", Boolean.FALSE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan >= 1 and $nan <= 1", Boolean.FALSE, Boolean.class);            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$nan = 1", Boolean.FALSE, Boolean.class);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$nan != 1", Boolean.FALSE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JxPath_19
@@@
Split test: org.apache.commons.jxpath.ri.model.AliasedNamespaceIterationTest::testIterateJDOM
file: /tmp/JxPath_19/src/test//org/apache/commons/jxpath/ri/model/AliasedNamespaceIterationTest.java
Begin: Pos(57, 12)
End: Pos(59, 5)
Source: /tmp/JxPath_19/src/test//org/apache/commons/jxpath/ri/model/AliasedNamespaceIterationTest.java
Name: testIterateJDOM
Childs: [StatementAssertion<Begin: Pos(58, 9), End: Pos(58, 52)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.AliasedNamespaceIterationTest::testIterateDOM
file: /tmp/JxPath_19/src/test//org/apache/commons/jxpath/ri/model/AliasedNamespaceIterationTest.java
Begin: Pos(53, 12)
End: Pos(55, 5)
Source: /tmp/JxPath_19/src/test//org/apache/commons/jxpath/ri/model/AliasedNamespaceIterationTest.java
Name: testIterateDOM
Childs: [StatementAssertion<Begin: Pos(54, 9), End: Pos(54, 51)>,
]
--------------------
Run: JxPath_18
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute
file: /tmp/JxPath_18/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisAttribute> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisAttribute
file: /tmp/JxPath_18/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisAttribute> in AST

---
--------------------
Run: JxPath_15
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testUnion
file: /tmp/JxPath_15/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testUnion> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testUnion
file: /tmp/JxPath_15/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testUnion> in AST

---
--------------------
Run: JxPath_16
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisFollowing
file: /tmp/JxPath_16/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisFollowing> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisPreceding
file: /tmp/JxPath_16/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisPreceding> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisFollowing
file: /tmp/JxPath_16/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisFollowing> in AST

---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisPreceding
file: /tmp/JxPath_16/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
# Exception:
Traceback (most recent call last):
  File "/root/rjy/c4j/scripts/split_tests/run.py", line 46, in run
    fti, check = spliter.process_test_node_v2(path2file, test[1], table)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/spliter.py", line 364, in process_test_node_v2
    node = get_only_node(name, _globals)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/rjy/c4j/scripts/split_tests/util.py", line 44, in get_only_node
    raise ParseError('Cannot find method <{}> in AST'.format(name))
util.ParseError: Cannot find method <testAxisPreceding> in AST

---
--------------------
Run: JxPath_2
@@@
Split test: org.apache.commons.jxpath.ri.compiler.ExtensionFunctionTest::testNodeSetReturn
file: /tmp/JxPath_2/src/test//org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java
Begin: Pos(336, 12)
End: Pos(363, 5)
Source: /tmp/JxPath_2/src/test//org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java
Name: testNodeSetReturn
Childs: [StatementAssertion<Begin: Pos(337, 9), End: Pos(340, 38)>,
StatementAssertion<Begin: Pos(342, 9), End: Pos(345, 66)>,
StatementAssertion<Begin: Pos(347, 9), End: Pos(350, 54)>,
StatementAssertion<Begin: Pos(352, 9), End: Pos(356, 30)>,
StatementAssertion<Begin: Pos(358, 9), End: Pos(362, 31)>,
]
---
    public void testNodeSetReturn$catena_0() {
        assertXPathValueIterator(
            context,
            "test:nodeSet()/name",
            list("Name 1", "Name 2"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()",
            list(testBean.getBeans()[0], testBean.getBeans()[1]));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathPointerIterator(
            context,
            "test:nodeSet()/name",
            list("/beans[1]/name", "/beans[2]/name"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            
        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/name",
            "Name 1",
            "/beans[1]/name");                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}        

        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/@name",
            "Name 1",
            "/beans[1]/@name");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetReturn$catena_1() {
        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()/name",
            list("Name 1", "Name 2"));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        assertXPathValueIterator(
            context,
            "test:nodeSet()",
            list(testBean.getBeans()[0], testBean.getBeans()[1]));                                          /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertXPathPointerIterator(
            context,
            "test:nodeSet()/name",
            list("/beans[1]/name", "/beans[2]/name"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            
        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/name",
            "Name 1",
            "/beans[1]/name");                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}        

        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/@name",
            "Name 1",
            "/beans[1]/@name");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetReturn$catena_2() {
        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()/name",
            list("Name 1", "Name 2"));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()",
            list(testBean.getBeans()[0], testBean.getBeans()[1]));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        assertXPathPointerIterator(
            context,
            "test:nodeSet()/name",
            list("/beans[1]/name", "/beans[2]/name"));                                                      /***** ORIGINAL ASSERTION IS HERE *****/
            
        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/name",
            "Name 1",
            "/beans[1]/name");                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}        

        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/@name",
            "Name 1",
            "/beans[1]/@name");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetReturn$catena_3() {
        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()/name",
            list("Name 1", "Name 2"));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()",
            list(testBean.getBeans()[0], testBean.getBeans()[1]));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathPointerIterator(
            context,
            "test:nodeSet()/name",
            list("/beans[1]/name", "/beans[2]/name"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            
        assertXPathValueAndPointer(
            context,
            "test:nodeSet()/name",
            "Name 1",
            "/beans[1]/name");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/        

        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/@name",
            "Name 1",
            "/beans[1]/@name");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetReturn$catena_4() {
        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()/name",
            list("Name 1", "Name 2"));                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValueIterator(
            context,
            "test:nodeSet()",
            list(testBean.getBeans()[0], testBean.getBeans()[1]));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathPointerIterator(
            context,
            "test:nodeSet()/name",
            list("/beans[1]/name", "/beans[2]/name"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}
            
        try{ assertXPathValueAndPointer(
            context,
            "test:nodeSet()/name",
            "Name 1",
            "/beans[1]/name");                                                                      }catch(Throwable __SHOULD_BE_IGNORED){}        

        assertXPathValueAndPointer(
            context,
            "test:nodeSet()/@name",
            "Name 1",
            "/beans[1]/@name");                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JxPath_20
@@@
Split test: org.apache.commons.jxpath.ri.compiler.JXPath149Test::testComplexOperationWithVariables
file: /tmp/JxPath_20/src/test//org/apache/commons/jxpath/ri/compiler/JXPath149Test.java
Begin: Pos(24, 12)
End: Pos(30, 5)
Source: /tmp/JxPath_20/src/test//org/apache/commons/jxpath/ri/compiler/JXPath149Test.java
Name: testComplexOperationWithVariables
Childs: [StatementAssertion<Begin: Pos(29, 9), End: Pos(29, 65)>,
]
--------------------
Run: JxPath_7
@@@
Split test: org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations
file: /tmp/JxPath_7/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Begin: Pos(99, 12)
End: Pos(112, 5)
Source: /tmp/JxPath_7/src/test//org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java
Name: testNodeSetOperations
Childs: [StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 77)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 78)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 78)>,
StatementAssertion<Begin: Pos(103, 9), End: Pos(103, 80)>,
StatementAssertion<Begin: Pos(104, 9), End: Pos(104, 79)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 83)>,
StatementAssertion<Begin: Pos(106, 9), End: Pos(106, 80)>,
StatementAssertion<Begin: Pos(107, 9), End: Pos(107, 77)>,
StatementAssertion<Begin: Pos(108, 9), End: Pos(108, 78)>,
StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 78)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 78)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 78)>,
]
---
    public void testNodeSetOperations$catena_0() {
        assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_1() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_2() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_3() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_4() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_5() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_6() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_7() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_8() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_9() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_10() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testNodeSetOperations$catena_11() {
        try{ assertXPathValue(context, "$array > 0", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array >= 0", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.25", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.5", Boolean.TRUE, Boolean.class);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.50000", Boolean.TRUE, Boolean.class);                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 0.75", Boolean.TRUE, Boolean.class);                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array < 1", Boolean.TRUE, Boolean.class);                          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array <= 1", Boolean.TRUE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array = 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$array > 1", Boolean.FALSE, Boolean.class);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$array < 0", Boolean.FALSE, Boolean.class);                              /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JxPath_3
@@@
Split test: org.apache.commons.jxpath.ri.model.beans.BadlyImplementedFactoryTest::testBadFactoryImplementation
file: /tmp/JxPath_3/src/test//org/apache/commons/jxpath/ri/model/beans/BadlyImplementedFactoryTest.java
Begin: Pos(59, 12)
End: Pos(66, 5)
Source: /tmp/JxPath_3/src/test//org/apache/commons/jxpath/ri/model/beans/BadlyImplementedFactoryTest.java
Name: testBadFactoryImplementation
Childs: [StatementAssertion<Begin: Pos(62, 13), End: Pos(62, 94)>,
StatementAssertion<Begin: Pos(64, 13), End: Pos(64, 79)>,
]
---
    public void testBadFactoryImplementation$catena_0() {
        try {
            context.createPath("foo/bar");
            fail("should fail with JXPathException caused by JXPathAbstractFactoryException");              /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (JXPathException e) {
            try{ assertTrue(e.getCause() instanceof JXPathAbstractFactoryException);                        }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }
---
---
    public void testBadFactoryImplementation$catena_1() {
        try {
            context.createPath("foo/bar");
            try{ fail("should fail with JXPathException caused by JXPathAbstractFactoryException");         }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (JXPathException e) {
            assertTrue(e.getCause() instanceof JXPathAbstractFactoryException);                             /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
---
--------------------
Run: JxPath_13
@@@
Split test: org.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest::testCreateAndSetAttributeDOM
file: /tmp/JxPath_13/src/test//org/apache/commons/jxpath/ri/model/ExternalXMLNamespaceTest.java
Begin: Pos(82, 12)
End: Pos(84, 5)
Source: /tmp/JxPath_13/src/test//org/apache/commons/jxpath/ri/model/ExternalXMLNamespaceTest.java
Name: testCreateAndSetAttributeDOM
Childs: [StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 65)>,
]
--------------------
Run: JxPath_4
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testPreserveDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(66, 12)
End: Pos(68, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testPreserveDOM
Childs: [StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 65)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testNestedJDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(90, 12)
End: Pos(92, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testNestedJDOM
Childs: [StatementAssertion<Begin: Pos(91, 9), End: Pos(91, 72)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testNestedWithCommentsJDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(94, 12)
End: Pos(96, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testNestedWithCommentsJDOM
Childs: [StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 86)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testPreserveJDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(86, 12)
End: Pos(88, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testPreserveJDOM
Childs: [StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 66)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testNestedDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(70, 12)
End: Pos(72, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testNestedDOM
Childs: [StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 71)>,
]
@@@
Split test: org.apache.commons.jxpath.ri.model.XMLSpaceTest::testNestedWithCommentsDOM
file: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Begin: Pos(74, 12)
End: Pos(76, 5)
Source: /tmp/JxPath_4/src/test//org/apache/commons/jxpath/ri/model/XMLSpaceTest.java
Name: testNestedWithCommentsDOM
Childs: [StatementAssertion<Begin: Pos(75, 9), End: Pos(75, 85)>,
]
--------------------
Run: JxPath_1
@@@
Split test: org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testGetNode
file: /tmp/JxPath_1/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
Begin: Pos(64, 12)
End: Pos(69, 5)
Source: /tmp/JxPath_1/src/test//org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java
Name: testGetNode
Childs: [StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 58)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 72)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 69)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 64)>,
]
---
    public void testGetNode$catena_0() {
        assertXPathNodeType(context, "/", Document.class);                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//location/@name", Attr.class);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//vendor", Element.class);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetNode$catena_1() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "/vendor/location", Element.class);                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "//location/@name", Attr.class);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//vendor", Element.class);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetNode$catena_2() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "//location/@name", Attr.class);                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "//vendor", Element.class);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testGetNode$catena_3() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//location/@name", Attr.class);                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "//vendor", Element.class);                                            /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
@@@
Split test: org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testGetNode
file: /tmp/JxPath_1/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
Begin: Pos(61, 12)
End: Pos(66, 5)
Source: /tmp/JxPath_1/src/test//org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java
Name: testGetNode
Childs: [StatementAssertion<Begin: Pos(62, 9), End: Pos(62, 58)>,
StatementAssertion<Begin: Pos(63, 9), End: Pos(63, 72)>,
StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 74)>,
StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 64)>,
]
---
    public void testGetNode$catena_0() {
        assertXPathNodeType(context, "/", Document.class);                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//location/@name", Attribute.class);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//vendor", Element.class);                     }catch(Throwable __SHOULD_BE_IGNORED){} //bugzilla #38586
    }
---
---
    public void testGetNode$catena_1() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "/vendor/location", Element.class);                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "//location/@name", Attribute.class);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//vendor", Element.class);                     }catch(Throwable __SHOULD_BE_IGNORED){} //bugzilla #38586
    }
---
---
    public void testGetNode$catena_2() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "//location/@name", Attribute.class);                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathNodeType(context, "//vendor", Element.class);                     }catch(Throwable __SHOULD_BE_IGNORED){} //bugzilla #38586
    }
---
---
    public void testGetNode$catena_3() {
        try{ assertXPathNodeType(context, "/", Document.class);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "/vendor/location", Element.class);                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathNodeType(context, "//location/@name", Attribute.class);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathNodeType(context, "//vendor", Element.class);                          /***** ORIGINAL ASSERTION IS HERE *****/ //bugzilla #38586
    }
---
--------------------
Run: JxPath_14
@@@
Split test: org.apache.commons.jxpath.ri.compiler.CoreFunctionTest::testCoreFunctions
file: /tmp/JxPath_14/src/test//org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java
Begin: Pos(63, 12)
End: Pos(129, 5)
Source: /tmp/JxPath_14/src/test//org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java
Name: testCoreFunctions
Childs: [StatementAssertion<Begin: Pos(64, 9), End: Pos(64, 52)>,
StatementAssertion<Begin: Pos(65, 9), End: Pos(65, 57)>,
StatementAssertion<Begin: Pos(66, 9), End: Pos(66, 58)>,
StatementAssertion<Begin: Pos(67, 9), End: Pos(67, 67)>,
StatementAssertion<Begin: Pos(68, 9), End: Pos(68, 65)>,
StatementAssertion<Begin: Pos(69, 9), End: Pos(69, 66)>,
StatementAssertion<Begin: Pos(70, 9), End: Pos(70, 76)>,
StatementAssertion<Begin: Pos(71, 9), End: Pos(71, 78)>,
StatementAssertion<Begin: Pos(72, 9), End: Pos(72, 74)>,
StatementAssertion<Begin: Pos(73, 9), End: Pos(73, 75)>,
StatementAssertion<Begin: Pos(74, 9), End: Pos(77, 20)>,
StatementAssertion<Begin: Pos(78, 9), End: Pos(81, 21)>,
StatementAssertion<Begin: Pos(82, 9), End: Pos(82, 69)>,
StatementAssertion<Begin: Pos(83, 9), End: Pos(83, 67)>,
StatementAssertion<Begin: Pos(84, 9), End: Pos(84, 73)>,
StatementAssertion<Begin: Pos(85, 9), End: Pos(85, 68)>,
StatementAssertion<Begin: Pos(86, 9), End: Pos(86, 72)>,
StatementAssertion<Begin: Pos(87, 9), End: Pos(87, 72)>,
StatementAssertion<Begin: Pos(88, 9), End: Pos(88, 79)>,
StatementAssertion<Begin: Pos(89, 9), End: Pos(89, 79)>,
StatementAssertion<Begin: Pos(90, 9), End: Pos(90, 66)>,
StatementAssertion<Begin: Pos(91, 9), End: Pos(91, 66)>,
StatementAssertion<Begin: Pos(92, 9), End: Pos(92, 63)>,
StatementAssertion<Begin: Pos(93, 9), End: Pos(93, 75)>,
StatementAssertion<Begin: Pos(94, 9), End: Pos(94, 79)>,
StatementAssertion<Begin: Pos(95, 9), End: Pos(95, 75)>,
StatementAssertion<Begin: Pos(96, 9), End: Pos(96, 64)>,
StatementAssertion<Begin: Pos(97, 9), End: Pos(97, 80)>,
StatementAssertion<Begin: Pos(98, 9), End: Pos(98, 62)>,
StatementAssertion<Begin: Pos(99, 9), End: Pos(99, 63)>,
StatementAssertion<Begin: Pos(100, 9), End: Pos(100, 64)>,
StatementAssertion<Begin: Pos(101, 9), End: Pos(101, 64)>,
StatementAssertion<Begin: Pos(102, 9), End: Pos(102, 66)>,
StatementAssertion<Begin: Pos(103, 9), End: Pos(103, 83)>,
StatementAssertion<Begin: Pos(105, 9), End: Pos(105, 58)>,
StatementAssertion<Begin: Pos(106, 9), End: Pos(106, 60)>,
StatementAssertion<Begin: Pos(107, 9), End: Pos(107, 64)>,
StatementAssertion<Begin: Pos(108, 9), End: Pos(108, 64)>,
StatementAssertion<Begin: Pos(109, 9), End: Pos(109, 50)>,
StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 64)>,
StatementAssertion<Begin: Pos(111, 9), End: Pos(111, 71)>,
StatementAssertion<Begin: Pos(112, 9), End: Pos(112, 72)>,
StatementAssertion<Begin: Pos(113, 9), End: Pos(113, 63)>,
StatementAssertion<Begin: Pos(114, 9), End: Pos(114, 65)>,
StatementAssertion<Begin: Pos(115, 9), End: Pos(115, 65)>,
StatementAssertion<Begin: Pos(116, 9), End: Pos(116, 67)>,
StatementAssertion<Begin: Pos(117, 9), End: Pos(117, 63)>,
StatementAssertion<Begin: Pos(118, 9), End: Pos(118, 65)>,
StatementAssertion<Begin: Pos(120, 9), End: Pos(120, 74)>,
StatementAssertion<Begin: Pos(121, 9), End: Pos(121, 91)>,
StatementAssertion<Begin: Pos(122, 9), End: Pos(122, 90)>,
StatementAssertion<Begin: Pos(123, 9), End: Pos(123, 76)>,
StatementAssertion<Begin: Pos(124, 9), End: Pos(124, 93)>,
StatementAssertion<Begin: Pos(125, 9), End: Pos(125, 92)>,
StatementAssertion<Begin: Pos(126, 9), End: Pos(126, 74)>,
StatementAssertion<Begin: Pos(127, 9), End: Pos(127, 91)>,
StatementAssertion<Begin: Pos(128, 9), End: Pos(128, 90)>,
]
---
    public void testCoreFunctions$catena_0() {
        assertXPathValue(context, "string(2)", "2");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_1() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "string($nan)", "NaN");                                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_2() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "string(-$nan)", "NaN");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_3() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_4() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "string(2 div 0)", "Infinity");                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_5() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_6() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_7() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_8() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_9() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_10() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_11() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_12() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 2, 3)", "234");                                       /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_13() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 2)", "2345");                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_14() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                                   /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_15() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 0, 3)", "12");                                        /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_16() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_17() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_18() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_19() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_20() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 6, 6)", "");                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_21() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 7, 8)", "");                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_22() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "substring('12345', 7)", "");                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_23() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "string-length('12345')", new Double(5));                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_24() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_25() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "normalize-space('abc def')", "abc def");                                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_26() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "normalize-space('   ')", "");                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_27() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_28() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                              /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_29() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_30() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_31() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean('')", Boolean.FALSE);                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_32() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                          /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_33() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                         /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_34() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        assertXPathValue(context, "true()", Boolean.TRUE);                                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_35() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "false()", Boolean.FALSE);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_36() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "not(false())", Boolean.TRUE);                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_37() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "not(true())", Boolean.FALSE);                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_38() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "null()", null);                                                  /***** ORIGINAL ASSERTION IS HERE *****/        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_39() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        assertXPathValue(context, "number('1')", new Double(1));                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_40() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "number($bool_true)", new Double(1));                                     /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_41() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "number($bool_false)", new Double(0));                                    /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_42() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "floor(1.5)", new Double(1));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_43() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "floor(-1.5)", new Double(-2));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_44() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "ceiling(1.5)", new Double(2));                                           /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_45() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                         /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_46() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "round(1.5)", new Double(2));                                             /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_47() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "round(-1.5)", new Double(-1));                                           /***** ORIGINAL ASSERTION IS HERE *****/

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_48() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_49() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_50() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_51() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_52() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));               /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_53() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_54() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                                  /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_55() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));                 /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testCoreFunctions$catena_56() {
        try{ assertXPathValue(context, "string(2)", "2");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string($nan)", "NaN");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-$nan)", "NaN");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(-2 div 0)", "-Infinity");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string(2 div 0)", "Infinity");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "concat('a', 'b', 'c')", "abc");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-before('1999/04/01', '/')",
            "1999");                                                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(
            context,
            "substring-after('1999/04/01', '/')",
            "04/01");                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2, 3)", "234");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 2)", "2345");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");                              }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0, 3)", "12");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 6, 6)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7, 8)", "");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "substring('12345', 7)", "");                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "string-length('12345')", new Double(5));                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('abc def')", "abc def");                            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "normalize-space('   ')", "");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(1)", Boolean.TRUE);                                         }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(0)", Boolean.FALSE);                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('x')", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean('')", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list)", Boolean.TRUE);                                     }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "boolean(/list[position() < 1])", Boolean.FALSE);                    }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "true()", Boolean.TRUE);                                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "false()", Boolean.FALSE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(false())", Boolean.TRUE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "not(true())", Boolean.FALSE);                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "null()", null);                                             }catch(Throwable __SHOULD_BE_IGNORED){}        
        try{ assertXPathValue(context, "number('1')", new Double(1));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_true)", new Double(1));                                }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "number($bool_false)", new Double(0));                               }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(1.5)", new Double(1));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-1.5)", new Double(-2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(1.5)", new Double(2));                                      }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-1.5)", new Double(-1));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(1.5)", new Double(2));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-1.5)", new Double(-1));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

        try{ assertXPathValue(context, "floor('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "floor(2 div 0)", new Double(Double.POSITIVE_INFINITY));             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling('NaN')", new Double(Double.NaN));                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));          }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "ceiling(2 div 0)", new Double(Double.POSITIVE_INFINITY));           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round('NaN')", new Double(Double.NaN));                             }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "round(-2 div 0)", new Double(Double.NEGATIVE_INFINITY));            }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "round(2 div 0)", new Double(Double.POSITIVE_INFINITY));                  /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
--------------------
Run: JxPath_6
@@@
Split test: org.apache.commons.jxpath.ri.compiler.VariableTest::testIterateVariable
file: /tmp/JxPath_6/src/test//org/apache/commons/jxpath/ri/compiler/VariableTest.java
Begin: Pos(276, 12)
End: Pos(280, 5)
Source: /tmp/JxPath_6/src/test//org/apache/commons/jxpath/ri/compiler/VariableTest.java
Name: testIterateVariable
Childs: [StatementAssertion<Begin: Pos(277, 9), End: Pos(277, 64)>,
StatementAssertion<Begin: Pos(278, 9), End: Pos(278, 60)>,
StatementAssertion<Begin: Pos(279, 9), End: Pos(279, 60)>,
]
---
    public void testIterateVariable$catena_0() throws Exception {
        assertXPathValueIterator(context, "$d", list("a", "b"));                                            /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$d = 'a'", Boolean.TRUE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$d = 'b'", Boolean.TRUE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIterateVariable$catena_1() throws Exception {
        try{ assertXPathValueIterator(context, "$d", list("a", "b"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$d = 'a'", Boolean.TRUE);                                                /***** ORIGINAL ASSERTION IS HERE *****/
        try{ assertXPathValue(context, "$d = 'b'", Boolean.TRUE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    }
---
---
    public void testIterateVariable$catena_2() throws Exception {
        try{ assertXPathValueIterator(context, "$d", list("a", "b"));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
        try{ assertXPathValue(context, "$d = 'a'", Boolean.TRUE);                                           }catch(Throwable __SHOULD_BE_IGNORED){}
        assertXPathValue(context, "$d = 'b'", Boolean.TRUE);                                                /***** ORIGINAL ASSERTION IS HERE *****/
    }
---
---
check list:
Cli_23@org.apache.commons.cli.bug.BugCLI162Test::testPrintHelpLongLines
Compress_4@org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields
Csv_8@org.apache.commons.csv.CSVFormatTest::testDuplicateHeaderElements
Jsoup_66@org.jsoup.nodes.ElementTest::testNextElementSiblingAfterClone
---
exception list:
Cli_30@org.apache.commons.cli.BasicParserTest::testPropertyOptionGroup
Cli_30@org.apache.commons.cli.BasicParserTest::testPropertyOptionUnexpected
Cli_30@org.apache.commons.cli.DefaultParserTest::testPropertyOptionGroup
Cli_30@org.apache.commons.cli.DefaultParserTest::testPropertyOptionUnexpected
Cli_30@org.apache.commons.cli.GnuParserTest::testPropertyOptionGroup
Cli_30@org.apache.commons.cli.GnuParserTest::testPropertyOptionUnexpected
Cli_30@org.apache.commons.cli.PosixParserTest::testPropertyOptionGroup
Cli_30@org.apache.commons.cli.PosixParserTest::testPropertyOptionUnexpected
Cli_22@org.apache.commons.cli.PosixParserTest::testStopAtExpectedArg
Cli_16@org.apache.commons.cli2.commandline.DefaultingCommandLineTest::testGetOptions_Order
Cli_16@org.apache.commons.cli2.commandline.PreferencesCommandLineTest::testGetOptions_Order
Cli_16@org.apache.commons.cli2.commandline.PropertiesCommandLineTest::testGetOptions_Order
Cli_16@org.apache.commons.cli2.commandline.WriteableCommandLineImplTest::testGetOptions_Order
Cli_27@org.apache.commons.cli.BasicParserTest::testOptionGroupLong
Cli_27@org.apache.commons.cli.GnuParserTest::testOptionGroupLong
Cli_27@org.apache.commons.cli.PosixParserTest::testOptionGroupLong
Codec_1@org.apache.commons.codec.language.CaverphoneTest::testLocaleIndependence
Codec_1@org.apache.commons.codec.language.DoubleMetaphoneTest::testLocaleIndependence
Codec_1@org.apache.commons.codec.language.MetaphoneTest::testLocaleIndependence
Codec_1@org.apache.commons.codec.language.RefinedSoundexTest::testLocaleIndependence
Codec_1@org.apache.commons.codec.language.SoundexTest::testLocaleIndependence
JxPath_17@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute
JxPath_17@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisAttribute
JxPath_11@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testNamespaceMapping
JxPath_11@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testNamespaceMapping
JxPath_18@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute
JxPath_18@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisAttribute
JxPath_15@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testUnion
JxPath_15@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testUnion
JxPath_16@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisFollowing
JxPath_16@org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisPreceding
JxPath_16@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisFollowing
JxPath_16@org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisPreceding
